{"meta":{"title":"William's 隨手札記","subtitle":"Blog of William","description":"Just record it.","author":"William L.K.","url":"http://a10000005588.github.io"},"pages":[{"title":"Just Do It.","date":"2019-02-05T11:53:34.000Z","updated":"2020-07-26T08:50:03.370Z","comments":true,"path":"about/index.html","permalink":"http://a10000005588.github.io/about/index.html","excerpt":"","text":"Hi 我叫William ，這裡是我用來記錄我各種學習的筆記，看自己成長過程的地方。 如果在看我寫的文章筆記時想要回饋時，可以直接在下方留言。若有我觀念或紀錄錯誤的地方也請多多指教與留言，Thanks!"}],"posts":[{"title":"樣板模式 Template Pattern [Design Pattern in Java]","slug":"Design-Pattern-Java-Template-Pattern-樣板模式","date":"2020-07-29T15:33:47.000Z","updated":"2020-07-29T15:39:08.891Z","comments":true,"path":"2020/07/29/Design-Pattern-Java-Template-Pattern-樣板模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/29/Design-Pattern-Java-Template-Pattern-樣板模式/","excerpt":"樣板, 顧名思義就是把同樣的邏輯定義成一個樣板, 可讓其他類別共同使用 樣板也會開放可客製化的方法 (抽象方法), 供其他類別實作","text":"樣板, 顧名思義就是把同樣的邏輯定義成一個樣板, 可讓其他類別共同使用 樣板也會開放可客製化的方法 (抽象方法), 供其他類別實作 樣板主要核心 將共同演算法邏輯包裝好 定義非共同的方法為抽像方法, 請使用樣板方法的類別自行實作 透過泡茶與泡咖啡來瞭解樣板模式吧這時候若直接寫code, 會分別定義出 Tea 與 Coffee class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Tea &#123; Tea() &#123;&#125; public void prepare() &#123; System.out.println(\"=======開始準備茶的動作=======\"); boilWater(); steepTeaBag(); addLenmon(); pourIntoCup(); System.out.println(\"=======結束=======\"); &#125; private void boilWater() &#123; System.out.println(\"燒開水\"); &#125; private void steepTeaBag() &#123; System.out.println(\"泡開茶包\"); &#125; private void addLenmon() &#123; System.out.println(\"加入檸檬\"); &#125; private void pourIntoCup() &#123; System.out.println(\"倒入杯中\"); &#125;&#125;class Coffee &#123; Coffee() &#123;&#125; public void prepare() &#123; System.out.println(\"=======開始準備咖啡的動作=======\"); boilWater(); greedCoffeeGrinds(); addCreamer(); pourIntoCup(); System.out.println(\"=======結束=======\"); &#125; private void boilWater() &#123; System.out.println(\"燒開水\"); &#125; private void greedCoffeeGrinds() &#123; System.out.println(\"磨咖啡豆\"); &#125; private void addCreamer() &#123; System.out.println(\"加奶精\"); &#125; private void pourIntoCup() &#123; System.out.println(\"倒入杯中\"); &#125;&#125; 使用以上定義的方法 123456789public class main &#123; public static void main(String[] args) &#123; Tea tea = new Tea(); tea.prepare(); Coffee coffee = new Coffee(); coffee.prepare(); &#125;&#125; 套用Template Pattern吧仔細比較泡茶和泡咖啡, 都會有著以下類似的動作 煮沸開水 將(茶的茶包/咖啡藥磨成粉)泡開 &lt;– 這個動作一樣, 但茶是用茶包, 咖啡是需要先磨成粉 添加有的沒的 (咖啡會用奶精/茶會放檸檬) &lt;– 這邊的也是一樣 倒進杯中 剛好茶與咖啡都是含有咖啡因的飲料，這時就可以定義一個樣板叫做 CaffeineBeverage, 並把上述 2,3步驟,定義成抽象方法, 讓茶與咖啡類別自己去實作自己的邏輯 12345678910111213141516171819202122232425262728abstract class CaffeineBeverage &#123; String name = \"咖啡因飲料\"; CaffeineBeverage(String name) &#123; this.name = name; &#125; public void prepare() &#123; System.out.println(\"=======開始準備 \" + this.name + \" 的動作=======\"); boilWater(); brew(); addCondiments(); pourIntoCup(); System.out.println(\"=======結束=======\"); &#125; private void boilWater() &#123; System.out.println(\"燒開水\"); &#125; // 定義如何泡的抽象方法, 讓茶與咖啡自行定義 abstract void brew(); // 定義要添加其他配料, 讓茶與咖啡自行定義 abstract void addCondiments(); private void pourIntoCup() &#123; System.out.println(\"倒進杯中\"); &#125;&#125; 接著Tea與Coffee實現該樣板類別 CaffeineBeverage並根據自己的邏輯實作abstract方法 brew()與addCondiments() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Tea extends CaffeineBeverage &#123; Tea(String name) &#123; super(name); &#125; public void prepare() &#123; System.out.println(\"=======開始準備茶的動作=======\"); boilWater(); brew(); addCondiments(); pourIntoCup(); System.out.println(\"=======結束=======\"); &#125; @Override void brew() &#123; System.out.println(\"泡開茶包\"); &#125; @Override void addCondiments() &#123; System.out.println(\"加入檸檬\"); &#125;&#125;class Coffee extends CaffeineBeverage&#123; Coffee(String name) &#123; super(name); &#125; public void prepare() &#123; System.out.println(\"=======開始準備咖啡的動作=======\"); boilWater(); brew(); addCondiments(); pourIntoCup(); System.out.println(\"=======結束=======\"); &#125; @Override void brew() &#123; System.out.println(\"磨咖啡豆\"); &#125; @Override void addCondiments() &#123; System.out.println(\"加奶精\"); &#125;&#125; 接著一樣使用之 123456789public class main &#123; public static void main(String[] args) &#123; CaffeineBeverage tea = new Tea(\"茶\"); tea.prepare(); CaffeineBeverage coffee = new Coffee(\"咖啡\"); coffee.prepare(); &#125;&#125; 小結透過以上方法可以看到 樣板模式 將重複的地方給統整起來成為演算法邏輯, 並定義一個抽象類別, 將需要客製化的部分定義成抽象方法, 統一的部分就直接定義實體方法 如此一來各個類別在實作時，就不用在自己去做重複一樣的動作(例如燒開水, 倒入杯中) 只要直接繼承樣板抽象類別就有囉, 然後在自己實作自己需要的部分 (如茶有自己的茶包泡法, 咖啡則有自己的咖啡豆要磨 才能泡) 以實現樣板模式的精神 透過hook方法將封裝的演算法邏輯部分做控制使用待補充","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"}]},{"title":"Facade Pattern 表象模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Facade-Pattern-表象模式","date":"2020-07-29T12:20:24.000Z","updated":"2020-07-29T15:41:02.366Z","comments":true,"path":"2020/07/29/Design-Pattern-Java-Facade-Pattern-表象模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/29/Design-Pattern-Java-Facade-Pattern-表象模式/","excerpt":"將複雜的類別關係, 用一個類別包裝起來, 供呼叫 不會讓使用者直接看到背後複雜的邏輯, 只會看到 “表面的現象”, 故叫做表象模式","text":"將複雜的類別關係, 用一個類別包裝起來, 供呼叫 不會讓使用者直接看到背後複雜的邏輯, 只會看到 “表面的現象”, 故叫做表象模式 以一個家庭劇院來解說如果坐在客廳, 想要營造一個家庭劇院 我們得做以下事情： 打開燈, 調整亮度 打開電視, 切換到DVD模式 打開音響, 調整大小聲 打開DVD, 讀取要看的片 等等之類的, 以下定義這些服務的class 12345678910111213141516171819202122232425262728293031class LightService &#123; LightService() &#123;&#125; public void lightOn() &#123; System.out.println(\"Turn on the light\"); &#125;&#125;class TVService &#123; TVService() &#123;&#125; public void openTV() &#123; System.out.println(\"Turn on the TV\"); &#125;&#125;class SoundService &#123; SoundService() &#123;&#125; public void openSound() &#123; System.out.println(\"Turn on the Sound\"); &#125;&#125;class DVDPlayerService &#123; DVDPlayerService() &#123;&#125; public void openDVD() &#123; System.out.println(\"Turn on the DVD\"); &#125;&#125; 然後直覺上會呼叫之 1234567891011121314public class main &#123; public static void main(String[] args) &#123; LightService lightService = new LightService(); TVService tvService = new TVService(); SoundService soundService = new SoundService(); DVDPlayerService dvdPlayerService = new DVDPlayerService(); lightService.lightOn(); tvService.openTV(); soundService.openSound(); dvdPlayerService.openDVD(); &#125;&#125; 其結果為： 表象模式登場不過對於使用者來說, 其實就只想要享受家庭劇院的娛樂, 所以其實我們可以用包裝的方式, 將上面main裡面相關服務的class都包在一個class內, 叫做MovieTheaterFacadeService 12345678910111213141516class MovieTheaterFacadeService &#123; MovieTheaterFacadeService() &#123;&#125; public void startMovieTheaterService() &#123; LightService lightService = new LightService(); TVService tvService = new TVService(); SoundService soundService = new SoundService(); DVDPlayerService dvdPlayerService = new DVDPlayerService(); lightService.lightOn(); tvService.openTV(); soundService.openSound(); dvdPlayerService.openDVD(); &#125;&#125; 如此一來, 我們的使用者(main()), 只要呼叫 MovieTheaterFacadeService 就可以直接享受家庭劇院, 不用親自去處理過程中的事 1234567public class main &#123; public static void main(String[] args) &#123; MovieTheaterFacadeService movieTheaterFacadeService = new MovieTheaterFacadeService(); movieTheaterFacadeService.startMovieTheaterService(); &#125;&#125; 總結透過以上的例子, 可以看到表象模式最大的用處就是將複雜的服務類別們給包裝在一起, 並開放單一個類別供使用者使用, 讓使用者僅需要看到表面即可, 不用理解細節是什麼。","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"}]},{"title":"Adaptor Pattern 轉接器模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Adaptor-Pattern-轉接器模式","date":"2020-07-29T00:15:30.000Z","updated":"2020-07-29T11:52:08.666Z","comments":true,"path":"2020/07/29/Design-Pattern-Java-Adaptor-Pattern-轉接器模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/29/Design-Pattern-Java-Adaptor-Pattern-轉接器模式/","excerpt":"假如要使用A, 但無法直接使用, 只能使用B介面 所以我們用轉接器類別包裝A的方法，並且實作B，達到轉接的效果","text":"假如要使用A, 但無法直接使用, 只能使用B介面 所以我們用轉接器類別包裝A的方法，並且實作B，達到轉接的效果 用螢幕轉接器的例子直接解釋例如我們有個 HDMI的線, 叫做 HDMI interface 12345interface HDMI &#123; // 定義連接裝置的方法格式 boolean connect(String device);&#125; 但現在有個螢幕只有支援VGA的插孔 所以我們需要個 HDMI轉VGA的Adaptor類別, 把VGA的類別引入進來, 並使用之 12345678910111213141516class HdmiToVgaAdpator implements HDMI &#123; VGA vgaCable = null; HdmiToVgaAdpator(VGA vgaCable) &#123; this.vgaCable = vgaCable; &#125; // 必須要實作HDMI的方法 public boolean connect(String device) &#123; // 介接Vga線的connect功能 System.out.println(\"使用轉接器的connect功能!\"); vgaCable.connect(device); return true; &#125;&#125; 因為有使用到VGA類別, 所以來定義一下 123456789101112interface VGA &#123; // 定義連接裝置的方法格式 boolean connect(String device);&#125;class VGACable implements VGA &#123; public boolean connect(String device) &#123; System.out.println(\"VGA線連接: \" + device); return true; &#125;&#125; 來定義有台筆電, 是只有具備hdmi孔, 但具備著可以連接到某裝置進行投影 1234567class Labtop &#123; // 該台筆電只有hdmi孔, 並指定要連接的螢幕(device) public void connectToDevice(HDMI hdmi, String device) &#123; System.out.println(\"筆電只有hdmi孔, 使用實作hdmi介面的 'hdmi轉vga的轉接器' 類別！\"); hdmi.connect(device); &#125;&#125; 接著來使用吧 1234567891011public class main &#123; public static void main(String[] args) &#123; Labtop laptop = new Labtop(); // 如果某筆電只有hdmi插孔, 但要接的投影螢幕只有vga laptop.connectToDevice( new HdmiToVgaAdpator( // 這時可以使用Hdmi轉Vga的轉接器！ 轉接器需要帶入實際具有VGA功能的VGA線物件 new VGACable()), \"老舊投影機\"); &#125;&#125; 我們可以看到結果為: 筆電使用了 實作hdmi介面的轉接器 (轉接器因為實作了hdmi interface, 所以可以插入筆電的hdmi孔) 接著轉接器引入了VGA cable類別, 故轉接器就可以使用VGA的connect()功能 最後就觸發VGA功能, 與投影裝置連動 實際應用場景通常轉接器模式可用在轉接那些已經過時的模組&amp;方法 例如有模組是用Java較舊迭代Collection的版本去寫的, 為Enumeration Interface 但現在新的專案中，是使用Iterator方式去迭代Collection 12345678910class NewLoopService &#123; // 使用Java 5版本之後支援的Iterator public void loopCollection(Collection col, Iterator itr) &#123; itr = col.iterator(); while(itr.hasNext()) &#123; System.out.println(itr.next()); &#125; &#125;&#125; 使用NewLoopService12345678910111213class main() &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"apple\"); list.add(\"banana\"); // 宣告Iterator的變數 Iterator itr; NewLoopService loopService = new NewLoopService(); loopService.loopCollection(list, itr); &#125;&#125; 但現在若只能用舊版的 Enumeration 方式去迭代 這時就可以寫一個 EnumeratorAdaptor 來實作可兼容Iterator的類別, 並可呼叫 Enumeration的方法 1234567891011121314151617181920212223// 實作Iterator的方法class EnumeratorAdaptor&lt;E&gt; implement Iterator &#123; Enumeration&lt;E&gt; enumeration; EnumeratorAdaptor(Enumeration&lt;E&gt; enumeration) &#123; this.enumeration = enumeration; &#125; // 實作Iterator 介面所需的方法 public boolean hasNext() &#123; // 但實際上是使用Enumeration的方法 return this.enumeration.hasMoreElements(); &#125; public Object next() &#123; return this.enumeration.nextElement(); &#125; // 但這時候會遇到Enumeration沒有的方法, 但又必須要實作 滿足Iterator的介面規範, 這時可以throw Exception來處理 public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125; 這時我們可以在main()中改用轉接器, 來間接使用Enumeration了！ 1234567891011121314151617181920212223242526class main() &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"apple\"); list.add(\"banana\"); // 使用 `實作Iterator介面` 的轉接器 EnumeratorAdaptor itr; NewLoopService loopService = new NewLoopService(); loopService.loopCollection(list, itr); &#125;&#125;class NewLoopService &#123; // 使用Java 5版本之後支援的Iterator public void loopCollection(Collection col, Iterator itr) &#123; itr = col.iterator(); // 這時會是使用EnumeratorAdaptor內的hasNext()與next() 達到轉接的效果 while(itr.hasNext()) &#123; System.out.println(itr.next()); &#125; &#125;&#125; 透過以上方法, 可以把要使用Enumeration方式的service, 但該Service又是只能吃Iterator的輸入, 那就可以實作一個 EnumeratorAdaptor, 帶入Service, 並透過轉接器使用 Enumeration的方式去撈出Collection內容.","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"}]},{"title":"Observer Pattern 觀察者模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Observer-Pattern-觀察者模式","date":"2020-07-26T08:59:48.000Z","updated":"2020-07-29T11:50:21.853Z","comments":true,"path":"2020/07/26/Design-Pattern-Java-Observer-Pattern-觀察者模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/26/Design-Pattern-Java-Observer-Pattern-觀察者模式/","excerpt":"觀察者模式可以讓物件了解資料變化的情況。物件甚至可以在執行期間決定是否要繼續被通知，又或者是可以主動去詢問資料的狀態。在此模式中也會了解一對多，以及物件鬆綁的意義是如何。","text":"觀察者模式可以讓物件了解資料變化的情況。物件甚至可以在執行期間決定是否要繼續被通知，又或者是可以主動去詢問資料的狀態。在此模式中也會了解一對多，以及物件鬆綁的意義是如何。 以氣象監測系統的概況來當做例子假設系統中有三個組成要件：(1) 氣象站: 獲取實際氣象的物理裝置，假設有三個:溫度,濕度,壓力感應(2) Weather Data物件: 追蹤來自氣象站的資料，並且顯示在佈告版上(3) 佈告版: 將Weather Data物件給予的資料呈現出來 整個例子會有，一個氣象站(產出假的氣象資料)，Weather Data物件(獲取氣象資料並通知佈告版)，佈告版將拿到的資料給呈現出來 沒使用觀察者模式 Observer Pattern的情況初學者會很直覺的寫出這樣的程式架構： 佈告欄CurrentConditionsDisplay.class123456789101112131415161718public class CurrentConditionsDisplay &#123; private int temp; private int humidity; private int pressure; public void update() &#123; this.temp = temp; this.humidity = humidity; this.pressure = pressure; &#125; // 顯示資料 public void display() &#123; System.out.println(temp); System.out.println(humidity); System.out.println(pressure); &#125;&#125; WeatherData.class1234567891011121314151617181920212223242526272829303132public class WeatherData &#123; // instance variable declarations // 宣告佈告欄 CurrentConditionsDisplay currentConditionsDisplay; StatisticsDisplay statisticsDisplay; // 建構子 public WeatherData( CurrentConditionsDisplay currentConditionsDisplay, StatisticsDisplay statisticsDisplay ) &#123; this.currentConditionsDisplay = currentConditionsDisplay; this.statisticsDisplay = statisticsDisplay; &#125; public int getTemperature() &#123;...&#125; public int getHumidity() &#123;...&#125; public int getPressure() &#123;...&#125; public void measurementsChanged() &#123; float temp = getTemperature(); float humidity = getHumidity(); float pressure = getPressure(); // 對佈告欄類別進行更新他們的顯示內容 currentConditionsDisplay.update(temp, humidity, pressure); statisticsDisplay.update(temp, humidity, pressure); // 其他WeatherData function... &#125;&#125; 但是以上程式結構會有耦合性的狀況： 所以接下來來了解觀察者模式的內涵 觀察者模式解析定義了物件之間一對多關係，如此一來，當一個物件改變狀態時，其他相依者都會收到通知並自動做改變 其示意圖如下： 主題與觀察者們定義了一對多的關係 若要實踐出可以隔離主題和觀察者們的方式，以 Subject介面和Observer介面最為常見 在這張圖要注意一個重點是，由於現在已經針對介面實作，現在的Subject中的註冊Observer都是以註冊”介面“為主！而非是像上面一開始的新手例子是直接針對實踐而寫 如此一來如果要在新增一個佈告欄叫做ForecastDisplay，直接實踐Observer就好，這樣就不用動到實踐Subject介面的WeatherData之程式碼 以觀察者模式來重寫氣象監測系統Subject.interface 12345public interface Subject &#123; void registerObserver(Observer o); void removeObserver(Observer o); void notifyObservers();&#125; ObserverInterface 123public interface Observer &#123; void update(float temperature, float humidity, float pressure);&#125; WeatherData.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.ArrayList;public class WeatherData implements Subject&#123; private ArrayList observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList(); &#125; public void registerObserver(Observer o) &#123; int i = observers.indexOf(o); observers.add(o); &#125; public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if(i&gt;=0) &#123; observers.remove(i); &#125; &#125; // 向觀察者們送以改動的資料 // 可以看到現在我們是直接註冊Observer介面，如此一來觀察者類別的實作就不用去在意 // 只要知道要註冊的對象必須要有實作Observer介面就好 public void notifyObservers() &#123; for(int i=0; i&lt;observers.size(); i++) &#123; Observer observer = (Observer)observers.get(i); observer.update(temperature, humidity, pressure); &#125; &#125; // 執行向觀察者們通知資料 public void measurementsChanged() &#123; notifyObservers(); &#125; // 讀取假資料，可以改動這地方，改為向氣象局網站爬資料 public void setMeasurements( float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125;&#125; 這裡我們只實踐一個佈告欄 CurrentConditionDisplay CurrentConditionDisplay.java12345678910111213141516171819202122public class CurrentConditionDisplay implements Observer &#123; private float temperature; private float humidity; private float pressure; private Subject weatherData; public CurrentConditionDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; public void update(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; display(); &#125; public void display() &#123; System.out.println(\"Current condition: \"+temperature + \"F degrees and \" + humidity + \"% humidity and \"+ pressure + \" pressure\"); &#125;&#125; 執行程式 12345678910public class Main &#123; public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); CurrentConditionDisplay currentDisplay = new CurrentConditionDisplay(weatherData); weatherData.setMeasurements(80, 64, 30.4f); &#125;&#125; 可以看到以下結果 1Current condition: 80.0F degrees and 64.0% humidity and 30.4 pressure 之後只要透過主題呼叫觀察者的update()的方法，就可以通知新的資料給觀察者 並且透過註冊的方式+只加入針對實踐Observer介面的觀察者，如此一來可以達到分離主題物件與觀察者物件的邏輯，之後新增新的佈告欄就不用動到主題的程式邏輯。 補充java sdk也有自行提供Observer方法其中會有setChange()的方法，主要讓呼叫者定義什麼時候才要通知新的資料給觀察者，避免每次資料一改變就一直通知觀察者。Ex: 如果沒有setChanged的方法，WeahterData物件就會持續不斷的通知觀察者，所以若我們希望溫度差距半度才更新，溫度差距插到半度以上，主題才會呼叫觀察者的update()的方法。 1234567891011121314setChanged() &#123; changed = ture;&#125;tifyObservers(Object arg) &#123; if(changed) &#123; for every observer on the list &#123; call update(this. org) &#125; changed = false; &#125;&#125;notifyObsergers() &#123; notifyObservers(null);&#125;","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"}]},{"title":"Strategy Pattern 策略模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Strategy-Pattern-策略模式","date":"2020-07-26T08:58:12.000Z","updated":"2020-07-29T11:50:37.834Z","comments":true,"path":"2020/07/26/Design-Pattern-Java-Strategy-Pattern-策略模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/26/Design-Pattern-Java-Strategy-Pattern-策略模式/","excerpt":"可以在執行期動態更換物件的行為 『策略模式』定義了演算法家族，將他們個別封裝起來，可以讓他們之間互相替換，此模式不會影響到使用此演算法的程式。","text":"可以在執行期動態更換物件的行為 『策略模式』定義了演算法家族，將他們個別封裝起來，可以讓他們之間互相替換，此模式不會影響到使用此演算法的程式。 沒有思考使用設計模式的時候:模擬鴨子版本假設我們要開發模擬鴨子遊戲，會有各種不同的鴨子，這時候會們通常都會先設計出一個class叫做 Duck，然後Duck會包含鴨子的共同行為：發出叫聲 quack(), 游泳 swin(), 以及展現外觀 display()，然後有綠頭鴨 MallardDuck class和 紅頭鴨 RedheadDuck class分別繼承 Duck類別 (做UML) 若現在需要讓每隻鴨子都會飛，我們會很直覺的在 Duck class中加入 fly() 但若現在有個橡皮鴨子，會不小心繼承到Duck class的fly(), 但橡皮鴨不會飛！ 用繼承的可以改善作法直接在橡皮鴨 class中的fly() 不定義任何事情 (做UML) 問題若又遇到誘餌鴨，就會面臨fly()沒定義任何事情，quack()也沒定義任何事情因為若有很多新型態的鴨子，會導致每一個不同的鴨子都得檢視該鴨子是否可飛或可叫 (做UML) 改用介面做改善將fly與quack從Duck抽離出來變成 Flyable與Quackable介面，讓有需要飛或叫的鴨子實作之 問題重複的程式碼會變超多，因為同樣會飛或叫的鴨子都各自實作了Flyable與Quackable介面的程式碼，該程式碼邏輯都是相同的。 設計守則(一) 找出程式中需要更動之處，並將之獨立出來，不要和那些不需要更動的程式碼混在一起 把會變動的部分取出來並將之封裝起來，以便以後可以輕易地擴充此部分，而不影響不需要更動的部分。 將鴨子的行為從Duck類別取出來！ 抽離會變動的部分成為獨立類別將飛行行為 fly,與呱呱叫行為 quack獨立成class 並且在Duck類別設置 “可以設定行為的方法”，可以在“執行期”動態地改變鴨子的飛行或呱呱叫行為 設計守則(二)寫程式是針對介面而寫，而不是針對實踐 用介面代表每個行為: FlyBehavior, QuackBehavior用各個鴨子的行為類別去實踐FlyBehavior和QuackBehavior介面而不是由Duck類別實踐該介面 :::info寫程式是針對介面去寫：其真正意思是『寫程式是針對超型態(supertype)而寫』 使用超型態的話可以不用理會以後執行時的真正物件型態：為“多型”的實踐 ex: Animal interface { makeSound() }Dog implment Animal { makeSound() { bark() }}Cat implement Animal { makeSound() { meow() }} Animal animal = new Dog();animal.makeSound(); 有個好處是，可以不用直接在一開始僵化某個變數的宣告型態 ex: Dog x = new dog(); // 僵化了x變數為dog型態 而是可以在執行期，也就是使用的時候指定該物件型態 ex: 1234567// 定義getAnimal為回傳Dog();x = getAnimal(); // 得到 Dog型態x.makeSound(); // 發出狗叫聲// 將getAnimal() 中改成傳回Cat();x = getAnimal(); // 得到 Cat型態x.makeSound(); // 發出貓叫聲 ::: 實踐鴨子的行為 FlyBehavior介面，用FlyWithWings(實踐所有有翅膀的丫子會飛的行為)與FlyNoWay(實踐所有不會飛的鴨子的動作)這兩個類別來實作 QuackBehavior介面，用Quack(真的呱呱叫)、Squeak(橡皮吱吱叫)與MuteQuack(叫不出聲音)這三個類別來實作 :::info以上設計將飛行與呱呱叫的行為可以被其他物件再三利用，將鴨子的行為抽離出來::: 問題與思考 是否該先把系統做出來，在看看哪些地方需要更動，再回頭將需更動的邏輯獨立出來？ 答：不儘然，設計系統中可以預先考慮到未來哪些地方可能需要變動 鴨子是不是也可以設計成一個介面？ 答: 不恰當，因為已經將會變動的邏輯(fly與quack)抽離出dock class, 那dock class就可以直接為每隻鴨子都會有同樣邏輯的類別，讓不同類型的鴨子直接繼承使用 整合鴨子的行為將飛行與呱呱叫的動作，委託其他人處理 (在Dock類別中宣告 FlyBehavior與QuackBehavior，透過Behavior介面取得 有實作該Behavior介面的行為們 ex: FlyBehavior介面會有FlyWithNoWings類別實作) 123456789101112public class Duck &#123; FlyBehavior flyBehavior; QuackBehavior quackBehavior; public void performQuack() &#123; quackBehavior.quack(); &#125; public void performFly() &#123; flyBehavior.fly(); &#125;&#125; 現在由綠頭鴨(MallarDuck)來使用Duck的quackBehavior所擁有的有實踐自己的子類別 Quack()用flyBehavior的FlyWithNoWings 且MallarDuck繼承了Duck類別，所以可以使用quackBehavior和flyBehavior取用自己對應的動作12345678910public class MallardDuck extends Duck &#123; // constructor pubilc MallardDuck() &#123; quackBehavior = new Quack(); flyBehavior = new FlyWithNoWings(); &#125; quackBehavior.performQuack(); flyBehavior.performFly();&#125; 完整測試的code：實作一個MiniDuckDuck class12345678910111213141516171819public abstract class Duck &#123; FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck() &#123;&#125; public abstract void display(); public void performFly() &#123; flyBehavior.fly(); &#125; public void performQuack() &#123; quackBehavior.quack(); &#125; public void swim() &#123; System.out.println(\"All ducks float, even decoys!\"); &#125;&#125; FlyBehavior and QuackBehavior介面與實踐之的動作FlyBehavior.inrface123public interface FlyBehavior &#123; void fly();&#125; 各種實踐Fly的類別 FlyWithWings.java12345public class FlyWithWings implements FlyBehavior &#123; public void fly() &#123; System.out.println(\"I am flying\"); &#125;&#125; FlyNoWay.java12345public class FlyNoWay implements FlyBehavior &#123; public void fly() &#123; System.out.println(\"I cannot fly\"); &#125;&#125; QuackBehavior.java123public interface QuackBehavior &#123; public void quack();&#125; 各種實踐Quack的類別 Quack.java12345public class Quack implements QuackBehavior &#123; public void quack() &#123; System.out.println(\"Quack\"); &#125;&#125; MuteQuack.java12345public class MuteQuack implements QuackBehavior &#123; public void quack() &#123; System.out.println(\"&lt;&lt;Silence&gt;&gt;\"); &#125;&#125; Squeak.java12345public class Squeak implements QuackBehavior &#123; public void quack() &#123; System.out.println(\"Squeak\"); &#125;&#125; 實踐綠頭鴨的類別：MallardDuck.java1234567891011public class MallardDuck extends Duck &#123; // constructor public MallardDuck() &#123; quackBehavior = new Quack(); flyBehavior = new FlyWithWings(); &#125; public void display() &#123; System.out.println(\"I am a real Mallard duck\"); &#125;&#125; 測試用類別：MiniDuckSimulator.java12345678910public class MiniDuckSimulator &#123; public static void main(String[] args) &#123; Duck mallard = new MallardDuck(); // 會呼叫 MallardDuck繼承來的performQuack() // 進而委託 quackBehavior處理quack行為，而非在自己class內處理 mallard.performQuack(); mallard.performFly(); &#125;&#125; 動態設定行為在鴨子類別中可以加入設置flyBehavior和quackBehavior的方法 可以隨時呼叫以下方法改變鴨子的行為12345678910public abstract class Duck &#123;... public void setFlyBehavior(FlyBehavior fb) &#123; flyBehavior = fb; &#125; public void setQuackBehavior(QuackBehavior qb) &#123; quackBehavior = qb; &#125;&#125; 例如有個 “模型鴨“ 12345678910public class ModelDuck extends Duck &#123; public ModelDuck() &#123; flyBehavior = new FlyNoWay(); quackBehavior = new Quack(); &#125; public void display() &#123; System.out.println(\"Model duck\"); &#125;&#125; 建立一個新的FlyBehavior型態，具有火箭噴射的功能 12345public class FlyRocketPowered implements FlyBehavior &#123; public void fly() &#123; System.out.println(\"I am flying a rocket\"); &#125;&#125; 改變測試類別，加上模型鴨子，使模型鴨具有火箭動力！ 123456789101112131415public class MiniDuckSimulator &#123; public static void main(String[] args) &#123; Duck mallard = new MallardDuck(); ... /** * 具有噴射動力的模型鴨子 */ Duck modelDuck = new ModelDuck(); modelDuck.performFly(); // 不會飛 // 動態地更換飛行的行為 modelDuck.setFlyBehavior(new FlyRocketPowered()); modelDuck.performFly(); // 噴射！ &#125;&#125; 以上的行為為將兩個類別(FlyBehavior與QuackBehavior)組合起來使用，為”Composition 合成”的精神，與繼承不一樣的是，鴨子Duck的行為不是繼承而來，而是透過適當的行為物件『合成』而來！ 設計守則多用合成，少用繼承 合成可以將演算法封裝成類別，更可以『在執行動態地改變行為』，只要合成的行為物件，符合特定的介面標準即可","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"}]},{"title":"Factory Pattern 工廠模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Factory-Pattern-工廠模式","date":"2020-07-26T08:57:20.000Z","updated":"2020-07-29T11:50:13.089Z","comments":true,"path":"2020/07/26/Design-Pattern-Java-Factory-Pattern-工廠模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/26/Design-Pattern-Java-Factory-Pattern-工廠模式/","excerpt":"工廠模式提供了可創建(new)各種不同類別(class)的實例(instance) 工廠模式主要又涵蓋了 (1) 簡單工廠模式 Simple Factory Pattern (2) 工廠方法模式 (3) 抽象方法模式 簡單工廠方法是最初階的用法，會違反OOP的Open-close principle(OCP)然而工廠方法和抽象方法則比較能讓模組間耦合度降低。 以下會依序做介紹","text":"工廠模式提供了可創建(new)各種不同類別(class)的實例(instance) 工廠模式主要又涵蓋了 (1) 簡單工廠模式 Simple Factory Pattern (2) 工廠方法模式 (3) 抽象方法模式 簡單工廠方法是最初階的用法，會違反OOP的Open-close principle(OCP)然而工廠方法和抽象方法則比較能讓模組間耦合度降低。 以下會依序做介紹 簡單工廠模式 Simple Factory Method簡單工廠模式僅提供一個工廠類別，接收參數(決定生產哪種產品)，來產生出對應的產品物件(Object) 以生產Pizza為例，假設我們有個披薩簡單工廠(SimplePizzaFactory)可以生產兩種不同口味的Pizza(Cheese和Potato): SimplePizzaFactory.java 123456789101112public class SimplePizzaFactory &#123; public Pizza createPizza(String type) &#123; Pizza pizza = null; if(type.equals(\"cheese\")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals(\"potato\")) &#123; pizza = new PotatoPizza(); &#125; return pizza; &#125;&#125; 工廠會回傳抽象的Pizza類別 Pizza.java1234567891011121314151617public abstract class Pizza &#123; String name; String ingridient; void prepare() &#123; System.out.println(\"Preparing\" + name); System.out.println(\"Ingredient\" + ingridient); &#125; void bake() &#123; System.out.println(\"Bake for 20 mins\"); &#125; String getName() &#123; return name; &#125;&#125; 以及實作了兩個口味的披薩 CheesePizza和PotatoPizza CheesePizza.java12345public class CheesePizza extends Pizza &#123; String name = \"CheesePizza\"; String ingridient = \"Cheese\";&#125; PotatoPizza.java1234public class PotatoPizza extends Pizza &#123; String name = \"PotatoPizza\"; String ingridient = \"Potato\";&#125; Pizza都定義完畢後，定義SimplePizzaFactory.java SimplePizzaFactory.java123456789101112131415161718public class SimplePizzaFactory &#123; public void orderPizza(String type) &#123; Pizza pizza = null; pizza = createPizza(type); pizza.prepare(); pizza.bake(); &#125; public Pizza createPizza(String type) &#123; Pizza pizza = null; if(type.equals(\"cheese\")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals(\"potato\")) &#123; pizza = new PotatoPizza(); &#125; return pizza; &#125;&#125; 在Main.java透過SimplePizzaFactory製作兩個Pizza: Main.java123456789public class Main &#123; public static void main(String[] args) &#123; SimplePizzaFactory simplePizzaFactory = new SimplePizzaFactory(); simplePizzaFactory.orderPizza(\"cheese\"); simplePizzaFactory.orderPizza(\"potato\"); &#125;&#125; 執行Main.java 123456Preparing: CheesePizzaIngredient: CheeseBake for 20 minsPreparing: PotatoPizzaIngredient: PotatoBake for 20 mins 但此若之後要擴充Pizza的種類，例如要多一個叫做OnionPizza，勢必得修改SimplePizzaFacotory.java SimplePizzaFactory.java1234567891011121314151617181920public class SimplePizzaFactory &#123; public void orderPizza(String type) &#123; Pizza pizza = null; pizza = createPizza(type); pizza.prepare(); pizza.bake(); &#125; public Pizza createPizza(String type) &#123; Pizza pizza = null; if(type.equals(\"cheese\")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals(\"potato\")) &#123; pizza = new PotatoPizza(); &#125; else if (type.equals(\"onion\")) &#123; // 新增洋蔥口味pizza pizza = new OnionPizza(); &#125; return pizza; &#125;&#125; :::danger上述做法破壞了OOD的OCP(Open-Close Principle)的原則，亦即進行擴充時不修改到SimplePizzaFactory的程式碼。::: 工廠方法模式為了改善簡單工廠模式，工廠方法模式透過”抽象方法”的模式，讓之後擴充的工廠實作該”抽象方法”，以進行其他類別的擴充 舉例：有個PizzaFactory負責定義了Pizza工廠該做的一件事(抽象方法)叫做 createPizza(); PizzaFactory.java 12345678910public abstract class PizzaFactory &#123; public void orderPizza(String type) &#123; Pizza pizza = null; pizza = createPizza(type); pizza.prepare(); pizza.bake(); &#125; abstract Pizza createPizza(String type);&#125; 原本我們已經有兩種口味(Cheese和Potato) Pizza，叫做原味披薩(OriginalPizzaFactory), 使OringinalPizzaFactory去實作PizzaFactory的createPizza()方法 OringinalPizzaFactory.java123456789101112public class OriginalPizzaFactory extends PizzaFactory &#123; public Pizza createPizza(String type) &#123; Pizza pizza = null; if(type.equals(\"cheese\")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals(\"potato\")) &#123; pizza = new PotatoPizza(); &#125; return pizza; &#125;&#125; 若要新增洋蔥口味的Pizza的話，那就直接在定義一個額外的工廠叫做，特別披薩工廠 (SpecialPizzaFactory)進行擴充，如此一來就不用更動到到原本原味披薩工廠(OriginalPizzaFactory)的程式碼 SpecialPizzaFactory.java123456789public class SpecialPizzaFactory extends PizzaFactory &#123; public Pizza createPizza(String type) &#123; Pizza pizza = null; if(type.equals(\"onion\")) &#123; pizza = new OnionPizza(); &#125; return pizza; &#125;&#125; 記得多新增一個洋蔥披薩的類別 OnionPizza.java123456public class OnionPizza extends Pizza &#123; public OnionPizza() &#123; name = \"OnionPizza\"; ingridient = \"Onion\"; &#125;&#125; 在Main.java中呼叫原味和特別口味的披薩 Main.java1234567891011public class Main &#123; public static void main(String[] args) &#123; PizzaFactory originalPizzaFactory = new OriginalPizzaFactory(); originalPizzaFactory.orderPizza(\"cheese\"); originalPizzaFactory.orderPizza(\"potato\"); PizzaFactory specialPizzaFactory = new SpecialPizzaFactory(); specialPizzaFactory.orderPizza(\"onion\"); &#125;&#125; 透過下面的圖可以看到，透過定義一個抽象方法的工廠，若要擴充產品(在這裡我們用的是Pizza)類別的話，透過實作該抽象方法工廠，來進行擴充。 由於我們亦把Pizza類別給獨立出來成為一個抽象類別，若要新增其他口味的Pizza也可以達到不違反OCP精神的擴充，如下圖所示： 抽象工廠抽象工廠顧名思義就是定義一個抽象介面工廠，欲擴充的話就實作該抽象介面工廠 以披薩原料工廠(PizzaIngredientFactory)為例，有醬料和蔬菜兩種原料：方面給之後我們要製作的中式和美式披薩的原料實作，做擴展： PizzaIngredientFactory.java1234public interface PizzaIngredientFactory &#123; public Sauce createSauce(); public Vegetable createVegetable();&#125; 抽象工廠(原料工廠)在透過工廠方法來製作原料產品我們再分別產生美式版本(AmericaIngredientFactory)和中式版本(ChinesePizzaFactory)的披薩原料工廠，可以看到使用了createSauce和createVegetable，透過工廠方法來產生原料產品 AmericaIngredientFactory.java12345678public class AmericaIngredientFactory implements PizzaIngredientFactory &#123; public Sauce createSauce() &#123; return new TomatoSauce(); &#125; public Vegetable createVegetable() &#123; return new Potato(); &#125;&#125; ChineseIngredientFactory.java12345678public class ChineseIngredientFactory implements PizzaIngredientFactory &#123; public Sauce createSauce() &#123; return new SoySauce(); &#125; public Vegetable createVegetable() &#123; return new Onion(); &#125;&#125; 接著定義剛剛原料工廠有使用到的原料類別們(Sauce: SoySauce與PotatoSauce; Vegetable: Onion和Potato，該原料亦在實作Pizza類別的具體類別亦會用到 :::infoPizza.java123456789public abstract class Pizza &#123; String name; // 在Pizza類別中已經有宣告會用到的原料有哪些，是以介面來實作，方便做擴展 Sauce sauce; Vegetable vegetable; ...&#125; ::: 定義醬料Sauce原料們： Sauce.java12345public abstract class Sauce &#123; String name; public abstract String getSauce();&#125; SoySauce.java12345678910public class SoySauce extends Sauce &#123; public SoySauce() &#123; name = \"soy sauce\"; &#125; public String getSauce() &#123; System.out.println(\"The sauce is :\" + name); return this.name; &#125;&#125; TomatoSauce.java1234567891011public class TomatoSauce extends Sauce &#123; public TomatoSauce() &#123; name = \"tomato sauce\"; &#125; public String getSauce() &#123; System.out.println(\"The sauce is :\" + name); return this.name; &#125;&#125; 接下來換定義Vegetable原料們 Vegetable.java12345public abstract class Vegetable &#123; String name; public abstract String getVegetable();&#125; Onion.java123456789public class Onion extends Vegetable &#123; public Onion() &#123; name = \"onion\"; &#125; public String getVegetable() &#123; System.out.println(\"The vegetable is :\" + name); return this.name; &#125;&#125; Potato.java1234567891011public class Potato extends Vegetable &#123; public Potato() &#123; name = \"potato\"; &#125; public String getVegetable() &#123; System.out.println(\"The vegetable is :\" + name); return this.name; &#125;&#125; 將披薩修改成包含上述原料 (Sauce和Vegetable) Pizza.java123456789101112131415161718192021public abstract class Pizza &#123; String name; Sauce sauce; Vegetable vegetable; // 將prepare修改成抽象，該方法需要收集Pizza所需的原料，原料來自於原料工廠！ public abstract void prepare(); public void bake() &#123; System.out.println(\"Bake for 30 mins\"); &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 定義兩個style的Pizza: 中式披薩(Chinese Pizza)和美式披薩(America Pizza)，在這兩隻類別可以看到我們傳入了原料工廠，以決定哪種風格的披薩就用對應風格的原料工廠 ChinesePizza.java1234567891011121314151617public class ChinesePizza extends Pizza &#123; PizzaIngredientFactory ingredientFactory; public ChinesePizza(PizzaIngredientFactory ingredientFactory) &#123; this.ingredientFactory = ingredientFactory; &#125; public void prepare() &#123; System.out.println(\"Preparing: \" + name); sauce = ingredientFactory.createSauce(); sauce.getSauce(); vegetable = ingredientFactory.createVegetable(); vegetable.getVegetable(); &#125;&#125; AmericaPizza.java123456789101112131415161718public class AmericaPizza extends Pizza &#123; PizzaIngredientFactory ingredientFactory; public AmericaPizza(PizzaIngredientFactory ingredientFactory) &#123; this.ingredientFactory = ingredientFactory; &#125; public void prepare() &#123; System.out.println(\"Preparing: \" + name); sauce = ingredientFactory.createSauce(); sauce.getSauce(); vegetable = ingredientFactory.createVegetable(); vegetable.getVegetable(); &#125;&#125; 接著再利用工廠方法，定義中式和美式的披薩工廠，製作出中式和美式的披薩 PizzaFactory.java12345678910public abstract class PizzaFactory &#123; public void orderPizza(String type) &#123; Pizza pizza = null; pizza = createPizza(type); pizza.prepare(); pizza.bake(); &#125; abstract Pizza createPizza(String type);&#125; AmericaPizzaFactory.java123456789101112131415public class AmericaPizzaFactory extends PizzaFactory &#123; protected Pizza createPizza(String style) &#123; Pizza pizza = null; // 使用了美式原料工廠 PizzaIngredientFactory ingredientFactory = new AmericaIngredientFactory(); if(style.equals(\"America\")) &#123; pizza = new AmericaPizza(ingredientFactory); pizza.setName(\"America style pizza\"); &#125; return pizza; &#125;&#125; :::info可以在對美式工廠新增其他種不同口味的Pizza，用不同的原料工廠來達成::: ChinesePizzaFactory.java123456789101112131415public class ChinesePizzaFactory extends PizzaFactory &#123; protected Pizza createPizza(String style) &#123; Pizza pizza = null; // 使用了中式原料工廠 PizzaIngredientFactory ingredientFactory = new ChineseIngredientFactory(); if(style.equals(\"Chinese\")) &#123; pizza = new ChinesePizza(ingredientFactory); pizza.setName(\"Chinese style pizza\"); &#125; return pizza; &#125;&#125; 最後在Main.java中來製作披薩： Main.java1234567891011public class Main &#123; public static void main(String[] args) &#123; PizzaFactory AmericaPizzaFactory = new AmericaPizzaFactory(); AmericaPizzaFactory.orderPizza(\"America\"); PizzaFactory ChinesePizzaFactory = new ChinesePizzaFactory(); ChinesePizzaFactory.orderPizza(\"Chinese\"); &#125;&#125; 可以看到抽象工廠方法可以幫我們把相關產品集結起來(上述例子為原料們)，可以產生出不同組的原料類別們，另外抽象工廠通常還會再搭配工廠方法，來建立其產品(披薩們，各個披薩會用到各個不同的抽象工廠所建立的原料工廠)，如同該連結所做的-&gt;連結在透過工廠方法來製作原料產品)","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"}]},{"title":"Singleton Pattern 獨體模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Singleton-Pattern-獨體模式","date":"2020-07-26T08:56:27.000Z","updated":"2020-07-29T11:50:30.495Z","comments":true,"path":"2020/07/26/Design-Pattern-Java-Singleton-Pattern-獨體模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/26/Design-Pattern-Java-Singleton-Pattern-獨體模式/","excerpt":"每次引用類別都只會產出相同的物件 適合用在: 執行緒池(thread pool)，快取區(cache)，對話盒、處理對話設定和登錄的物件，和驅動程式溝通的物件。","text":"每次引用類別都只會產出相同的物件 適合用在: 執行緒池(thread pool)，快取區(cache)，對話盒、處理對話設定和登錄的物件，和驅動程式溝通的物件。 作法假如有一個類別叫做MyClass，現在要讓MyClass變成獨體模式，讓外面的類別只能透過 MyClass.getInstance() 取得MyClass物件。 12345678910111213141516public class MyClass &#123; // 設定成private與static，不能給外面類別存取 private static MyClass uniqueInstance; // 將建構式設定成 private，這樣就可以避免直接被類別 new出來 private MyClass() &#123;&#125; // 設置成static，使外面類別可以直接存取MyClass.getInstance方法 public static MyClass getInstance() &#123; // 若第一次取得MyClass， new 出MyClass(); if(uniqueInstance == null) &#123; uniqueInstance = new MyClass(); &#125; return uniqueInstance; &#125;&#125; 其他類別要取用MyClass 12345678910public static void main(String args[]) &#123; // 1. 第一次取用getInstance Myclass instance = MyClass.getInstance(); // 2. 第二次取用getInstance時，MyClass的uniqueInstance已經有值了，得到與上面instance一樣的object Myclass instance1 = MyClass.getInstance(); if(instance == instance1) &#123; System.out.println(&quot;instance and instance1 are the same&quot;); &#125;&#125; 多執行緒下獨體模式會遇到的狀況假如有兩個thread(thread 1和thread 2)，同時要跟MyClass取得物件，但會面臨thread1和thread2會取得不同的MyClass物件，情況如下： 解法一：只要把getInstance()給同步化 (會有效能不佳的狀況，可能造成效率下降100倍)12345678910111213public class MyClass &#123; private static MyClass uniqueInstance; private MyClass() &#123;&#125; // 設定成synchronized，就可以讓執行緒依序進入getInstance內 public static synchronized MyClass getInstance() &#123; if(uniqueInstance == null) &#123; uniqueInstance = new MyClass(); &#125; return uniqueInstance; &#125;&#125; 但我們只需要第一次進入getInstance才進行同步化就好，不然其他次要取得uniqueInstnace都得變成同步的方式，造成取用Instance的緩慢 解法二：率先建立實體，不要等到有人呼叫getInstance才new出MyClass實體1234567891011public class MyClass &#123; // 直接初始話MyClass()，並設成private private static MyClass uniqueInstnace = new MyClass(); private MyClass() &#123;&#125; public static MyClass getInstance() &#123; return uniqueInstance; &#125; &#125; 此作法依賴JVM載入此類別時，馬上建立此唯一的獨體物件，JVM保證在任何執行緒存取uniqueInstnace靜態變數之前，一定先建立此實體 解法三：利用 “雙重檢查上鎖” 在getInstance()中減少使用同步化利用雙重檢查上鎖，首先檢查是否實體已經建立了，若沒有，“才”進行同步化，如此一來只有第一次進入getInstance才同步化，才是我們所想要的。 `java=public class MyClass { // volatile為Java 6之後才有的關鍵字，能夠使執行緒們取得相同的uniqueInstance private volatile static MyClass uniqueInstance; private MyClass() {} public static MyClass getInstance() { // 只有第一次才徹底執行以下程式碼 // 當執行緒遇到被宣告成volatile的uniqueInstnace，會變得謹慎 if(uniqueInstance == null) { synchronized(MyClass.class) { // 再檢查一次，若為null則new MyClass(); if(uniqueInstance == null) { uniqueInstance = new MyClass(); } } } return uniqueInstance; } }","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"}]},{"title":"Command Pattern 命令模式 [Design Pattern in Java]","slug":"Design-Pattern-Command-Pattern-命令模式","date":"2020-07-26T08:52:42.000Z","updated":"2020-07-29T11:50:00.570Z","comments":true,"path":"2020/07/26/Design-Pattern-Command-Pattern-命令模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/26/Design-Pattern-Command-Pattern-命令模式/","excerpt":"命令模式主要將執行的命令, 與執行者做鬆綁的動作","text":"命令模式主要將執行的命令, 與執行者做鬆綁的動作 沒有命令模式會是怎樣的寫法？？假如我們現在要寫一個 遙控器 RemoteControl (執行者), 上面會有很多按鈕功能 (命令) 每個按鈕可能都對應各個功能, 例如 打開, 關閉某些房間的燈 於是我們定義了 Light 抽象類別, 有著 on()與off()開關燈的方法, 並且實作了 LivingRoomLight, KitchenLight這兩個房間並繼承 Light抽象類別的方法, 使他們都有開關的功能！ 接著在遙控器 RemoteControl類別內定義了 Light[] 陣列, 儲存欲執行的功能 (實作Light的類別們) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class main &#123; public static void main(String[] args) &#123; // 定義出一個遙控器instance RemoteControl remoteControl = new RemoteControl( new Light[]&#123; new LivingRoomLight(), new KitchenLight() &#125;); // 0: 打開LivingRoom Light // 1: 打開Kitchen Light remoteControl.turnOnLight(0); remoteControl.turnOnLight(1); // 0: 關閉LivingRoom Light // 1: 關閉Kitchen Light remoteControl.turnOffLight(0); remoteControl.turnOffLight(1); &#125;&#125;class RemoteControl &#123; Light[] lights = new Light[10]; RemoteControl(Light[] lights) &#123; // 將傳進來的lights放入到lights內 for(int i=0; i&lt;lights.length; i++) &#123; this.lights[i] = lights[i]; &#125; &#125; public void turnOnLight(int buttonNumber) &#123; this.lights[buttonNumber].on(); &#125; public void turnOffLight(int buttonNumber) &#123; this.lights[buttonNumber].off(); &#125;&#125;abstract class Light &#123; Light() &#123;&#125; abstract void on(); abstract void off();&#125;class LivingRoomLight extends Light &#123; LivingRoomLight() &#123;&#125; @Override public void on() &#123; System.out.println(\"Turn on the living room light\"); &#125; @Override public void off() &#123; System.out.println(\"Turn off the living room light\"); &#125;&#125;class KitchenLight extends Light &#123; KitchenLight() &#123;&#125; @Override public void on() &#123; System.out.println(\"Turn on the kitchen light\"); &#125; @Override public void off() &#123; System.out.println(\"Turn off the kitchem light\"); &#125;&#125; 執行結果如下 問題假如現在又想要添加電視與冷氣開關的功能 TV, AirConditioner, 那不就又要在RemoteControl類別內進行修改 12345678910111213141516171819202122class RemoteControl &#123; // 又新增了HomeDevice陣列...定義家具集合的類別 HomeDevice[] homeDevices = new HomeDevice[10]; Light[] lights = new Light[10]; RemoteControl(Light[] lights) &#123; // 將傳進來的lights放入到lights內 for(int i=0; i&lt;lights.length; i++) &#123; this.lights[i] = lights[i]; &#125; &#125; public void turnOnLight(int buttonNumber) &#123; this.lights[buttonNumber].on(); &#125; public void turnOffLight(int buttonNumber) &#123; this.lights[buttonNumber].off(); &#125; // 又在定義HomeDevice的開關功能...&#125; 可看到每次若要為遙控器類別新增功能, 都要對RemoteControl進行修改的動作, 如此一來可能會造成其他已經內嵌好的功能可能被改壞的狀況發生, 這時我們可以使用 Command 模式 來避免這種狀況發生 Command 命令模式的優勢命令模式可以幫我們把要賦予RemoteControl的這些功能給封裝起來, 成為一個獨立的個體, 不會跟RemoteControl給耦合再一起 (像上面turnOnLight, turnOffLight等功能) 我們可以把 Light 的開關功能都視作為 Command (命令)抽象介面, 該介面包含了一個 execute()功能, 接著由Command (命令)衍伸出 LightOnCommand與LightOffCommand這兩個實作類別, 負責定義Light的開與關的動作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 定義一個命令, 包含的執行execute的動作 */interface Command &#123; void execute();&#125;/** * 實作燈的開關命令 */class Light &#123; void on() &#123; System.out.println(\"Turn on the light\"); &#125;; void off() &#123; System.out.println(\"Turn off the light\"); &#125;;&#125;class LightOnCommand implements Command &#123; Light light; LightOnCommand() &#123; this.light = new Light(); &#125; public void execute() &#123; light.on(); &#125;&#125;class LightOffCommand implements Command &#123; Light light; LightOffCommand() &#123; this.light = new Light(); &#125; public void execute() &#123; light.off(); &#125;&#125;class NoCommand implements Command &#123; NoCommand() &#123;&#125; public void execute() &#123; System.out.println(\"Not yet defined\"); &#125;&#125; 接著我們需要在遙控器類別 RemoteControl 定義可放置Command的動作 setXXXCommand(), 以及呼叫Command的 pressOnButton()與pressOffButton() 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 定義遙控器類別 */class RemoteControl &#123; Command[] onCommands = new Command[7]; Command[] offCommands = new Command[7]; // 初始化一開始的插槽, 若沒功能就定義一個沒作用的command供呼叫 (可避免用 if (command != null) 這種判斷方式 RemoteControl() &#123; for(int i=0; i&lt;7; i++) &#123; onCommands[i] = new NoCommand(); offCommands[i] = new NoCommand(); &#125; &#125; public void setOnCommand(int slot, Command onCommand) &#123; this.onCommands[slot] = onCommand; &#125; public void setOffCommand(int slot, Command offCommand) &#123; this.offCommands[slot] = offCommand; &#125; public void pressOnButton(int slot) &#123; this.onCommands[slot].execute(); &#125; public void pressOffButton(int slot) &#123; this.offCommands[slot].execute(); &#125; // 顯示我們塞了哪些功能到slot內 public String toString() &#123; StringBuffer stringBuff = new StringBuffer(); stringBuff.append(\"\\n ------- Remote Control-------\\n\"); for (int i=0; i &lt; onCommands.length; i++) &#123; stringBuff.append(\"[slot \" + i + \"] \" + onCommands[i].getClass().getName() + \" \" + offCommands[i].getClass().getName() + \"\\n\"); &#125; return stringBuff.toString(); &#125;&#125; 透過這樣的做法, 我們可以看到原本RemoteControl內的與Light操作有關的動作, 都被我們透過 Command 抽象介面以及其 LightOnCommand與LightOffCommand實作類別給抽離出來了 於是我們可以來執行看看 123456789101112131415161718192021222324252627public class main &#123; public static void main(String[] args) &#123; RemoteControl remoteControl = new RemoteControl(); // 定義出兩種房間的燈 Light LivingRoomLight = new Light(\"Living Room\"); Light KitchenLight = new Light(\"Kitchen\"); // 設置Command按鈕 remoteControl.setOnCommand(0, new LightOnCommand(LivingRoomLight)); remoteControl.setOffCommand(0, new LightOffCommand(LivingRoomLight)); remoteControl.setOnCommand(1, new LightOnCommand(KitchenLight)); remoteControl.setOffCommand(1, new LightOffCommand(KitchenLight)); // 顯示有哪些功能 System.out.println(remoteControl.toString()); // 執行命令 //// 客廳的 remoteControl.pressOnButton(0); remoteControl.pressOffButton(0); //// 廚房的 remoteControl.pressOnButton(1); remoteControl.pressOffButton(1); &#125;&#125; 若接下來需要新增如浴室開關, 電視開關, 只要透過RemoteConrol的setCommand()方法, 即可以動態做設置, 不需更動到遙控器類別原本的程式碼！ (除非要改變遙控器的slot大小了) 進階的Command Pattern技巧等待補充 (為Command介面新增 undo()方法, 使動作復原) 應用場景運用在任務序列中, 多執行緒只要拿到Command物件, 並且執行execute方法負責執行完就好 或是用在日誌管理, 將執行過的動作給記錄起來, 並且若後續伺服器當機, 可將命令給復原","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"}]},{"title":"下班自修的經驗分享","slug":"下班自修的經驗分享","date":"2020-05-16T12:47:39.000Z","updated":"2020-07-26T09:21:27.885Z","comments":true,"path":"2020/05/16/下班自修的經驗分享/","link":"","permalink":"http://a10000005588.github.io/2020/05/16/下班自修的經驗分享/","excerpt":"最近剛好在Backend版上看到有人Po文問說: “下班後要如何精進自修”, 意外看到許多大大們在下面留言, 正好最近我也在思考要如何精進自己, 所以趁這機會來統整一下大大們提出來的想法並且與自己目前的進修方式做結合, 主要會以Full-Stack engineer的精進方式來做個紀錄分享.","text":"最近剛好在Backend版上看到有人Po文問說: “下班後要如何精進自修”, 意外看到許多大大們在下面留言, 正好最近我也在思考要如何精進自己, 所以趁這機會來統整一下大大們提出來的想法並且與自己目前的進修方式做結合, 主要會以Full-Stack engineer的精進方式來做個紀錄分享. 如果對某程式語言&amp;框架掌握度還不夠, 請先熟悉之！如果上班接觸到某種自己不熟悉的語言或框架, 像我目前需要寫Java &amp; Spring, 與Angular &amp; Typescript. 所以我會偏好先到線上程式語言線上平台進修之, 因為這些學習平台能夠提供完整的學習輪廓, 能夠讓我快速掌握該程式語言&amp;框架所需具備的硬知識為何. 說到線上程式學習平台, 我蠻推薦 Pluralsight, 因為該平台提供了該程式語言或框架推薦學習的影片, 並且透過測驗推估你對該技術的知識程度為何. 有興趣可以到該平台試試看, 不過每個月會收取29美元的花費, 不過這花費當作投資是蠻值得的. 若已經對程式語言&amp;框架有經驗, 可以嘗試看看Side Project為什麼會特地提到Side Project?? 那是因為在公司其實很難自己能夠負責專案的所有全貌, 例如可能只是負責寫API, 也可能只負責前端頁面的刻畫. 所以透過Side Project, 便能夠有機會嘗試所有技術的機會, 並且從中去體會到自己最想要加強的領域是哪邊, 例如後端效能? 前端渲染速度? Container, CI/CD的運作? 諸如此類, 從而培養一個Full-Stack的經驗. 所以下班後自己跑一個Side Project是個不錯的精進方式. 但要怎麼樣想出一個Side Project?我覺得學習最快的方式就是模仿, 可以到Github上搜尋有興趣的專案, 並且試著用自己的程式語言與框架自己做出一套是最快的方式. 像我因為很喜歡用Markdown方式來做筆記, 目前打算自己做個小型的線上筆記編輯系統, 並看到Github上有提供CodiMD 的開源專案可參考, 來試著自己建造出一個看看. 之後會再分享到自己的部落格上怎麼一步一步進行的. 嘗試撰寫線上筆記或部落格吧我認為現在技術真的太多太多了, 如果沒有將自己看過的技術文章或學習影片給消化和記錄起來, 很快就又會忘記. 所以最好的方式是有個做筆記的習慣! 做筆記的話我都是用Hackmd先記錄起來, 之後等有空的時間會再消化審視自己寫過的內容, 並發佈到自己的Bloger上, 這樣有助於將學習過的知識給內化到自己的腦海中. 其他更進階的進修方法根據技能樹(RoadMap)來補充自己最常用,有興趣但所缺乏的觀念與技術這網站Roadmap提供了各開發者(Frontend, Backend, DevOps)所需要具備的技能樹為何, 若想要往後端精進, 可以看到下面這張圖會碰到哪些所需具備的能力. 看完之後會發覺有太多東西需要Cover了, 學海無涯 (茶). 經營 Stackoverflow這點是我看到大大們提出來可以嘗試的方式, 不過我目前也只有在Stackoverflow上面問幾個小問題, 對這方面還沒有涉略, 可參考下面大大所寫的Stackoverflow的介紹, 未來我會想在這邊嘗試看看能不能也試著回答別人遇到的問題. 工程師鍛鍊接軌世界的能力從stackoverflow 開始 - 阿貝好威的實驗室 小結下班後要再自修真的需要有興趣使然以及強大的毅力, 否則很容易就會半途而廢. 所以最重要的還是要讓自己有個規劃, 並且從實踐規劃中內化成自己的日常習慣, 久而久之就會讓自己變得更強的！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://a10000005588.github.io/tags/Life/"}]},{"title":"Spring Annotation筆記整理","slug":"Spring-Annotation介紹","date":"2020-03-10T14:13:00.000Z","updated":"2020-08-01T02:39:49.090Z","comments":true,"path":"2020/03/10/Spring-Annotation介紹/","link":"","permalink":"http://a10000005588.github.io/2020/03/10/Spring-Annotation介紹/","excerpt":"Spring Annotation 筆記這邊主要整理了我使用或是遇到的Spring Annotation資料查詢與統整的紀錄","text":"Spring Annotation 筆記這邊主要整理了我使用或是遇到的Spring Annotation資料查詢與統整的紀錄 API 相關 @Annotation@RestController將class設置為外部控制器 @RestControllerAdvice等同於@ControllerAdvice + @ResponseBody @ControllerAdvice為可在宣告的函式中使用@ExceptionHandler, @InitBinder或 @ModelAttribute註解的方法 @ExceptionHandler攔截所有控制器所發出的exception，並返回body型式 @RequestMapping控制器裡面的方法，使之成為外部請求 若要設置GET method, 如下(也可以改成 POST, PUT, DELETE) 定義一組restful api前綴路由ex : @RequestMapping(“/api/v1”) 1234567@RequstMapping(\"/api/v1\")public class hello &#123; @GetMapping(\"/hello\") public hello()&#123; return \"helloworld\"; &#125;&#125; 要使用的話得在postman中用 /api/v1/hello HTTP動作Annotation@PostMapping@GetMapping@PutMapping@DeleteMapping@RequestBody可以接收Body參數，得透過class宣告一組object來接收 123456789101112131415class Car &#123; private String type; private Integer number; public setType(String type) &#123; this.type = type; &#125; public setNumber(Integer number) &#123; this.number = number; &#125; public getType... public getNumber...&#125; 1234567@RequestMapping(\"/api/v1\")public class CarController&#123; // 透過宣告一個car，來接收Body的值 (type, number) @GetMapping(\"/car\") function getCar(@RequestBody Car car);&#125; @RequestHeader、@CookieValue處理request header部分的注解： Request Header的內容123456Host localhost:8080 Accept text/html,application/xhtml+xml,application/xml;q=0.9 Accept-Language fr,en-gb;q=0.7,en;q=0.3 Accept-Encoding gzip,deflate Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7 Keep-Alive 300 透過 @RequestHeader(“”)接受其Header值1234@RequestMapping(&quot;/displayHeaderInfo.do&quot;) public void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding, @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123; &#125; @SessionAttributes該註解用來綁定HttpSession中的attribute對象的值，便於在方法中的參數里使用。 該註解有value、types兩個屬性，可以通過名字和類型指定要使用的attribute 對象； 123456@Controller @RequestMapping(\"/editPet.do\") @SessionAttributes(\"pet\") public class EditPetForm &#123; // ... &#125; 參考資料:Spring MVC常用注解@PathVariable、@RequestHeader、@CookieValue、@RequestParam、@RequestBody、@SessionAttributes、@ModelAttribute https://www.cnblogs.com/EasonJim/p/8323017.html @JsonProperty (重點，遇到接不到request的值，用這就對了)用來接收application/json中，有大小不一型別的變數 ex: Postman script1234567&#123; \"contact\":&#123; \"cPhone\":\"0912345678\", \"cMail\":\" abc@test.com.tw \", \"cAddress\":\"台北市中正區信義路一段21-3號\" &#125;,...&#125; 若要接到 PHONE或Website，需要定義 @JsonProperty(“PHONE”), @JsonProperty(“Website”) 123456789101112131415161718@Datapublic class Lia201iReqDTO &#123; contactDto contact; @Data @AllArgsConstructor @NoArgsConstructor public static class contactDto &#123; @NotNull @JsonProperty(\"cPhone\") String cPhone; @JsonProperty(\"cMail\") String cMail; @JsonProperty(\"cAddress\") String cAddress; &#125;&#125; 參考資料Spring REST consuming JSON uppercase vs lowercasehttps://stackoverflow.com/questions/26890398/spring-rest-consuming-json-uppercase-vs-lowercase 驗證相關的Annotation@Valid與@Validated負責驗證有被定義校正的參數或object 先產生要校正的實體類(class)1234567891011121314151617public class Foo &#123; @NotBlank private String name; @Min(18) private Integer age; @Pattern(regexp = \"^1(3|4|5|7|8)\\\\d&#123;9&#125;$\",message = \"手机号码格式错误\") @NotBlank(message = \"手机号码不能为空\") private String phone; @Email(message = \"邮箱格式错误\") private String email; //... getter setter&#125; 於@Controller中 使用Valid做校正 12345678910111213141516@Controllerpublic class FooController &#123; // 對Foo class產生的foo做校正 @RequestMapping(&quot;/foo&quot;) public String foo(@Validated Foo foo &lt;1&gt;, BindingResult bindingResult &lt;2&gt;) &#123; if(bindingResult.hasErrors())&#123; for (FieldError fieldError : bindingResult.getFieldErrors()) &#123; //... &#125; return &quot;fail&quot;; &#125; return &quot;success&quot;; &#125;&#125; @Validate 與 @Valid差異@Valid能進行嵌套驗證， @Validate不行 因為@Valid能加在成員屬性上，反而@Validated不能用在成員屬性。 舉例：12345678910public class Item &#123; @NotNull(message = \"id不能為空值\") @Min(value = 1, message = \"id必須為正整數\") private Long id; @NotNull(message = \"props不能為空直\") @Size(min = 1, message = \"至少要有一個屬性\") private List&lt;Prop&gt; props;&#125; 然而 Prop class如下12345678910111213141516public class Prop &#123; @NotNull(message = \"pid不能為空\") @Min(value = 1, message = \"pid必須為正整數\") private Long pid; @NotNull(message = \"vid不能為空\") @Min(value = 1, message = \"vid必須為正整數\") private Long vid; @NotBlank(message = \"pidName不能為空\") private String pidName; @NotBlank(message = \"vidName不能為空\") private String vidName;&#125; 現在我們有個ItemController接受一個Item的參數，想要對Item進行驗證，如下所示： 12345678@RestControllerpublic class ItemController &#123; @RequestMapping(\"/item/add\") public void addItem(@Validated Item item, BindingResult bindingResult) &#123; doSomething(); &#125;&#125; 在上圖中，如果Item實體的props屬性不額外加註釋，只有@NotNull和@Size，無論入參採用@Validated還是@Valid驗證，Spring Validation框架只會對Item的id和props做非空和數量驗證，不會對props字段裡的Prop實體進行字段驗證，也就是@Validated和@Valid加在方法參數前，都不會自動對參數進行嵌套驗證&lt;/ span&gt; :::info這邊指的嵌套(Nested)驗證，指的是若class Item中還有一個變數List 且這個Props的class內也有自己定義驗證@Notnull, @NotBlank, 一層class內還有一個class定義自己的驗證，就叫做嵌套驗證::: 要進行嵌套驗證的話得在 class Props中加入@Valid 1234567891011public class Item &#123; @NotNull(message = \"id不能为空\") @Min(value = 1, message = \"id必须为正整数\") private Long id; @Valid // 嵌套验证必须用@Valid @NotNull(message = \"props不能为空\") @Size(min = 1, message = \"props至少要有一个自定义属性\") private List&lt;Prop&gt; props;&#125; 補充 負責校驗的Annotation12345678910111213141516171819@Null 被註釋的元素必須為 null@NotNull 被註釋的元素必須不為 null@AssertTrue 被註釋的元素必須為 true@AssertFalse 被註釋的元素必須為 false@Min(value) 被註釋的元素必須是一個數字，其值必須大於等於指定的最小值@Max(value) 被註釋的元素必須是一個數字，其值必須小於等於指定的最大值@DecimalMin(value) 被註釋的元素必須是一個數字，其值必須大於等於指定的最小值@DecimalMax(value) 被註釋的元素必須是一個數字，其值必須小於等於指定的最大值@Size(max=, min=) 被註釋的元素的大小必須在指定的範圍內@Digits (integer, fraction) 被註釋的元素必須是一個數字，其值必須在可接受的範圍內@Past 被註釋的元素必須是一個過去的日期@Future 被註釋的元素必須是一個將來的日期@Pattern(regex=,flag=) 被註釋的元素必須符合指定的正則表達式@NotBlank(message =) 驗證字符串非null，且長度必須大於0@Email 被註釋的元素必須是電子郵箱地址@Length(min=,max=) 被註釋的字符串的大小必須在指定的範圍內@NotEmpty 被註釋的字符串的必須非空@Range(min=,max=,message=) 被註釋的元素必須在合適的範圍內 補充: 用BindingResult接收@Valid拋出來的錯誤訊息假設有驗證錯誤的物件為 BindingResult bindingResult可透過bindResult取得錯誤資訊 舉例: 123456789public class FlightDTO &#123; @NotBlank private String terminal; // 航廈 @NotBlank private String type; // 航班種類 @NotBlank private String carrier; // 航空公司代碼 ...&#125; 若使用@Valid對FlightDTO做參數驗證，假設有一Request少輸入terminal資訊，就會發出bindingResult訊息，其中包含： 12345678910List&lt;FieldError&gt; fieldErrors = bindingResult.getFieldErrors();for(FieldError fieldError: fieldErrors) &#123; // 封裝錯誤格式 FieldResource fieldResource = new FieldResource( fieldError.getObjectName(), // 取得物件名稱：為FlightDTO fieldError.getField(), // 為properties(terminal) fieldError.getCode(), // 為@Notblank fieldError.getDefaultMessage() // 為@Notblank的錯誤資訊 );&#125; :::infoBindingResult為Error的子介面 BindingResulthttps://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/BindingResult.htmlError:https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/Errors.html::: 參考資料：使用spring validation完成数据后端校验https://www.cnkirito.moe/spring-validation/ @Validated和@Valid区别：Spring validation验证框架对入参实体进行嵌套验证必须在相应属性（字段）加上@Valid而不是@Validatedhttps://blog.csdn.net/qq_27680317/article/details/79970590 操作數據庫相關數據相關的Annotation@Entity表示是一個對應到DB Table的物件 @Id聲明該欄位為主鍵 @GeneratedValue指定ID生成的策略，若沒有設置的化, Hibernate對應的是為一個Not null的物件，得自行設定id到物件內。但通常會自行在新增資料時產生ID, 故@Id與@GeneratedValue會常常同時出現 因為Hibernate會遇見不同的Database，所以有各種不同的生成策略: GenerationType.AutoHibernate會根據採用的Database為何，來決定要用 GenerationType.Identity 或 GenerationType.SEQUENCE。(大部分的情況都會採用 GenerationType.SEQUENCE) GenerationType.IDENTITY透過auto-incremented database column來產生primary key.常見的MySQL和MMSQL都採用該方式，相對應的DDL語言為以下所示:1id BIGINT NOT NULL AUTO_INCREMENT GenerationType.SEQUENCE設定該策略，通常也會給入另一個Annotation @SequenceGenerator，如下 12345@Id@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"author_generator\")@SequenceGenerator(name=\"author_generator\", sequenceName = \"author_seq\", allocationSize=50)@Column(name = \"id\", updatable = false, nullable = false)private Long id 若沒有指定，Hibernate會使用預設的SequenceGenerator 可以看到若指定 sequenceGenerator的name為author_seq, Hibernate就會在 author_seq這個table查找下一個id值為多少 注意，在Postgres情況下不適合用該方法https://stackoverflow.com/questions/4288740/hibernate-use-of-postgresql-sequence-does-not-affect-sequence-table/4502062#4502062 GenerationType.SEQUENCE當不希望應用程式與某一種 Database Engine 綁死的時候，可以使用這種方法，透過另外一個表格來定義 ID 會透過SQL，建立存放各種column的seqeunce1CREATE TABLE APP_SEQ_STORE ( APP_SEQ_NAME VARCHAR(255) NOT NULL, APP_SEQ_VALUE BIGINT NOT NULL, PRIMARY KEY(APP_SEQ_NAME) ); Reference: https://thoughts-on-java.org/jpa-generate-primary-keys/@IdClass 复合主键复合主键由多个主键字段组成。每个主键字段必须是上面列出的支持类型之一。例如，以下项目实体类的主键由两个字段组成:12345@Entity @IdClass(ProjectId.class)public class Project &#123; @Id int departmentId; @Id long projectId;&#125; 在ProjectId.class中聲明兩個主鍵值1234Class ProjectId &#123; int departmentId; long projectId;&#125; @Embeddable嵌入式主键表示复合主键的另一种方法是使用可嵌入的类 12345678910@Entitypublic class Project &#123; @EmbeddedId ProjectId id;&#125;@EmbeddableClass ProjectId &#123; int departmentId; long projectId;&#125; @Column宣告該變數與資料庫欄位的對映 1234@Column(nam=”category_name” length=20)Public void getCategoryName()&#123; Return this.categoryName;&#125; 參考資料:SPRING中常用的注解（@ENTITY，@TABLE，@COLUMN，@REPOSITORY，@SERVICE）https://www.cnblogs.com/hoojjack/p/6568920.html JPA 主键@Id、@IdClass、@Embeddable、@EmbeddedIdhttps://blog.csdn.net/tracycater/article/details/78319021 @Data@Data 自動產生 getter(), setter(), toString(), 節省一大堆代碼的神Annotation 前置作業： 引入lombok要使用 @Data 注解要先引入lombok 1lombok為一個Library，可以用簡單的註解形式來簡化代碼，提高開發效率。 如何使用lobok 在maven中添加依賴 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 在編譯器中添加插件 以IDEA為例，在setting的plugin裡搜索lombok plugin，安裝插件。 直接在Class上加上@Data即可 例如一个简单的Person Class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Person &#123; private String name; private String address; private Integer age; private String hobbit; private String phone; public Person() &#123; &#125; public Person(String name, String address, Integer age, String hobbit, String phone) &#123; this.name = name; this.address = address; this.age = age; this.hobbit = hobbit; this.phone = phone; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getHobbit() &#123; return hobbit; &#125; public void setHobbit(String hobbit) &#123; this.hobbit = hobbit; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", address='\" + address + '\\'' + \", age=\" + age + \", hobbit='\" + hobbit + '\\'' + \", phone='\" + phone + '\\'' + '&#125;'; &#125;&#125; 使用了 @Data 12345678910@Data@AllArgsConstructor@NoArgsConstructorpublic class Person &#123; private String name; private String address; private Integer age; private String hobbit; private String phone;&#125; 在按快捷鍵 Ctrl + F12，可以查找到set,get,toString 方法。 使用 @Data 註解就可以有下面幾個註解的功能： @ToString、@Getter、@Setter、@EqualsAndHashCode、@NoArgsConstructor 。 :::info常用的幾個註解：@Data ： 注在類上，提供類的get、set、equals、hashCode、canEqual、toString方法@Setter ： 注在屬性上，提供 set 方法@Getter ： 注在屬性上，提供 get 方法構造函數 @AllArgsConstructor会生成一个包含所有变量，同时如果变量使用了NotNull annotation ， 会进行是否为空的校验，全部参数的Constructor函数的自动生成，该注解的作用域也是只有在实体类上，参数的顺序与属性定义的顺序一致。 範例:123456789101112131415import lombok.AllArgsConstructor;@AllArgsConstructorclass MyClass&#123; private String one; private Integer three; private Integer two; &#125;自動生成建構子:public MyClass(String one, Integer three, Integer two) &#123; this.one = one; this.three = three; this.two = two; &#125; 參考: https://stackoverflow.com/questions/49106072/how-to-specify-the-order-of-parameters-in-allargsconstructor-in-lombok @NoArgsConstructor產生沒有參數的建構子generate a constructor with no parameters. @RequiredArgsConstructor会生成一个包含常量（final），和标识了@NotNull的变量 的构造方法。 @EqualsAndHashCode ： 注在类上，提供对应的 equals 和 hashCode 方法@Log4j/@Slf4j ： 注在类上，提供对应的 Logger 对象，变量名为 log::: :::warning注意的是，同时使用@Data 和 @AllArgsConstructor 后 ，默认的无参构造函数失效，如果需要它，要重新设置 @NoArgsConstructor::: 參考資料 @Data注解 与 lombokhttps://www.jianshu.com/p/c1ee7e4247bf学习Spring Boot：（十五）使用Lombok来优雅的编码https://blog.wuwii.com/springboot-15.html Spring載入Bean與標示為Bean有關的Annotation@Bean定義可共物件化的類別，叫做Bean，並且放置在Spring Ioc Container中並且給其管理，等待被呼叫使用。 配置方式1. 程式碼Java Code配置Spring 的@Bean通常宣告在掛有@Configuration的Spring配置類別中的方法前，例如宣告一個 AppConfig.java，若有超過一個以上的bean，使用 @Qualifier給予名稱 AppConfig.java1234567891011121314151617@Configurationpublic class AppConfig &#123; @Bean(name=\"add\") Calculator addCalculator() &#123; return new AddCalculator(); &#125; @Bean(name=\"sub\") Calculator subCalculator() &#123; return new SubCalculator(); &#125; @Bean(name=\"mul\") Calculator mulCalculator() &#123; return new MulCalculator(); &#125;&#125; 定義Calculator的介面 Calculator.interface123public interface Calculator &#123; int calc(int a, int b);&#125; 定義一個實作Calculator的類別 CalculatorImpl.java1234567891011121314151617181920212223package com.will.advanced.demo.bean;class AddCalculator implements Calculator &#123; @Override public int calc(int a, int b) &#123; return a + b ; &#125;&#125;class SubCalculator implements Calculator &#123; @Override public int calc(int a, int b) &#123; return a - b; &#125;&#125;class MulCalculator implements Calculator &#123; @Override public int calc(int a, int b) &#123; return a * b; &#125;&#125; 取得註冊的bean的方式1. 使用@Autowire 與 @Qualifier然後在 CommandLineRunner中使用 @AutoWire使用@Bean，然而若要Autowired的類別對象是介面的話，且介面有很多的實作子類別(AddCalculator, SubCalculator, MulCalculator) 那得透過 @Qualifier來指名是哪一個子類別 CommandLineAppStartupRunner.java123456789101112131415161718192021@SpringBootApplicationpublic class CommandLineAppStartupRunner implements CommandLineRunner &#123; @Autowired private ApplicationContext context; @Autowired @Qualifier(\"add\") Calculator addCalculator; @Autowired @Qualifier(\"sub\") Calculator subCalculator; @Autowired @Qualifier(\"mul\") Calculator mulCaculator; @Override public void run(String...args) throws Exception &#123; System.out.println(addCalculator.calc(1,3)); System.out.println(subCalculator.calc(3,2)); System.out.println(mulCaculator.calc(2,6)); &#125;&#125; 2. 使用getBean()CommandLineAppStartupRunner.java1234567891011121314151617181920@SpringBootApplicationpublic class CommandLineAppStartupRunner implements CommandLineRunner &#123; @Autowired private ApplicationContext context; @Override public void run(String...args) throws Exception &#123; // 取得所有已經註冊的bean System.out.println(Arrays.asList(context.getBeanDefinitionNames())); // 取得名稱為add的bean Calculator addCalculator = context.getBean(\"add\", Calculator.class); Calculator subCalculator = context.getBean(\"sub\", Calculator.class); Calculator mulCalculator = context.getBean(\"mul\", Calculator.class); System.out.println(addCalculator.calc(1,3)); System.out.println(subCalculator.calc(3,2)); System.out.println(mulCalculator.calc(2,3)); &#125;&#125; 補充: 使用CommandlineRunner讓Spring設置可以先被載入，然後可透過run()定義自訂義執行的內容https://dzone.com/articles/spring-boot-applicationrunner-and-commandlinerunne 3. xml檔案配置上面的寫法等同在 appConfig.xml 宣告:123&lt;beans&gt; &lt;bean name=&quot;addCalculator&quot; class=&quot;com.will.advanced.TransferServiceImpl&quot;/&gt;&lt;/beans&gt; @ComponentScan: 掃描指定package中掛有@Component的類別，自動註冊包含的bean不過一般在沒有特殊需求的情況下都會使用@ComponentScan掃描指定package中掛有@Component的類別來自動註冊為bean。 而會使用@Bean的時機為，當要被註冊為bean的類別建構步驟或邏輯比較複雜，此時就需要@Bean讓你可以在構造bean的方法內撰寫構造的詳細邏輯，而@ComponentScan就無法滿足比較細微的配置。 例如在 service層中新增一個 TestService class透過@Component將TestService註冊成Bean123456@Componentpublic class TestService &#123; public String test() &#123; return &quot;testing&quot;; &#125;&#125; 透過@ComponentScan可使用@Component註冊的bean， 12345678910@ComponentScanpublic class CommandLineAppStartupRunner implements CommandLineRunner &#123; @Autowired TestService testService; @Override public void run(String...args) throws Exception &#123; System.out.println(testService.test()); &#125;&#125; 參考資料Spring: A Head Start 🔥 — Beans Configuration (Part 2)https://medium.com/omarelgabrys-blog/spring-a-head-start-beans-configuration-part-2-4a8c239b070a @Scope: 定義Bean被引用時要怎樣被使用 singleton：在Spring IoC Container，該bean只會有單一實例(a single instance)，此為Spring預設值 prototype：在Spring IoC Container中，該bean可以有多個實例(any number of object instances) request： 在每一次的HTTP Request，spring container會根據loginAction bean的定義來建立一個全新的instance，而且僅在目前的request中有效，所以可以放心的去更改instance的內部狀態，請求結束，request scope的bean instance會被destroy session：針對某個HTTP Session，spring container會根據userPreference bean的定義來建立一個全新的instance，同樣的，和request scope一樣，可以放心的去更改instance內部狀態。 global-session：僅在portlet為基礎的Web應用下有作用。Porlet的規範中定義了global session的概念。 參考資料:Spring Bean Scope 學習https://kevingo75.blogspot.com/2012/03/spring-bean-scope.html 補充: 什麼是Spring IoC (Inversion of Control) container. Inversion of Control, or IoC for short, is a process in which an object defines its dependencies without creating them. This object delegates the job of constructing such dependencies to an IoC container. 用一柱話描述IoC： class不用自己主動new欲依賴class的instance，而是透過外部 (main()方法) 以建構子、setter或是介面注入來產生依賴class的instance :::success需要的 遊戲，不用自己 下載，而是 網咖提供 給你。———————-||——————— 需要的 物件，不用自己 取得，而是 服務容器 提供 給你。———————-||———————需要的 依賴實例，不用 主動 (Active) 建立，而是 被動 (Passive) 接收。::: 參考資料：控制反轉 (IoC) 與 依賴注入 (DI)https://notfalse.net/3/ioc-di @Repository简化 Spring 的开发。@Repository注解便属于最先引入的一批，它用于将数据访问层 (DAO 层 ) 的类标识为 Spring Bean。具体只需将该注解标注在 DAO类上即可。 @Service、@Controller 和 @Component 將class標示为Bean @Component 是一个泛化的概念，仅仅表示一个组件 (Bean) ，可以作用在任何层次。 @Service 通常作用在業務邏輯層，但是目前该功能与 @Component 相同。 @Controller 通常作用在控制層(Controller)，但是目前该功能與@Component 相同。 @PostConstruct被@PostConstruct修飾的方法會在服務器加載Servlet的時候運行，並且只會被服務器執行一次。 @Transactional假若你在class中設定了@Transactional, 該class所有的method有使用到JPA的都會被spring的transaction所管理。 舉例：當有個Transaction有三個動作：entity1.save, entity2.save, entity3.save. 若entity3.save失敗，那Spring就會將entity1.save與entity2.save的執行結果給rollback，還原其動作。 參考資料https://stackoverflow.com/questions/1099025/spring-transactional-what-happens-in-background AOP相關的Annotaion@Aspect@Aspect:定義AOP，作用在class AOP為 Aspect Oritented ProgrammingAOP通過給程序定義一個切入點，然後在其前後切入不同的執行內容AOP不會破壞原來的程序邏輯AOP使用場景： 紀錄日誌 事務管理 安全檢查 資源控制 @Pointcut, @Before, @After範例1234567891011121314151617181920212223@Aspect@Componentpublic class LogAspect &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); // 切入package為com.william.demo.api的LogTestApi類別的log函式 @Pointcut(\"execution(* com.william.demo.api.LogTestApi.log(..))\") public void log() &#123; &#125; // 希望在切入點 log()函式前執行某些內容 // 或是用直接用 @Before(\"execution(* com.william.demo.api.LogTestApi.log(..))\"); @Before(\"log()\") public void doBefore() &#123; logger.info(\"----------do before---------\"); &#125; @After(\"log()\") public void doAfter() &#123; logger.info(\"----------do after----------\"); &#125;&#125; 其他Annotation@Cache定義cache策略與範圍，可以定義以下參數： usage: 當前緩存策略(NONE, READ_ONLY, NONSTRICT_READ_WRITE, TRANSACTIONAL) read-only: 只讀緩存 如果你的應用程序只需讀取一個持久化類的實例，而無需對其修改， 那麼就可以對其進行只讀緩存 read-write: 讀寫緩存 如果應用程序需要更新數據，那麼使用讀/寫緩存比較合適。如果應用程序要求“序列化事務”的隔離級別（serializable transaction isolation level），那麼就決不能使用這種緩存策略 nonstrict-read-write: 不嚴格讀寫緩存 如果應用程序只偶爾需要更新數據（也就是說，兩個事務同時更新同一記錄的情況很不常見），也不需要十分嚴格的事務隔離，那麼比較適合使用非嚴格讀/寫緩存策略。 transactional :事務性緩存 Hibernate 的事務緩存策略提供了全事務的緩存支持，例如對 JBoss TreeCache 的支持。這樣的緩存只能用於 JTA 環境中，你必須指定為其hibernate.transaction.manager_lookup_class屬性。 region: 可選參數，指定二級緩存的去域名，默認為類或者集合的名字。 include: 可選參數(all, non-lazy)。 all包含所有屬性，non-lazy僅包含非延遲加載的屬性。 範例12345@Table(name = &quot;PROVICE&quot;)@Cache(usage =CacheConcurrencyStrategy.READ_ONLY)public class Province() &#123;...&#125; 1234567@Table(name = &quot;PROVICE&quot;)@Cache(usage =CacheConcurrencyStrategy.READ_ONLY)public class Province() &#123; @OneToMany(fetch = FetchType.LAZY) @JoinColumn(name = &quot;cityId&quot;) @Cache(usage = CacheConcrrencyStrategy.READ_ONLY) private Set&lt;City&gt; cities; 參考資料Hibernate @Cache注解-天才小小布https://blog.csdn.net/w410589502/article/details/54603265 @Configuration@Configuration的作用同以前的xml配置檔（例如Spring的applicationContext.xml或dispatcher-servlet.xml），用來設定Spring環境配置，例如宣告及註冊bean至Spring容器中，注入properties參數等。 範例例如我們有一個FooService類別，若此類別要成為Spring容器管理的bean，有兩種方法： 一般在該類別上宣告@Component並搭配@ComponentScan掃描的方式註冊為bean 透過在@Configuration類別中搭配@Bean的方式註冊。 例如建立一個AppConfig並在類別名稱前掛上@Configuration，則此類別及成為Spring的配置類。在配置類的方法前掛上@Bean則方法回傳的物件就會被註冊為Spring容器管理的bean fooService()方法便會將FooService註冊為bean。 1234567891011121314package com.will.advanced.demo.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.will.advanced.demo.service.FooService;@Configurationpublic class AppConfig &#123; @Bean public FooService fooService() &#123; return new FooService(); &#125;&#125; 為了程式管理及維護上的方便，通常我們會把某些相關的配置寫在另外的配置檔，而不是全部塞在同一個類別，此時就可以利用@Configuration另外定義一個配置檔，例如上面的AppConfig。 @SpringBootApplication: 本身也包含@Configuration而在Spring Boot中，@SpringBootApplication類本身即包含了@Configuration，所以可以直接在裡面進行如上Bean的配置，例如 123456789101112131415161718192021package com.will.advanced.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import com.will.advanced.demo.FooService;@SpringBootApplicationpublic class SpringBootBeanDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootBeanDemoApplication.class, args); &#125; @Bean public FooService fooService() &#123; return new FooService(); &#125;&#125; 參考資料Spring @Configuration作用https://matthung0807.blogspot.com/2019/04/spring-configuration_28.html @SpringBootApplication定義 @SpringBootApplication的預設掃瞄bean的範圍 Spring Boot的@SpringBootApplication預設只會掃描所屬package下的類，因此若@Configuration類別定義在@SpringBootApplication類以外的package，則要用scanBasePackages屬性來設定要額外掃描的package，例如@SpringBootApplication(scanBasePackages=”com.will.advanced.demo.config”) （@Configuration包含了@Component）， 12345678910111213package com.will.advanced.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;// 注意在scanBasePackages的package名稱@SpringBootApplication(scanBasePackages=\"com.will.advanced.demo.config\") public class SpringBootBeanDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootBeanDemoApplication.class, args); &#125;&#125; @Import或是透過@Import來引入 ，例如12345678910111213141516package com.will.advanced.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Import;@SpringBootApplication// 注意pacakge名稱@Import(value = &#123; com.will.advanced.demo.config.AnotherAppConfig.class &#125;)public class SpringBootBeanDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootBeanDemoApplication.class, args); &#125;&#125; :::warning注意使用@Import會忽略@Configuration設定::: @Autowired依賴注入物件 Spring的@Autowired用來依賴注入物件，典型的用法就是掛在類別成員變數上。@Autowired預設會依注入對象的類別型態來選擇容器(透過@Configuration定義的class會成為容器)中相符的物件(設置成bean)來注入。 12@Autowiredprivate Car car; Spring會自動去容器中找到 有容器定義CarBeans的bean 123456import ....xxx.Car;@Configuationpublic class CarBeans &#123; @Bean public Car car() &#123; return new Car() &#125;&#125; @Autowire為Spring IoC的實現，不用自己去new一個car出來，而是透過容器(會做constructor or setter or interface injection)，來去實現外部注入，降低模組(class)之間的耦合性 @EnableScheduling若開發者在AppConfig類中使用了@EnableScheduling，並在某個task class中使用了@Schedule註解，那麼被@Schedule標註的方法既可以在指定時間內自動執行 注意：@EnableScheduling要與@Schedule搭配使用才有效果 @ConfigurationProperties若想要把配置文件的信息，讀取好並自動封裝(getter讀取private的config值)成實體類，如此一來我們在代碼裡面使用就輕鬆許多，這時就可以使用@ConfiguationProperties，把同類的配置訊息自動封裝成實體類。 假設有設定文件在 application.properties之下：123connection.username=adminconnection.password=kyjufskifas2jsfsconnection.remoteAddress=192.168.1.1 我們可以定義一個實體類在裝載配置文件信息 12345678910111213141516171819202122232425262728@Component@ConfigurationProperties(prefix=\"connection\")public class ConnectionSettings &#123; private String username; private String remoteAddress; private String password ; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getRemoteAddress() &#123; return remoteAddress; &#125; public void setRemoteAddress(String remoteAddress) &#123; this.remoteAddress = remoteAddress; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 亦可以把 @ConfigurationProperties 定義在@Bean之下，說明@Bean是參考到有用configuationProperties設定的class 12345678910111213141516@SpringBootApplicationpublic class DemoApplication&#123; //... @Bean @ConfigurationProperties(prefix = \"connection\") public ConnectionSettings connectionSettings()&#123; return new ConnectionSettings(); &#125; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 需要使用時直接用@Autowire注入 12345678910111213@RestController@RequestMapping(\"/task\")public class TaskController &#123; // 在這裡注入 config！ @Autowired ConnectionSettings conn; @RequestMapping(value = &#123;\"/\",\"\"&#125;) public String hellTask()&#123; String userName = conn.getUsername(); return \"hello task !!\"; &#125;&#125; 參考資料：spring boot 使用@ConfigurationPropertieshttps://blog.csdn.net/yingxiake/article/details/51263071 @ConditionalOnClass是Springboot实现自动配置的重要支撑之一。其用途是判断当前classpath下是否存在指定类，若是则将当前的配置装载入spring容器。 參考資料：@ConditionalOnClass的使用探索 新日暮里格斗大会https://blog.csdn.net/lucyTheSlayer/article/details/80430912 @ConditionalOnMissingBean结合使用注解@ConditionalOnMissingBean和@Bean,可以做到只有特定名称或者类型的Bean不存在于BeanFactory中时才创建某个Bean 12345678910111213141516171819202122232425@Configurationpublic class ConditionalOnMissingBeanConfig &#123; // 無條件定義一個bean @Bean public A beanA ()&#123; return new A(); // &#125; @Bean @ConditionalOnMissingBean(name=\"beanA\") public B beanB()&#123; // 如果 beanFactory 中存在一个名称为 beanA 的 bean，才定义bean ： beanB； // 因为上面的方法已经定义了一个 beanA，所以这里 beanB定义并不会发生。 return new B(); &#125; @Bean @ConditionalOnMissingBean(name=\"beanD\") public C beanC()&#123; // 如果 beanFactory 中存在一个名称为 beanD的 bean，才定义bean ： beanC； return new C(); &#125;&#125; 參考資料：Spring Boot基于特定条件创建Bean例子 : ConditionalOnMissingBeanhttps://blog.csdn.net/andy_zhang2007/article/details/81285130","categories":[{"name":"Spring","slug":"Spring","permalink":"http://a10000005588.github.io/categories/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://a10000005588.github.io/tags/Spring/"}]},{"title":"Spring Security 功能介紹","slug":"Spring-Security介紹","date":"2020-02-29T13:34:23.000Z","updated":"2020-08-01T01:49:21.045Z","comments":true,"path":"2020/02/29/Spring-Security介紹/","link":"","permalink":"http://a10000005588.github.io/2020/02/29/Spring-Security介紹/","excerpt":"","text":"Spring Security 功能介紹先介紹以下常用認證功能 User name / password 基本認證使用使用者名稱/密碼做驗證 SSO / Okta / LDAPSSO (Single Sign On)為OAuth的近一步實現，若已經透過Google取得token, 就可以在其他服務的小網站，都使用Google提供的身份驗證服務 Okta協助非營利組織的方式。從基本的單一登入（single sign-on，簡稱為 SSO）到進階的身份認證和存取權限的管理方案 LDAP (Lightweight Directory Access Protocol)為一種輕量的目錄服務協定，像是通訊錄一樣紀錄人員資訊，可以拿來做帳號整合,驗證。 LDAP目錄服務通常有層級結構，像是公司組織階層 OAuth (Intra App Authorization)OAuth讓用戶可以授權第三方網站存取他們在另外服務提供者(ex: Facebook, Line)的某些特定資訊，而非所有內容。 為什麼有OAuth出現？因為各個網站都做會員機制很麻煩，且小網站可能有資安風險。 故大網站像是Facebook, Line早已經做好超級安全的會員管理機制，大網站幫你管理個資，提供登入的服務。 但提供這樣服務的大廠越來越多，若小網站同時要提供用戶連結到多個有提供身分服務的大網站會變得很複雜，於是就訂定的工業標準：OAuth. 功能 進入小網站 -&gt; 跳轉到大網站登入畫面 -&gt; 登入成功大網站給予一個有時效的token 給小網站 -&gt; 小網站透過token跟大網站索取用戶的資訊 (這也是為什麼每次登入第三方都會詢問你是否要揭露以下資訊給小網站) 不過一般小網站”無法”直接取得token, 而是取得一個code, 再用這個code向大網站換得一個token(多這道手續的原因是因為，Internet可能會被路上經手的router或其他設備擷取,偽造,變更) 實際情況在 Line Login時, Line Notify中，組出一個URL，取得Authorization Code, 這一段取得的Code為明碼, 走的是http get，透過瀏覽器網址列來傳遞 (若沒有用SSL傳遞的話，會被任何人擷取看到). 接下來小網站取得Authorization Code後，在透過http post，從後端跟大網站換得token (因為走後端 大網站就知道小網站的身份和所拿的code) :::warningOAuth主要功能是授權，不是認證，所以後來才延伸出OpenID Connect (OIDC)來提供認證用。::::::infoAuthentication 檢查發送檢查人的身份是誰、是否合格;Authorization 則是規範使用者權限的規則，規定哪些能做、哪些不能 因此如果該 Request 未帶 token 或是 token 過期、不合法皆算是 Authentication Error ，跟 http status code 的 401 意思一樣 ; 如果 Request 的 token 認證成功但是該使用者的權限不足以執行該 Request 則是 Forbidden Error (即 因 Authorization 發生的錯誤) ，如 http status code 的 403 意思相同。 ::: :::success單純用大網站的OAuth當自己的會員系統還是有很大的問題最明顯的是當使用者同時有Google 與 Facebook的帳號時兩個帳號上面的Email可能不是一樣的自己的網站很可能無法辨認這是同一個人的帳戶所以一般還是會需要自己的會員系統做整合::: Microservice security (using tokens, JWT)JWT (JSON web token): JWT基於JSON的開放標準 (RFC 7519) 被用在身份提供者和服務提供者間傳遞，被認證的用戶身份訊息 可額外增加聲明訊息，該JWT token可以直接被用於認證(Authorization)，也可被加密 特別適用於SSO JWT 與 Session差別：Session:由於http協議為stateless,無法知道每次request是誰，但每次request若都要帳號密碼很麻煩 故用戶第一次發Request時，就產生一組token紀錄在db與session, 並將token給用戶，告訴用戶將token存在cookie，當下次發送request時，透過token證明自己身份。 JWT組成內容有三個部分(Header, Paylaod,Signature)並由. 做區隔，最後透過這三個部分，串成一個 Jwt 字串 Header: 1234&#123; &apos;typ&apos;: &apos;JWT&apos;, # 聲明類型 &apos;alg&apos;: &apos;HS256&apos; # 加密的方法: HMAC、SHA256、RSA 進行 Base64 編碼&#125; Payload: 放聲明內容，可以說就是存放溝通訊息的地方 在定義上有 3 種聲明 (Claims) Reserved (註冊聲明) Public (公開聲明) Private (私有聲明) 註冊聲明參數 (建議但不強制使用) iss (Issuer) - jwt簽發者 sub (Subject) - jwt所面向的用戶 aud (Audience) - 接收jwt的一方 exp (Expiration Time) - jwt的過期時間，這個過期時間必須要大於簽發時間 nbf (Not Before) - 定義在什麼時間之前，該jwt都是不可用的 iat (Issued At) - jwt的簽發時間 jti (JWT ID) - jwt的唯一身份標識，主要用來作為一次性token,從而迴避重放攻擊 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;iat&quot;: 1516239022&#125; Signature: 由三個部分組成 header (base64後的) payload (base64後的) secret 1HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), &apos;secret&apos;) :::warningsecret 要保存在 server 端，jwt 的 簽發驗證都必須使用這個 secret，當其他人得知這個 secret，那就意味著客戶端是可以自我簽發 jwt ，因此在任何場景都不應該外流::: 最後將 Header, Payload, Signature做base64編碼，組成 使用的時候，在reqeust的header加上 Authorization: Bearer &lt;token&gt; 12345post(&apos;api/user/1&apos;, &#123; headers: &#123; &apos;Authorization&apos;: &apos;Bearer &apos; + token &#125;&#125;) JWT 前後端互動示意圖 JWT優點 跨語言，因為 json 格式大部分語言都可使用 可儲存一些簡單但非敏感的商業邏輯 - role .. 構成內容簡單，佔用 Size 小方便傳輸 !!! 不需在 server 保存 session，所以它易於應用的擴展 Spring Security 教學視頻Spring Boot + Spring Security + JWT from scratch - Java Brainshttps://www.youtube.com/watch?v=X80nJ5T7YpE 參考資源：Okta 如何協助非營利組織-從 25 個免費的授權開始https://www.techsoup-taiwan.org.tw/okta LDAP 簡介https://poychang.github.io/ldap-introduction/ 一次搞懂OAuth與SSO在幹什麼?http://studyhost.blogspot.com/2017/01/oauthsso.html GraphQL 設計： Autentication 與 Authorization 大全https://ithelp.ithome.com.tw/articles/10208278 JSON Web Token(JWT) 簡單介紹https://mgleon08.github.io/blog/2018/07/16/jwt/ What is Spring Security really all about? Java Brains Brain Bytes https://www.youtube.com/watch?v=sm-8qfMWEV8&amp;list=PLqq-6Pq4lTTYTEooakHchTGglSvkZAjnE","categories":[{"name":"Spring","slug":"Spring","permalink":"http://a10000005588.github.io/categories/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://a10000005588.github.io/tags/Spring/"},{"name":"Authentication","slug":"Authentication","permalink":"http://a10000005588.github.io/tags/Authentication/"}]},{"title":"2020年的想法","slug":"2020年的想法與自修規劃","date":"2020-01-01T13:30:48.000Z","updated":"2020-01-01T14:22:47.890Z","comments":true,"path":"2020/01/01/2020年的想法與自修規劃/","link":"","permalink":"http://a10000005588.github.io/2020/01/01/2020年的想法與自修規劃/","excerpt":"回顧了一下2019年對自己的期許，自己與期許的似乎還有所差距，就再接再厲。","text":"回顧了一下2019年對自己的期許，自己與期許的似乎還有所差距，就再接再厲。 希望今年強化自身的網站開發的實力(以後端為主)接下來2020年想要趁下班閒暇時間時來做： 刷刷leetcode 找一個side project來經營 (預計用Java Spring Boot後端, Angular前端) 複習資料結構，資料庫SQL語法等 以上繼續精進，自我勉勵","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://a10000005588.github.io/tags/Life/"}]},{"title":"如何查看透過智能合約存在以太坊上的資料？","slug":"checksmartcontractdata","date":"2019-02-10T15:25:43.000Z","updated":"2019-02-10T15:36:44.807Z","comments":true,"path":"2019/02/10/checksmartcontractdata/","link":"","permalink":"http://a10000005588.github.io/2019/02/10/checksmartcontractdata/","excerpt":"在看這篇文章之前必須要知道一件事，那就是透過智能合約存在區塊鏈上的資訊都是公開的。","text":"在看這篇文章之前必須要知道一件事，那就是透過智能合約存在區塊鏈上的資訊都是公開的。 不管你是否有在智能合約上面有用requre(), revert(), assert()等等來限制某地址的人來存取智能合約上的變數，但這些變數都會存以太坊EVM的Storage上面，每個節點都可以透過以下方式來對EVM的Storage內的編碼進行解析，並還原當初透過合約所儲存的變數資料！！！ 以下透過一個範例來瞭解如何透過web3.js library中的eth.getStorage()方法來解析Storage內儲存的資訊。 智能合約範例：123456789101112131415161718192021222324252627282930313233343536373839404142434445prama solidity ^0.4.0;contract testStorage &#123; uint storeduint1 = 15; uint constant constuint = 16; uint128 investmentsLimit = 17055; uint32 investmentsDeadlinedTimeStamp = uint32(now); bytes16 string1 = 'test1'; bytes32 string2 = 'test1236'; string string3 = 'lets string something'; mapping (address =&gt; uint) uints1; mapping (address =&gt; DeviceData) structs1; uint[] uintarray; DeviceData[] deviceDataArray; struct DeviceData &#123; string deviceBrand; string deviceYear; string batteryWearLevel; &#125; function testStorage() &#123; address address1 = 0xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6 address address2 = 0xaee905fdd3ed851e48d22059575b9f4245a82b04; uints1[address1] = 88; uints1[address2] = 99; var dev1 = DeviceData('deviceBrand', 'deviceYear', 'wearLevel'); var dev2 = DeviceData('deviceBrand2', 'deviceYear2', 'wearLevel2'); structs1[addresss1] = dev1; structs1[addresss2] = dev2; uintarray.push(8000); uintarray.push(9000); deviceDataArray.push(dev1); deviceDataArray.push(dev2); &#125;&#125; 假設我們合約的地址是在：0xf1f5896ace3a78c347eb7eab503450bc93bd0c3b 所有儲存在storage內的參數都可以用index來索引，index的格式為256 bytes以及對應64碼。在以上的範例中我們有 10個參數，所以可以透過index來一一遍歷他們： 12345678910111213141516let contractAddress = &apos;0xf1f5896ace3a78c347eb7eab503450bc93bd0c3b&apos;for (index = 0; index &lt; 10; index++)&#123; console.log(`[$&#123;index&#125;]` + web3.eth.getStorageAt(contractAddress, index))&#125;result:[0] 0x000000000000000000000000000000000000000000000000000000000000000f[1] 0x00000000000000000000000059b92d9a0000000000000000000000000000429f[2] 0x0000000000000000000000000000000074657374310000000000000000000000[3] 0x7465737431323336000000000000000000000000000000000000000000000000[4] 0x6c65747320737472696e6720736f6d657468696e67000000000000000000002a[5] 0x0000000000000000000000000000000000000000000000000000000000000000[6] 0x0000000000000000000000000000000000000000000000000000000000000000[7] 0x0000000000000000000000000000000000000000000000000000000000000002[8] 0x0000000000000000000000000000000000000000000000000000000000000002[9] 0x0000000000000000000000000000000000000000000000000000000000000000 開始針對合約內的10個變數一一做遍歷和解析 index 0 - storeduint11234567let contractAddress = &apos;0xf1f5896ace3a78c347eb7eab503450bc93bd0c3b&apos;let index = 0console.log(web3.eth.getStorageAt(contractAddress, index))console.log(&apos;DEC:&apos; + web3.toDecimal(web3.eth.getStorageAt(contractAddress, index)))result:0x000000000000000000000000000000000000000000000000000000000000000fDEC:15 constuintConstants(常數) 不會被存在storage內，只能夠透過code來存取 index 1 - investmentsLimit, investmentsDeadlineTimeStamp12345let index = 1console.log(web3.eth.getStorageAt(contractAddress, index))result: 0x00000000000000000000000059b92d9a0000000000000000000000000000429fDEC: 1505308058 and 17055 在index 1中，會將2個變數(investmentsLimit, investmentsDeadlineTimeStamp)做合併來最佳化storage的存放 index 2 - string11234567index = 2console.log(web3.eth.getStorageAt(contractAddress, index))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result: 0x0000000000000000000000000000000074657374310000000000000000000000ASCII: test1 index 3 - string21234567index = 3console.log(web3.eth.getStorageAt(contractAddress, index))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result:0x7465737431323336000000000000000000000000000000000000000000000000ASCII: test1236 index 4 - string31234567index = 4console.log(web3.eth.getStorageAt(contractAddress, index))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result:0x6c65747320737472696e6720736f6d657468696e67000000000000000000002aASCII: lets string something * (42) 在result最後有 2a(dec42)為 string儲存的長度可參閱solidity官方文件描述變數在storage中呈現的格式：https://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage index 5 — uints112345index = 5console.log(web3.eth.getStorageAt(contractAddress, index))result:0x0000000000000000000000000000000000000000000000000000000000000000PROBLEM!!!! 若遇到 mapping struct宣告的變數，無法直接透過一般的index來取得struct內所儲存的值，必須得曉得對應value中的 key值，否則是不可能取得的。 1234/* 要取回在 uints1 struct所儲存在addresss1的值 :88// uints1[address1] = 88; address1 = 0xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6 1234567891011index = &apos;0000000000000000000000000000000000000000000000000000000000000005&apos;// convert address1 to the 256 bytes...key = &apos;00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6&apos;let newKey = web3.sha3(key + index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;)console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;DEC: &apos; + web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000000058DEC: 88 index6 - structs1123456789index = &quot;0000000000000000000000000000000000000000000000000000000000000006&quot;key = &quot;00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6&quot;let newKey = web3.sha3(key + index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;)console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963654272616e64000000000000000000000000000000000000000016ASCII: deviceBrand 若要讀取下一個struct的值，只需要將newKey的值+1即可取到。 12345678910111213141516function increaseHexByOne(hex) &#123; let x = new BigNumber(hex) let sum = x.add(1) let result = &apos;0x&apos; + sum.toString(16) return result&#125;index = &quot;0000000000000000000000000000000000000000000000000000000000000006&quot;key = &quot;00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6&quot;let newKey = increaseHexByOne( web3.sha3(key + index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;))console.log(web3.eth.getStorageAt(contractAddress,newKey))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963655965617200000000000000000000000000000000000000000014ASCII: deviceYear 若還需要第三個之後的值，繼續將newKey遞增，就能夠取到。 index 7 - uintarray12345index = &quot;7&quot;console.log(web3.eth.getStorageAt(contractAddress, index))result: 0x0000000000000000000000000000000000000000000000000000000000000002 以上的result表示 array目前有2個值 (8000, 9000) 123456789101112131415161718index = &quot;0000000000000000000000000000000000000000000000000000000000000007&quot;let newKey = web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;)console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;DEC: &apos; + web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000001f40DEC: 8000---newKey = increaseHexByOne(web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;))console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;DEC: &apos; + web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000002328DEC: 9000 index 8 - deviceDataArray1234567891011121314151617181920index = &quot;0000000000000000000000000000000000000000000000000000000000000008&quot;let newKey = web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;)console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963654272616e64000000000000000000000000000000000000000016ASCII: deviceBrand---index = &quot;0000000000000000000000000000000000000000000000000000000000000008&quot;let newKey = increaseHexByOne(web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;))console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;ASCII: &apos; +web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963655965617200000000000000000000000000000000000000000014ASCII: deviceYear 繼續增加index的值(+1), result: 12345678index = &quot;0000000000000000000000000000000000000000000000000000000000000008&quot;let newKey = increaseHexByTwo(web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;))console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;ASCII: &apos; +web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x776561724c6576656c0000000000000000000000000000000000000000000012ASCII: wearLevel 若加3之後，result會顯示第二組(dev2) 存進array的值 1234result:0x6465766963654272616e64320000000000000000000000000000000000000018ASCII: deviceBrand2 ReferenceHow to read Ethereum contract storage - Darius https://medium.com/aigang-network/how-to-read-ethereum-contract-storage-44252c8af925","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/tags/Solidity/"},{"name":"Smart Contract","slug":"Smart-Contract","permalink":"http://a10000005588.github.io/tags/Smart-Contract/"}]},{"title":"2019年的想法與規劃","slug":"2019年的想法與規劃","date":"2019-02-05T13:24:10.000Z","updated":"2020-01-01T13:14:35.237Z","comments":true,"path":"2019/02/05/2019年的想法與規劃/","link":"","permalink":"http://a10000005588.github.io/2019/02/05/2019年的想法與規劃/","excerpt":"剛好在農曆新年第一天，為自己的Blog換的新的Skin，同時也想勉勵自己重拾寫部落格的手感。","text":"剛好在農曆新年第一天，為自己的Blog換的新的Skin，同時也想勉勵自己重拾寫部落格的手感。 由於自己想往區塊鏈或是雲端後端工程師發展，所以在2019年希望自己能夠再次複習網路以及作業系統等知識， 以上，希望2019年能夠順利完成論文，且能夠找到一份好工作，並且持續精進自己的技術。","categories":[{"name":"Life","slug":"Life","permalink":"http://a10000005588.github.io/categories/Life/"}],"tags":[]},{"title":"以太坊測試網連接：Connect to the Rospen Network","slug":"rospen","date":"2018-05-13T08:22:06.000Z","updated":"2020-07-26T09:17:43.173Z","comments":true,"path":"2018/05/13/rospen/","link":"","permalink":"http://a10000005588.github.io/2018/05/13/rospen/","excerpt":"Enviroment: MacOS Assume reader has basic understanding of geth and ethereum.","text":"Enviroment: MacOS Assume reader has basic understanding of geth and ethereum. Create a Ethereum WalletWe can via myetherwallet to create a wallet.https://www.myetherwallet.com/#generate-wallet Record your privakey, pubkey:12private key: a406da76baa7c741ad28bfe87cef2133950d6bb6bcaaf0b1742d93c3bea56babpublic key: 0x2C58e0338435FE91FD2209105EcADebE8aaFCebB Because we are going to connect the testnet Rospen, we should do some stuff… Get a ether from faucet: For simplicity, we just ask someone to send some ether on testnet to us. Please attach your account address to get some ether. https://l.facebook.com/l.php?u=http%3A%2F%2Ffaucet.ropsten.be%3A3001%2F&amp;h=ATPjPzMFxxXmP_Egwq9V35ye_LjGOM4A_vzMkbQOdLCN8FYVRgfurVVTwrcuUzqNCMUiXF2C8sUqt241q8nmTJO6hCnY7WhpkV6iUVWxsIqjlALAeEVFv_kH5Q Check Tx from Rospen networkhttps://ropsten.etherscan.io/address/0x6508a973F080A9042a29d13925d9DB006f8c2989 In serch bar, enter your account address to see whether if the ether is sending to your account or not. Start to build a node and synchronize the Rospen network. Notice that your geth version should be the latest so that you can sucessfully sync the network. Current version : Version: 1.8.7-stable Before sync the node , Put your keystore file in the testnet document.When you download your keystore file.For example, the filename will be:UTC--2018-05-13T04-05-37.569Z--2c58e0338435fe91fd2209105ecadebe8aafcebbCopy this file into your testnet key store:/User/Library/Ethereum/testnet/keystore Sync to the Rospen networkhttps://github.com/ethereum/ropsten 1geth --unlock &lt;account&gt; --testnet --syncmode &quot;full&quot; &quot;enode://20c9ad97c081d63397d7b685a412227a40e23c8bdc6688c6f37e97cfbc22d2b4d1db1510d8f61e6a8866ad7f0e17c02b14182d37ea7c3c8b9c2683aeb6b733a1@52.169.14.227:30303,enode://6ce05930c72abc632c58e2e4324f7c7ea478cec0ed4fa2528982cf34483094e9cbc9216e7aa349691242576d552a2a56aaeae426c5303ded677ce455ba1acd9d@13.84.180.240:30303&quot; Threre are some flags: –unlock : use password to unlock the account. –testnet: connect to the rospen network. –syncmode “full”: in order to get our balances, we should synchronize whole blocks. 1geth --testnet --fast --bootnodes &quot;enode://20c9ad97c081d63397d7b685a412227a40e23c8bdc6688c6f37e97cfbc22d2b4d1db1510d8f61e6a8866ad7f0e17c02b14182d37ea7c3c8b9c2683aeb6b733a1@52.169.14.227:30303,enode://6ce05930c72abc632c58e2e4324f7c7ea478cec0ed4fa2528982cf34483094e9cbc9216e7aa349691242576d552a2a56aaeae426c5303ded677ce455ba1acd9d@13.84.180.240:30303&quot; If we already sync the entire network, we can just use--fast --bootnodes to connect testnet… Attach your gethOn MacOS (for testnet): geth attach ipc:/Users/&lt;username&gt;/Library/Ethereum/testnet/geth.ipc Then, in the console do eth.syncing you will see those stuff: 12345678&gt; eth.syncing&#123; currentBlock: 542220, highestBlock: 3224277, knownStates: 0, pulledStates: 0, startingBlock: 31397&#125; That means you are sucessfully connecting the testnet.After finish syncing process, you can see there is some ether in your accounts Problem for connecting the ropsten networkhttps://stackoverflow.com/questions/49195614/connection-failed-to-ethereum-ropsten-testnet-network Deploy to rospen network toturial:https://michalzalecki.com/deploying-smart-contracts-with-truffle/","categories":[{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/categories/Ethereum/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://a10000005588.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"}]},{"title":"ERC Token介紹：ERC20 & ERC721","slug":"erctoken","date":"2018-03-25T11:54:59.000Z","updated":"2020-07-26T09:16:56.792Z","comments":true,"path":"2018/03/25/erctoken/","link":"","permalink":"http://a10000005588.github.io/2018/03/25/erctoken/","excerpt":"即利用當今火紅的以太坊上的智能合約，實作出代幣功能。可擁有與虛擬貨幣作為價值傳遞功能。","text":"即利用當今火紅的以太坊上的智能合約，實作出代幣功能。可擁有與虛擬貨幣作為價值傳遞功能。 好處 不用自己架設公有鏈，就可以擁有自己發行的代幣 以既定匯率，可以直接與以太幣進行交換。 為何需要ERC標準合約？由於代幣是建立在以太坊上的智能合約，故其代幣也只是存在智能合約上的某筆紀錄。故透過一些狀態改變和轉移，故ERC合約可以明確定義某個以太坊地址上的某個代幣餘額，並可以對其進行操作，而操作的規範就定義在ERC上。 故一個代幣要擁有合理的發行機制，就得符合現在所擁有的ERC20以及ERC721之類的標準。 ERC代幣有自己的錢包嗎？？由於是透過以太坊智能合約控制的，故只要透過以太坊錢包(地址)就可以了。 ERC20 介紹記載ERC20規則 官方文件https://theethereum.wiki/w/index.php/ERC20_Token_Standard ERC20 Token Standard Interface12345678910interface ERC20 &#123; function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); | function allowance(address tokenOwner, address spender) public constant returns (uint remaining); | function transfer(address to, uint tokens) public returns (bool success); | function approve(address spender, uint tokens) public returns (bool success); | function transferFrom(address from, address to, uint tokens) public returns (bool success); | event Transfer(address indexed from, address indexed to, uint tokens); | event Approval(address indexed tokenOwner, address indexed spender, uint tokens); &#125; 以上的Interface定義了六個Function，有Input及Output格式。以及兩個Event，僅有Input。 其中Function為可以操縱智能合約狀態的動作，會需要消耗Gas，而可以看到有些Function後面有 constant關鍵字，表示僅做唯獨，不會更改到智能合約上的State，主要是回傳的State資訊，不會消耗到Gas。 而Event為紀錄重大事件的發生，例如在鏈上進行Token的轉移。 設定ERC Token資訊123string public constant name = \"Token Name\"; string public constant symbol = \"TKN\"; uint8 public constant decimals = 18; // 18 is the most common number of decimal places ERC20 需要設定此 Token 的三個資訊: name、symbol、decimals name 是 Token 的名字。 symbol 則是此 Token 會使用的代稱，像是 Binance Token 的 symbol 就是 BNB，而此 symbol 也會出現在 Etherscan上面 decimals 是用來設定此 Token 最小會有幾個位數，通常會設定成 18，意即最多到達小數點後 18 位數，這樣的設定跟 Ether 本身的設定也是一樣的(1 ether: 10 ^ 18 wei)。 補充說明：在 Solidity 中並沒有浮點數的存在，所有的運算都是整數，因此平常我們所說的 1 Ether，事實上在 Solidity 程式中是以wei的單位(1 ether = 10¹⁸)來撰寫。 ERC20 詳述12345678910111213141516171819202122232425262728293031323334353637383940414243contract TokenContractFragment &#123; // Balances for each account mapping(address =&gt; uint256) balances; // Owner of account approves the transfer of an amount to another account mapping(address =&gt; mapping (address =&gt; uint256)) allowed; // Get the token balance for account \\`tokenOwner\\` function balanceOf(address tokenOwner) public constant returns (uint balance) &#123; return balances\\[tokenOwner\\]; &#125; // Transfer the balance from owner's account to another account function transfer(address to, uint tokens) public returns (bool success) &#123; balances\\[msg.sender\\] = balances\\[msg.sender\\].sub(tokens); balances\\[to\\] = balances\\[to\\].add(tokens); Transfer(msg.sender, to, tokens); return true; &#125; // Send \\`tokens\\` amount of tokens from address \\`from\\` to address \\`to\\` // The transferFrom method is used for a withdraw workflow, allowing contracts to send // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge // fees in sub-currencies; the command should fail unless the _from account has // deliberately authorized the sender of the message via some mechanism; we propose // these standardized APIs for approval: function transferFrom(address from, address to, uint tokens) public returns (bool success) &#123; balances\\[from\\] = balances\\[from\\].sub(tokens); allowed\\[from\\]\\[msg.sender\\] = allowed\\[from\\]\\[msg.sender\\].sub(tokens); balances\\[to\\] = balances\\[to\\].add(tokens); Transfer(from, to, tokens); return true; &#125; // Allow \\`spender\\` to withdraw from your account, multiple times, up to the \\`tokens\\` amount. // If this function is called again it overwrites the current allowance with _value. function approve(address spender, uint tokens) public returns (bool success) &#123; allowed\\[msg.sender\\]\\[spender\\] = tokens; Approval(msg.sender, spender, tokens); return true; &#125;&#125; 使用例子Token Balance我們假設這個智能合約目前有兩個地址擁有該Tokenbalances[‘0x123456’] = 100balances[‘0x654321’] = 200 則 Function balanceOf 則會回傳以下資訊:tokenContract.balanceOf(‘0x123456’) will return 100tokenContract.balanceOf(‘0x654321’) will return 200 Transfer Token Balance如果 0x123456想要轉移 10 tokens 給 0x654321，則呼叫tokenContract.transfer(‘0x654321’, 10) 將得到下列結果balances[‘0x123456’] = 90balances[‘0x654321’] = 210 Approve And TransferFrom Token Balance如果 0x123456 允許 0x654321 擁有轉移 30 tokens 的權利，則呼叫tokenContract.approve(‘0x654321’, 30) 將得到下列結果tokenContract.allowed[‘0x123456’][‘0x654321’] = 30 如果此時’0x654321’ 想要轉移 ‘0x123456’ 的 20 tokens 給自己，則呼叫‘tokenContract.transferFrom(‘0x123456’, ‘0x654321’, 20) 將得到下列結果tokenContract.balances[‘0x123456’] = 70tokenContract.balances[‘0x654321’] = 230tokenContract.allowed[‘0x123456’][‘0x654321’] = 10 ERC721 介紹ERC-721 是用来定義 Non-fungible token (不可替代的代幣)。每個代幣是唯一的(unique)，具不可分割性，不像ERC20 每個token都相同。 具體應用: 以太貓(cryptokitties)每個以太貓，都是一個ERC721代幣。 1234567891011interface ERC721 &#123; function supportsInterface(bytes4 _interfaceID) external pure returns (bool); function ownerOf(uint256 \\_deedId) external view returns (address \\_owner); function countOfDeeds() external view returns (uint256 _count); function countOfDeedsByOwner(address \\_owner) external view returns (uint256 \\_count); function deedOfOwnerByIndex(address \\_owner, uint256 \\_index) external view returns (uint256 _deedId); event Transfer(address indexed from, address indexed to, uint256 indexed deedId); event Approval(address indexed owner, address indexed approved, uint256 indexed deedId); function approve(address \\_to, uint256 \\_deedId) external payable; function takeOwnership(uint256 _deedId) external payable;&#125; 參考資料 ERC20 Token Standardhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard 请问以太坊里的ERC-721和ERC-20是什么？http://www.blockchainbrother.com/question/510 What has ERC-721 better than ERC-20?https://medium.com/@PatrickGohBS/ethereum-erc-721-vs-erc-20-4bff8c147fdf","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"}]},{"title":"分散式系統共識算法筆記：Paxos和Raft","slug":"consensusAlgo","date":"2018-03-10T16:00:00.000Z","updated":"2019-02-05T13:06:27.330Z","comments":true,"path":"2018/03/11/consensusAlgo/","link":"","permalink":"http://a10000005588.github.io/2018/03/11/consensusAlgo/","excerpt":"Paxos介紹分布式系統中，只有出現故障節點(fault node),但不存在惡意節點(corrupt node)下達成共識的問題。","text":"Paxos介紹分布式系統中，只有出現故障節點(fault node),但不存在惡意節點(corrupt node)下達成共識的問題。 問題起源故事背景為古希臘的Paxon島上有諸位法官要對某一件法案進行裁決並如何達成共識的結果。 過程中法官會透過傳訊關傳遞訊息，但法官可能中途離席，而服務員可能偷懶睡覺。 故Paxos算法基於“兩階段提交”來確保法官們可以得到共識結果的一致性。 Paxos特性Paxos將參與節點中分為三類： Proposer(客戶端): 提出一個案子，等待大家批准並得到答案。 Acceptor(服務端): 接受提案，並進行投票。 Learner(客戶端or服務端): 被告知提案結果，並將自己的狀態與結果更新。 過程中必須滿足分散式系統共識所必須的兩特性： Safty：保證決議結果是對的，無異議，並不會出現錯誤情況。 Liveness：保證在”有限”時間內完成共識結果。 Paxos過程 由Proposer提出提案，爭取Acceptors的支持。 超過一半的Acceptors支持，則發送該提案結果給所有人進行確認。 兩階段提繳Step 1: Prepare階段 Proposer發送自己的計畫給多個Acceptors. Acceptor根據該計畫的編號，若是最新的編號則保留，反之則退回。 Step 2: Commit階段 Proposer收到Accpetor的確認回覆。若收到的回覆中不帶有新的提案請求，表示鎖定成功。 若沒有收到超過1/2個Accpetor的回覆。 特殊情況 若Proposer在提案過程中發生故障，可以透過超時機制票選下一位Proposer。 Paxos算法保證在正常節點有 1/2個以上時，可滿足共識的Safety和Liveness. Raft介紹為Paxos的簡化版本。 參與者包括三種角色： 1.Leader 2.Candidate 3.Follower 共識流程 Leader選舉：每個Candidate在一定時間內會提出選舉方案，而選舉結果的那位成為Leader. 同步每個Replication的Log: Leader會找到系統中的Log檔案上最新的紀錄，並要求所有Follower根據該最新紀錄同步到他們自己的Log檔案上。 log檔可能為系統上發生的動作紀錄。 小結Paxos和Raft為目前分散式系統的帶來不錯的共識結果，其他共識演算法像是PBFT (practical byzantine fault tolerant protocal)以及目前由Amis團隊所於etherum上所實現的BFT算法- Istanbul BFT，都算是本次筆記提到的再進階的共識算法，有興趣的讀者可以在到以下連結去深入瞭解。 Istanbul BFT - AMIS PBFT Introduction","categories":[{"name":"Consensus","slug":"Consensus","permalink":"http://a10000005588.github.io/categories/Consensus/"}],"tags":[{"name":"Consensus","slug":"Consensus","permalink":"http://a10000005588.github.io/tags/Consensus/"},{"name":"Blockchain","slug":"Blockchain","permalink":"http://a10000005588.github.io/tags/Blockchain/"}]},{"title":"Javascript筆記:Closure(閉包)概念","slug":"javascript-closure","date":"2017-09-13T04:43:04.000Z","updated":"2020-07-26T09:17:28.824Z","comments":true,"path":"2017/09/13/javascript-closure/","link":"","permalink":"http://a10000005588.github.io/2017/09/13/javascript-closure/","excerpt":"閉包（closure): 為一個function包在某一個函式內，用return來取得內部function的回傳值 Closure are commonly used to give objects data privacy.","text":"閉包（closure): 為一個function包在某一個函式內，用return來取得內部function的回傳值 Closure are commonly used to give objects data privacy. 為什麼要有閉包？？因為有以下問題ㄧ、Counter dilemma123456789101112var counter = 0;function add() &#123; counter += 1;&#125;add();add();add();// the counter is now equal to 3 counter被改變成3、不過也可以不用透過add()直接更改counter的值。那這樣會造成變數污染衝突。 12345678function add() &#123; var counter = 0; counter += 1;&#125;add();add();add(); counter被宣告在add()內，為local variable，不會被其他function或global改寫。但會有重複呼叫add()後無法使counter值做累加的動作。(因為var counter使變數重複被定義)。 二、解決方法 1234567function add() &#123; var counter = 0; function plus() &#123;counter += 1;&#125; plus(); return counter; &#125; 透過內部plus函式才能更改counter值、解決counter dilemma問題，不過還會遇到var counter重複宣告的問題，這時候就得用閉包的技巧！如下： 1234567891011var add = (function () &#123; var counter = 0; return function () &#123;return counter += 1;&#125;&#125;)();add();add();add();// the counter is now 3 將add變數宣告成 self-invoking function(僅執行內部一次 var counter不會在add()第二次被呼叫時再次被宣告)，然後回傳function expression，如此一來add變數就變成 add() function了！ 12var counter = 0;return function () ***&#123;return counter += 1;***&#125; 就被包在add()函式內，直接呼叫add() 就只會跑上面*的部分。 以上做法即為closure閉包，使得變數不會被污染和衝突。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://a10000005588.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://a10000005588.github.io/tags/Javascript/"}]},{"title":"Javascript筆記:使用prototype chain(原型鍊)來達成繼承效果","slug":"javascript-prototypechain","date":"2017-09-13T04:39:37.000Z","updated":"2020-07-26T09:17:34.981Z","comments":true,"path":"2017/09/13/javascript-prototypechain/","link":"","permalink":"http://a10000005588.github.io/2017/09/13/javascript-prototypechain/","excerpt":"先知道個keyword： __proto__： javascript自己定義的變數，用來實現inheritance效果，有點類似像link list node的概念，連結其他的 prototype","text":"先知道個keyword： __proto__： javascript自己定義的變數，用來實現inheritance效果，有點類似像link list node的概念，連結其他的 prototype javascript記憶體管理的配置： class儲存在 global底下 class的prototype放置在heap （即class底下的各種variable和function) instance（ex var b = new B()) 的b儲存在 callstack(記憶體RAM裡面) slogan:在自己的scope裡面找不到要的函式或變數就跟自己的__proto__要！ 繼承範例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var Car = function()&#123; //constructor this.brand = \"default\"; var _wheels // private method var initialWheels = function () &#123; _wheels = 4 &#125; this.getNumberofWheel = function()&#123; return this.brand; &#125;&#125;var Benz = function(brandName) &#123; //constructor Car.apply(this, argument) //等於呼叫 super(args); //argument為 var Benz = function(args...); 的 args們 = [brandName, wheel] // 這一行就是把 Benz.prototype.__proto__ = Car.prototype接起來; // 即Benz class inheritance Car // 疑問：上面敘述需和Ben確認一下 那這樣為什麼下面又得自己做Benz.prototype = Object.create(Car.prototype) ?? // 解答：若沒有做Car.apply (即super()) 動作，這樣子類別會無法將接受的arguments傳遞給從parent複製過來的函式 this.brand = brandName; //初始化車品牌的名稱 &#125;// javascript ES5得自己綁定繼承關係，用__proto__這個keyword// 建立父類別實體 設定繼承關係:Benz.prototype = Object.create(Car.prototype) //上面即是做了Benz.prototype.__proto__ = Car.prototype//使Benz class繼承Car class(Benz extends Car)Benz.prototype.constructor = Benz//Benz的constructor指向Benz class//將Benz的constructor綁定到自己身上，//才能在Benz new出一個物件時作初始化動作（即呼叫Benz =function函式&#123;&#125;) //var benz = new Benz(\"Benz\") 初始化該車子名稱：\"Benz\"; var benz = new Benz() // benz.__proto__ = Benz.prototype// 宣告一個物件叫 benzconsole.log(benz.numberOfWheels()) // 會先搜尋benz.prototype有沒有numberOfWheels()方法// 沒有==&gt;那就找benz.__proto__ = Benz.prototype;// Benz.prototype就會找到 numberOfWheels()的方法！ benz.numberOfWheels() 有此方法 每次呼叫Car.apply(this, arguments)時”複製”到子類別的物件上初始化物件時較慢，在run time想要動態改變numberOfWheels()的實作時 無法影響已經創建的子類別或父類別instances. 以下為初始化較有效率的寫法：1234567891011121314151617181920212223242526var Car = function () &#123; // constructor // public property this.wheels = 4 // pulic property this.brand = 'default'&#125;// 這種寫法不支援存取private property// 因為每個物件都可以直接存取掛在parent.prototype上的property// 但可以在run time修改此Car.prototype.numberOfWheels()的實作// 就可以透過prototype chain更改所有相關的instance功能 因為instance共用prototype chain上的方法Car.prototype.numberOfWheels = function () &#123; return this.wheels&#125;var Benz = function (brandName) &#123; Car.apply(this, arguments) // 複製繼承父類別public property this.brand = 'brandName'; this.getBrand = function () &#123; return this.brand &#125;&#125;... numberOfWheels該方法已經被掛在 Car.prototype上，所以並不像Car.apply上直接複製一份給子class們，而是子class去共用Car.prototype.numberOfWheels 這個方法。 優點：節省初始化的時間和提升效率 缺點：這種寫法不支援存取private property javascript 類別、prototype以及reference中的proto所指向的關係示意圖：圖片作者： Ben大大 假設 B class extend A;let b = new B(); // b.__proto__ = B.prototypelet a = new A(); // a.__proto__ = A.prototypelet o = new Object(); o.__proto__ = Object.prototype//對應到圖片左邊的b、a、o. (先從圖片最左上角開始看那 var b = new B();b想要使用繼承A的 getValue() 函式，那麼就得先找自己的 b.prototype 沒有的話 找 b.__proto__ = B.prototype 若b.__proto__也沒有的話(即B.prototype)也沒有，那麼找 B.prototype.__proto__ == A.prototype在A.prototype就會找到getValue()的函式！ 如果又沒找到，那就最後找A.prototype.__proto__ == Object.prototype若沒有那就找 Object.prototype.__proto__ == null 即找無該函式，compile告知發生錯誤); Prototype inheritance 的好處 Suitable in loosely typed environments, no need to define explicit types. Makes it incredibly easy to implement singleton pattern (compare JavaScript and Java in this regard, and you’ll know what I am talking about). (why? 因為prototype inheritance提供???? 請看補充二） Provides ways of applying a method of an object in the context of a different object, adding and replacing methods dynamically from an object etc. (things which are not possible in a strongly typed languages). Prototype inheritance的壞處 No easy way of implementing private variables. Its possible to implement private vars using Crockford’s wizardry using closures, but its definitely not as trivial as using private variables in say Java or C#.(因為__prpto__會指向prototype的所有成員！故無法像class inheritance那樣避免繼承到有private關鍵字的變數，故得用closure手法來避免繼承到_private變數) Reference:prototype based vs. class based inheritance 補充ㄧ：Function.prototype.applyfun.apply(thisArg, [argsArray])// 將一連串參數用array包起來：[argsArray]，丟給fun函式處理 範例：1234567891011121314function theFunction(name, profession) &#123; console.log(&quot;My name is &quot; + name + &quot; and I am a &quot; + profession + &quot;.&quot;);&#125;// call functionfunction callFn(name, profession) &#123; theFunction.apply(this, [name, profession]);&#125;theFunction(&apos;小will&apos;, &apos;工程師&apos;);callFn(&apos;大Will&apos;, &apos;小廢廢&apos;);// 輸出:// My name is 小will and I am a 工程師.// My name is 大Will and I am a 小廢廢. 補充二：用Closure實作Singleton模式閉包觀念連結：==&gt; 閉包是什麼？？ 先看範例程式碼1234567891011121314151617181920var UniverseN;(function()&#123; var instance; UniverseN = function UniverseN()&#123; if(instance)&#123; return instance; &#125; instance = this; this.start_time = 0; this.bang = 'Big'; &#125;;&#125;());var uni9 = new UniverseN();var uni10 = new UniverseN();console.log(uni9 === uni10); //trueUniverseN.prototype.inEverything = true; 可以看出若利用了Prototype inheritance的特性，，將IIFE函式掛在UniverseN.prototype.IIFE上，使得之後宣告的物件不會在複製一份IIFE出來出來，讓IIFE只跑一次！這樣就可以達成一個class (UniverseN) 只能宣告一次的物件 (uni9)。 如果在宣告出 uni10，他們都還是指向同一樣的instance(uni9.__proto__ == uni10__proto__) Reference:JavaScript Design Pattern - Singleton 單體模式","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://a10000005588.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://a10000005588.github.io/tags/Javascript/"}]},{"title":"使用OpenZeppelin搭配Truffle來打造智能合約","slug":"openzepplin","date":"2017-09-13T02:43:31.000Z","updated":"2020-07-26T09:17:39.142Z","comments":true,"path":"2017/09/13/openzepplin/","link":"","permalink":"http://a10000005588.github.io/2017/09/13/openzepplin/","excerpt":"本篇是參考truffle官網所做的筆記：ROBUST SMART CONTRACTS WITH OPENZEPPELIN","text":"本篇是參考truffle官網所做的筆記：ROBUST SMART CONTRACTS WITH OPENZEPPELIN OpenZeppelin介紹可以把OpenZeppelin當成強化Solidity資訊安全的Framework，為智能合約附上Ethereum所認可的ERC-20標準，畢竟合約要處理的可是真正的錢！ ERC-20標準介紹：What is ERC-20 and What Does it Mean for Ethereum? 簡單來說ERC-20標準允許錢包、交易所和其他智能合約以一種常見的方式對接各種代幣。 使用OpenZeppelin預備知識建議先瞭解ethereum以及Smart Contract語言Solidity以及開發Smart Contract的框架 Truffle 可以參考官網或是我之前所做的筆記 Ethereum官方網站： 菜鳥William的Solidity學習紀錄 使用Truffle來練習撰寫認養寵物的智能合約 環境設定創立一個資料夾 open_z使用truffle unbox把練習專案給下載到本機上12cd open_ztruffle ubbox tutorialtoken 安裝 zeppelin-solidity 1npm install zeppelin-solidity 為tutorialtoken專案撰寫 TutorialToken合約在 /contracts 目錄底下創建 TutorialToken.sol TutorialToken.sol12345678910111213141516171819pragma solidity ^0.4.4;// 引入zepplin-solidity的StandardToken.sol 合約import 'zeppelin-solidity/contracts/token/StandardToken.sol';// 使用is 來繼承StandardToken合約contract TutorialToken is StandardToken &#123; string public name = 'TutorialToken'; // token name string public symbol = 'TT'; uint public decimals = 2; // 合約被創建時所產生的金額總數 uint public INITIAL_SUPPLY = 12000; function TutorialToken() &#123; totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; &#125;&#125; 透過以上簡短的程式碼就已經創造出符合Ethereum的 ERC-20標準的Token囉！ 編譯(Compile)以及部署(Deploy)在/migrations內，創建2_deploy_contracts.js檔案 2_deploy_contracts.js12345var TutorialToken = artifacts.require(\"./TutorialToken.sol\");module.exports = function(deployer) &#123; deployer.deploy(TutorialToken);&#125;; 在terminal，先用testrpc啟好自己的測試鍊 1testrpc then 執行12truffle comiletruffle migrate 和TutorialToken Dapp互動我們使用metamask和我們的Dapp互動 並且該專案已經內建 lite-server可運行Dapp 執行1npm run dev 看到以下畫面則表示成功運行！(別忘了要先登入metamask，以便前端能夠擷取到testrpc所開啟的錢包資訊) 以及可以看到在metamask上錢包的資訊 總結: Truffle+OpenZeppelin = A Superb Development Experience透過： Truffle：開發智能合約的框架 OpenZeppelin：可為智能合約提供ERC-20標準的工具 就可以打造出可上市的智能合約的開發環境！ 對OpenZeppelin內的合約架構有興趣的朋友可以觀看我這篇筆記： OpenZeppelin合約架構透析","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/tags/Solidity/"},{"name":"Truffle","slug":"Truffle","permalink":"http://a10000005588.github.io/tags/Truffle/"}]},{"title":"Solidity學習紀錄","slug":"solidity","date":"2017-09-12T13:34:23.000Z","updated":"2020-07-26T09:17:50.095Z","comments":true,"path":"2017/09/12/solidity/","link":"","permalink":"http://a10000005588.github.io/2017/09/12/solidity/","excerpt":"這篇主要記錄著我對Solidity官網文檔的學習紀錄","text":"這篇主要記錄著我對Solidity官網文檔的學習紀錄 簡單的合約開始介紹起1234567891011121314pragma solidity ^0.4.0; // 告訴compiler要如何對待這份codecontract SimpleStorage &#123; uint storedData; // 宣告uint型態的變數 uint為 256 bits. // 以下控制stored variable. function set(uint x) &#123; storedData = x; &#125; function get() constant returns (uint) &#123; return storedData; &#125;&#125; 另外一個比較複雜的合約 123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.0;contract Coin &#123; // The keyword \"public\" makes those variables // readable from outside. address public minter; mapping (address =&gt; uint) public balances; // 可把mapping 當成是hash tables // 將address當參數 映射到balances中會得到uint型態的回傳值 // Events allow light clients to react on // changes efficiently. event Sent(address from, address to, uint amount); // 和contract同名的函式名稱即為constructor，在合約被創造出來時呼叫 function Coin() &#123; minter = msg.sender; &#125; function mint(address receiver, uint amount) &#123; if (msg.sender != minter) return; balances[receiver] += amount; &#125; function send(address receiver, uint amount) &#123; if (balances[msg.sender] &lt; amount) return; balances[msg.sender] -= amount; balances[receiver] += amount; Sent(msg.sender, receiver, amount); // msg.sender 合約的持有者 &#125;&#125; address：160-bit value that does not allow any arithmetic operations. public：使其他合約可以存取自己的scope function,variable. address public minter 可看成如下： 1function minter() returns (address) &#123; return minter; &#125; mapping (address =&gt; uint) public balances;可看成如下 123function balances(address _account) returns (uint) &#123; return balances[_account];&#125; event Sent(address from, address to, uint amount); 透過該Sent function方便追蹤錢的流出和流入地址是哪 Coin()：為建構子，合約創造出來就會呼叫且建構子會儲存： msg：儲存創造合約的人的address以及其他properties (tx,block…)，擁有直接和blockchain溝通的權利 msg.sender：呼叫合約的人，若contract A呼叫contract B，那msg.sender在contract A B都是相同的。 Ethereum Virtual MachineThe Ethereum Virtual Machine or EVM is the runtime environment for smart contracts in Ethereum. Features: OverviewThe Ethereum Virtual Machine or EVM is the runtime environment for smart contracts in Ethereum AccountsExternal accounts that are controlled by public-private key pairs (i.e. humans)Contract accounts which are controlled by the code stored together with the account.—-Every account has a persistent key-value store mapping 256-bit words to 256-bit words called storage. Transactions GasThe gas price is a value set by the creator of the transaction合約的手續費，用來執行合約的燃料，避免Contract有bug會把錢一直轉走 Storage, Memory and the Stack Storage:每個Contract都會持有自己的storage,storage為一個key-value store that maps 256-bit words to 256-bit words. Memory：of which a contract obtains a freshly cleared instance for each message call Delegatecall / Callcode and Libraries Solidity ExamplesSolidity Example 1：Voting Contract.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138pragma solidity ^0.4.11;/// @title Voting with delegation.contract Ballot &#123; // This declares a new complex type which will // be used for variables later. // It will represent a single voter. struct Voter &#123; uint weight; // weight is accumulated by delegation bool voted; // if true, that person already voted address delegate; // person delegated to uint vote; // index of the voted proposal &#125; // This is a type for a single proposal. struct Proposal &#123; bytes32 name; // short name (up to 32 bytes) uint voteCount; // number of accumulated votes &#125; address public chairperson; // This declares a state variable that // stores a `Voter` struct for each possible address. // 將每一個地址映射到對應的 Voter struct. mapping(address =&gt; Voter) public voters; // A dynamically-sized array of `Proposal` structs. Proposal[] public proposals; /// Create a new ballot to choose one of `proposalNames`. function Ballot(bytes32[] proposalNames) &#123; chairperson = msg.sender; voters[chairperson].weight = 1; // For each of the provided proposal names, // create a new proposal object and add it // to the end of the array. for (uint i = 0; i &lt; proposalNames.length; i++) &#123; // `Proposal(&#123;...&#125;)` creates a temporary // Proposal object and `proposals.push(...)` // appends it to the end of `proposals`. proposals.push(Proposal(&#123; name: proposalNames[i], voteCount: 0 &#125;)); &#125; &#125; // Give `voter` the right to vote on this ballot. // May only be called by `chairperson`. function giveRightToVote(address voter) &#123; // If the argument of `require` evaluates to `false`, // it terminates and reverts all changes to // the state and to Ether balances. It is often // a good idea to use this if functions are // called incorrectly. But watch out, this // will currently also consume all provided gas // (this is planned to change in the future). require((msg.sender == chairperson) &amp;&amp; !voters[voter].voted &amp;&amp; (voters[voter].weight == 0)); voters[voter].weight = 1; &#125; /// Delegate your vote to the voter `to`. function delegate(address to) &#123; // assigns reference Voter storage sender = voters[msg.sender]; require(!sender.voted); // Self-delegation is not allowed. require(to != msg.sender); // Forward the delegation as long as // `to` also delegated. // In general, such loops are very dangerous, // because if they run too long, they might // need more gas than is available in a block. // In this case, the delegation will not be executed, // but in other situations, such loops might // cause a contract to get \"stuck\" completely. while (voters[to].delegate != address(0)) &#123; to = voters[to].delegate; // We found a loop in the delegation, not allowed. require(to != msg.sender); &#125; // Since `sender` is a reference, this // modifies `voters[msg.sender].voted` sender.voted = true; sender.delegate = to; Voter delegate = voters[to]; if (delegate.voted) &#123; // If the delegate already voted, // directly add to the number of votes proposals[delegate.vote].voteCount += sender.weight; &#125; else &#123; // If the delegate did not vote yet, // add to her weight. delegate.weight += sender.weight; &#125; &#125; /// Give your vote (including votes delegated to you) /// to proposal `proposals[proposal].name`. function vote(uint proposal) &#123; Voter storage sender = voters[msg.sender]; require(!sender.voted); sender.voted = true; sender.vote = proposal; // If `proposal` is out of the range of the array, // this will throw automatically and revert all // changes. proposals[proposal].voteCount += sender.weight; &#125; /// @dev Computes the winning proposal taking all /// previous votes into account. function winningProposal() constant returns (uint winningProposal) &#123; uint winningVoteCount = 0; for (uint p = 0; p &lt; proposals.length; p++) &#123; if (proposals[p].voteCount &gt; winningVoteCount) &#123; winningVoteCount = proposals[p].voteCount; winningProposal = p; &#125; &#125; &#125; // Calls winningProposal() function to get the index // of the winner contained in the proposals array and then // returns the name of the winner function winnerName() constant returns (bytes32 winnerName) &#123; winnerName = proposals[winningProposal()].name; &#125;&#125; Solidity Example 2：Simple Open Auction123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119pragma solidity ^0.4.11;contract SimpleAuction &#123; // Parameters of the auction. Times are either // absolute unix timestamps (seconds since 1970-01-01) // or time periods in seconds. address public beneficiary; uint public auctionStart; uint public biddingTime; // Current state of the auction. address public highestBidder; uint public highestBid; // Allowed withdrawals of previous bids mapping(address =&gt; uint) pendingReturns; // Set to true at the end, disallows any change bool ended; // Events that will be fired on changes. event HighestBidIncreased(address bidder, uint amount); event AuctionEnded(address winner, uint amount); // The following is a so-called natspec comment, // recognizable by the three slashes. // It will be shown when the user is asked to // confirm a transaction. /// Create a simple auction with `_biddingTime` /// seconds bidding time on behalf of the /// beneficiary address `_beneficiary`. function SimpleAuction( uint _biddingTime, address _beneficiary ) &#123; beneficiary = _beneficiary; auctionStart = now; biddingTime = _biddingTime; &#125; /// Bid on the auction with the value sent /// together with this transaction. /// The value will only be refunded if the /// auction is not won. function bid() payable &#123; // No arguments are necessary, all // information is already part of // the transaction. The keyword payable // is required for the function to // be able to receive Ether. // Revert the call if the bidding // period is over. require(now &lt;= (auctionStart + biddingTime)); // If the bid is not higher, send the // money back. require(msg.value &gt; highestBid); if (highestBidder != 0) &#123; // Sending back the money by simply using // highestBidder.send(highestBid) is a security risk // because it could execute an untrusted contract. // It is always safer to let the recipients // withdraw their money themselves. pendingReturns[highestBidder] += highestBid; &#125; highestBidder = msg.sender; highestBid = msg.value; HighestBidIncreased(msg.sender, msg.value); &#125; /// Withdraw a bid that was overbid. function withdraw() returns (bool) &#123; uint amount = pendingReturns[msg.sender]; if (amount &gt; 0) &#123; // It is important to set this to zero because the recipient // can call this function again as part of the receiving call // before `send` returns. pendingReturns[msg.sender] = 0; if (!msg.sender.send(amount)) &#123; // No need to call throw here, just reset the amount owing pendingReturns[msg.sender] = amount; return false; &#125; &#125; return true; &#125; /// End the auction and send the highest bid /// to the beneficiary. function auctionEnd() &#123; // It is a good guideline to structure functions that interact // with other contracts (i.e. they call functions or send Ether) // into three phases: // 1. checking conditions // 2. performing actions (potentially changing conditions) // 3. interacting with other contracts // If these phases are mixed up, the other contract could call // back into the current contract and modify the state or cause // effects (ether payout) to be performed multiple times. // If functions called internally include interaction with external // contracts, they also have to be considered interaction with // external contracts. // 1. Conditions require(now &gt;= (auctionStart + biddingTime)); // auction did not yet end require(!ended); // this function has already been called // 2. Effects ended = true; AuctionEnded(highestBidder, highestBid); // 3. Interaction beneficiary.transfer(highestBid); &#125;&#125; Solidity Example 3：Blink Auction123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144pragma solidity ^0.4.11;contract BlindAuction &#123; struct Bid &#123; bytes32 blindedBid; uint deposit; &#125; address public beneficiary; uint public auctionStart; uint public biddingEnd; uint public revealEnd; bool public ended; mapping(address =&gt; Bid[]) public bids; address public highestBidder; uint public highestBid; // Allowed withdrawals of previous bids mapping(address =&gt; uint) pendingReturns; event AuctionEnded(address winner, uint highestBid); /// Modifiers are a convenient way to validate inputs to /// functions. `onlyBefore` is applied to `bid` below: /// The new function body is the modifier's body where /// `_` is replaced by the old function body. modifier onlyBefore(uint _time) &#123; require(now &lt; _time); _; &#125; modifier onlyAfter(uint _time) &#123; require(now &gt; _time); _; &#125; function BlindAuction( uint _biddingTime, uint _revealTime, address _beneficiary ) &#123; beneficiary = _beneficiary; auctionStart = now; biddingEnd = now + _biddingTime; revealEnd = biddingEnd + _revealTime; &#125; /// Place a blinded bid with `_blindedBid` = keccak256(value, /// fake, secret). /// The sent ether is only refunded if the bid is correctly /// revealed in the revealing phase. The bid is valid if the /// ether sent together with the bid is at least \"value\" and /// \"fake\" is not true. Setting \"fake\" to true and sending /// not the exact amount are ways to hide the real bid but /// still make the required deposit. The same address can /// place multiple bids. function bid(bytes32 _blindedBid) payable onlyBefore(biddingEnd) &#123; bids[msg.sender].push(Bid(&#123; blindedBid: _blindedBid, deposit: msg.value &#125;)); &#125; /// Reveal your blinded bids. You will get a refund for all /// correctly blinded invalid bids and for all bids except for /// the totally highest. function reveal( uint[] _values, bool[] _fake, bytes32[] _secret ) onlyAfter(biddingEnd) onlyBefore(revealEnd) &#123; uint length = bids[msg.sender].length; require(_values.length == length); require(_fake.length == length); require(_secret.length == length); uint refund; for (uint i = 0; i &lt; length; i++) &#123; var bid = bids[msg.sender][i]; var (value, fake, secret) = (_values[i], _fake[i], _secret[i]); if (bid.blindedBid != keccak256(value, fake, secret)) &#123; // Bid was not actually revealed. // Do not refund deposit. continue; &#125; refund += bid.deposit; if (!fake &amp;&amp; bid.deposit &gt;= value) &#123; if (placeBid(msg.sender, value)) refund -= value; &#125; // Make it impossible for the sender to re-claim // the same deposit. bid.blindedBid = 0; &#125; msg.sender.transfer(refund); &#125; // This is an \"internal\" function which means that it // can only be called from the contract itself (or from // derived contracts). function placeBid(address bidder, uint value) internal returns (bool success) &#123; if (value &lt;= highestBid) &#123; return false; &#125; if (highestBidder != 0) &#123; // Refund the previously highest bidder. pendingReturns[highestBidder] += highestBid; &#125; highestBid = value; highestBidder = bidder; return true; &#125; /// Withdraw a bid that was overbid. function withdraw() &#123; uint amount = pendingReturns[msg.sender]; if (amount &gt; 0) &#123; // It is important to set this to zero because the recipient // can call this function again as part of the receiving call // before `send` returns (see the remark above about // conditions -&gt; effects -&gt; interaction). pendingReturns[msg.sender] = 0; msg.sender.transfer(amount); &#125; &#125; /// End the auction and send the highest bid /// to the beneficiary. function auctionEnd() onlyAfter(revealEnd) &#123; require(!ended); AuctionEnded(highestBidder, highestBid); ended = true; // We send all the money we have, because some // of the refunds might have failed. beneficiary.transfer(this.balance); &#125;&#125; Solidity Example 4： Remote Purchase123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384pragma solidity ^0.4.11;contract Purchase &#123; uint public value; address public seller; address public buyer; enum State &#123; Created, Locked, Inactive &#125; State public state; function Purchase() payable &#123; seller = msg.sender; value = msg.value / 2; require((2 * value) == msg.value); &#125; modifier condition(bool _condition) &#123; require(_condition); _; &#125; modifier onlyBuyer() &#123; require(msg.sender == buyer); _; &#125; modifier onlySeller() &#123; require(msg.sender == seller); _; &#125; modifier inState(State _state) &#123; require(state == _state); _; &#125; event Aborted(); event PurchaseConfirmed(); event ItemReceived(); /// Abort the purchase and reclaim the ether. /// Can only be called by the seller before /// the contract is locked. function abort() onlySeller inState(State.Created) &#123; Aborted(); state = State.Inactive; seller.transfer(this.balance); &#125; /// Confirm the purchase as buyer. /// Transaction has to include `2 * value` ether. /// The ether will be locked until confirmReceived /// is called. function confirmPurchase() inState(State.Created) condition(msg.value == (2 * value)) payable &#123; PurchaseConfirmed(); buyer = msg.sender; state = State.Locked; &#125; /// Confirm that you (the buyer) received the item. /// This will release the locked ether. function confirmReceived() onlyBuyer inState(State.Locked) &#123; ItemReceived(); // It is important to change the state first because // otherwise, the contracts called using `send` below // can call in again here. state = State.Inactive; // NOTE: This actually allows both the buyer and the seller to // block the refund - the withdraw pattern should be used. buyer.transfer(value); seller.transfer(this.balance); &#125;&#125; Solidity 語法AddressHolds a 20 byte value (size of an Ethereum address) Members of Addressesaddress包含著有以下的properties： balance：地址的餘額 transfer：轉錢到該地址 若有錯誤會發送exception 1234address x = 0x123;address myAddress = this;if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10); // 送給x這個地址 10塊ether send ：也是轉錢到該地址 若有錯誤只會return false，使用要比較小心 call ：傳送參數（.value()）或函式回傳值給合約， delegatecall 1234address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;nameReg.call(&quot;register&quot;, &quot;MyName&quot;);nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a);nameReg.call.value(10); Enums：類似實作interfaceEnums needs at least one member. 123456789101112131415161718192021222324pragma solidity ^0.4.0;contract test &#123; enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125; ActionChoices choice; ActionChoices constant defaultChoice = ActionChoices.GoStraight; function setGoStraight() &#123; choice = ActionChoices.GoStraight; &#125; // Since enum types are not part of the ABI, the signature of \"getChoice\" // will automatically be changed to \"getChoice() returns (uint8)\" // for all matters external to Solidity. The integer type used is just // large enough to hold all enum values, i.e. if you have more values, // `uint16` will be used and so on. function getChoice() returns (ActionChoices) &#123; return choice; &#125; function getDefaultChoice() returns (uint) &#123; return uint(defaultChoice); &#125;&#125; Functional的種類以及參數(constnat,payble) Internal function： can only be called inside the current contract. External function： consist of an address and a function signature and they can be passed via and returned from external function calls. function宣告的格式：123456789function (&lt;parameter types&gt;) &#123;internal|external&#125; [constant] [payable] [returns (&lt;return types&gt;)]parameter types：參數的形式constant：標註該function為read-only，不會改變contract的state.payable： 設定會需要收ether的函式都要加一個payable屬性，如果沒加而有人呼叫該函式順便帶ether的話就會造成errorex:function (address chairman) &#123;&#125; constant payble returns (uint) &#123;&#125;; 兩種方法存取該function: f： will result in an internal function, this.f： an external function. Internal Example: 類似OOD的Protected、不能被其他合約呼叫12345678910111213141516171819202122232425262728293031323334353637383940414243444546pragma solidity ^0.4.5;library ArrayUtils &#123; // internal functions can be used in internal library functions because // they will be part of the same code context function map(uint[] memory self, function (uint) returns (uint) f) internal returns (uint[] memory r) &#123; r = new uint[](self.length); for (uint i = 0; i &lt; self.length; i++) &#123; r[i] = f(self[i]); &#125; &#125; function reduce( uint[] memory self, function (uint, uint) returns (uint) f ) internal returns (uint r) &#123; r = self[0]; for (uint i = 1; i &lt; self.length; i++) &#123; r = f(r, self[i]); &#125; &#125; function range(uint length) internal returns (uint[] memory r) &#123; r = new uint[](length); for (uint i = 0; i &lt; r.length; i++) &#123; r[i] = i; &#125; &#125;&#125;contract Pyramid &#123; using ArrayUtils for *; function pyramid(uint l) returns (uint) &#123; return ArrayUtils.range(l).map(square).reduce(sum); &#125; function square(uint x) internal returns (uint) &#123; return x * x; &#125; function sum(uint x, uint y) internal returns (uint) &#123; return x + y; &#125;&#125; External： 其他合約可以呼叫該合約的function1234567891011121314151617181920212223242526272829pragma solidity ^0.4.11;contract Oracle &#123; struct Request &#123; bytes data; function(bytes memory) external callback; &#125; Request[] requests; event NewRequest(uint); function query(bytes data, function(bytes memory) external callback) &#123; requests.push(Request(data, callback)); NewRequest(requests.length - 1); &#125; function reply(uint requestID, bytes response) &#123; // Here goes the check that the reply comes from a trusted source requests[requestID].callback(response); &#125;&#125;contract OracleUser &#123; Oracle constant oracle = Oracle(0x1234567); // known contract function buySomething() &#123; oracle.query(\"USD\", this.oracleResponse); &#125; function oracleResponse(bytes response) &#123; require(msg.sender == address(oracle)); // Use the data &#125;&#125; 宣告Arrayex:1uint[] memory a = new uint[](7); 宣告 Struct： 類似宣告一個物件模板 1234struct Funder &#123; address addr; uint amount;&#125; Mappings宣告成： mapping(_KeyType =&gt; _ValueType) 的形式，可以看成是hash table的形式， 123456789101112131415161718pragma solidity ^0.4.0;contract MappingExample &#123; mapping(address =&gt; uint) public balances; //設定balances的index為addreess形態的，映射出後會得到uint型態的回傳值。 function update(uint newBalance) &#123; balances[msg.sender] = newBalance; &#125;&#125;contract MappingUser &#123; function f() returns (uint) &#123; MappingExample m = new MappingExample(); m.update(100); return m.balances(this); &#125;&#125; 其他 Operators Involving LValues（可被assign的value)delete a： 把a初始化成 0（也可以用在array 都設成0, struct 都設成初始值) Ether單位Ether Uint：1 ether =1000000000000000000 wei, (10^18)1000 finney, (10^3)1000000 szabo (10^6) 全域可用變數及函式Special Variables and Functions suicide.(A合約): 將目前合約的所有ether都轉入到指定的Ａ合約(contract) delete：回收宣告的成員，並且返回一些gas當作回收的獎勵。 回收各型態的參考資料：http://me.tryblockchain.org/solidity-delete.html Block and Transaction Properties block.blockhash(uint blockNumber) returns (bytes32): hash of the given block - only works for 256 most recent blocks excluding current block.coinbase (address): current block miner’s address block.difficulty (uint): current block difficulty block.gaslimit (uint): current block gaslimit block.number (uint): current block number block.timestamp (uint): current block timestamp as seconds since unix epoch msg.data (bytes): complete calldata msg.gas (uint): remaining gas msg.sender (address): sender of the message (current call) msg.sig (bytes4): first four bytes of the calldata (i.e. function identifier) msg.value (uint): number of wei sent with the message now (uint): current block timestamp (alias for block.timestamp) tx.gasprice (uint): gas price of the transaction tx.origin (address): sender of the transaction (full call chain)(不建議用) Error Handling assert(bool condition):throws if the condition is not met - to be used for internal errors. require(bool condition):throws if the condition is not met - to be used for errors in inputs or external components. revert():abort execution and revert state changes Mathematical and Cryptographic Functions addmod(uint x, uint y, uint k) returns (uint):compute (x + y) % k where the addition is performed with arbitrary precision and does not wrap around at 2**256. mulmod(uint x, uint y, uint k) returns (uint):compute (x * y) % k where the multiplication is performed with arbitrary precision and does not wrap around at 2**256. keccak256(…) returns (bytes32):compute the Ethereum-SHA-3 (Keccak-256) hash of the (tightly packed) arguments sha256(…) returns (bytes32):compute the SHA-256 hash of the (tightly packed) argumentssha3(…) returns (bytes32):alias to keccak256 ripemd160(…) returns (bytes20):compute RIPEMD-160 hash of the (tightly packed) arguments ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):recover the address associated with the public key from elliptic curve signature or return zero on error (example usage) Solidity的表達和控制的結構（Expressions and Control Structures）Input Parameters and Output Parameters 接收參數和回傳的形式12345678910pragma solidity ^0.4.0;contract Simple &#123; // 接收 uint _a , uint _b變數 // 回傳uint -_sum uint o_product function arithmetics(uint _a, uint _b) returns (uint o_sum, uint o_product) &#123; o_sum = _a + _b; o_product = _a * _b; &#125;&#125; External Function Calls如果要得知呼叫某合約的function會有多少Wei和花費多少gas，可用.value() .gas() 範例中的function info() 如果沒有加上 payable這個keyword，就無法使用 .value() 123456789101112pragma solidity ^0.4.0;contract InfoFeed &#123; // function info() payable returns (uint ret) &#123; return 42; &#125;&#125;contract Consumer &#123; InfoFeed feed; function setFeed(address addr) &#123; feed = InfoFeed(addr); &#125; function callFeed() &#123; feed.info.value(10).gas(800)(); &#125;&#125; Creating Contracts via new123456789101112131415161718192021pragma solidity ^0.4.0;contract D &#123; uint x; function D(uint a) payable &#123; x = a; &#125;&#125;contract C &#123; D d = new D(4); // will be executed as part of C's constructor function createD(uint arg) &#123; D newD = new D(arg); &#125; function createAndEndowD(uint arg, uint amount) &#123; // Send ether along with the creation D newD = (new D).value(amount)(arg); &#125;&#125; Error handling: Assert, Require, Revertand Exceptions require can be used to easily check conditions on inputs. assert can be used for internal error checking. 1234567891011121314pragma solidity ^0.4.0;contract Sharer &#123; function sendHalf(address addr) payable returns (uint balance) &#123; require(msg.value % 2 == 0); // Only allow even numbers uint balanceBeforeTransfer = this.balance; addr.transfer(msg.value / 2); // Since transfer throws an exception on failure and // cannot call back here, there should be no way for us to // still have half of the money. assert(this.balance == balanceBeforeTransfer - msg.value / 2); return this.balance; &#125;&#125; assert 發生的狀況： If you access an array at a too large or negative index (i.e. x[i] where i &gt;= x.length or i &lt; 0). If you access a fixed-length bytesN at a too large or negative index. If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0). If you shift by a negative amount. If you convert a value too big or negative into an enum type. If you call a zero-initialized variable of internal function type. If you call assert with an argument that evaluates to false. require 發生的狀況： Calling throw. Calling require with an argument that evaluates to false. If you call a function via a message call but it does not finish properly (i.e. it runs out of gas, has no matching function, or throws an exception itself), except when a low level operation call, send, delegatecall or callcode is used. The low level operations never throw exceptions but indicate failures by returning false. If you create a contract using the new keyword but the contract creation does not finish properly (see above for the definition of “not finish properly”). If you perform an external function call targeting a contract that contains no code. If your contract receives Ether via a public function without payable modifier (including the constructor and the fallback function). If your contract receives Ether via a public getter function. If a .transfer() fails. Solidity Contract(即Class)創建contract的時候，constructor只會被呼叫一次 合約的Visibility and GettersVisibility： external:External functions are part of the contract interface, which means they can be called from other contracts and via transactions. An external function f cannot be called internally (i.e. f() does not work, but this.f() works). External functions are sometimes more efficient when they receive large arrays of data. public:Public functions are part of the contract interface and can be either called internally or via messages. For public state variables, an automatic getter function (see below) is generated. internal:Those functions and state variables can only be accessed internally (i.e. from within the current contract or contracts deriving from it), without using this. private:Private functions and state variables are only visible for the contract they are defined in and not in derived contracts. Getter Functions123456789pragma solidity ^0.4.0;contract C &#123; uint public data; function x() &#123; data = 3; // internal access 當成state變數 uint val = this.data(); // external access 當成是function &#125;&#125; Function Modifier (類似：函式插槽)Modifier可用用來擴充其他function的內容，需要被inherit才能使用。通常modifier用來設定一些條件，幫助函式被執行時能夠先滿足該條件再被執行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172pragma solidity ^0.4.11;contract owned &#123; function owned() &#123; owner = msg.sender; &#125; address owner; // 該owned合約只有宣告一個modifier onlyOwner，並且沒有使用它 // 該modifier只會被其他有繼承owned contract的合約所使用 // // \"_;\" 要繼承onlyOwner 函式的內容 modifier onlyOwner &#123; require(msg.sender == owner); _; &#125;&#125;contract mortal is owned &#123; // 繼承 owned合約 // close函式 使用modifier \"onlyOwner\" // 且close的內容會插入在 modifier中的 \"_;\"中 // 可以把modifier想像成 slot（插槽) function close() onlyOwner &#123; selfdestruct(owner); &#125;&#125;contract priced &#123; // Modifier 也可以接收參數 modifier costs(uint price) &#123; // 若滿足msg.value &gt;= price 那就執行 使用該modifier函式的內容 if (msg.value &gt;= price) &#123; _; &#125; &#125;&#125;contract Register is priced, owned &#123; mapping (address =&gt; bool) registeredAddresses; uint price; function Register(uint initialPrice) &#123; price = initialPrice; &#125; // 需要提供 payable，register才會接受ether // 使用 costs 的modifier . function register() payable costs(price) &#123; registeredAddresses[msg.sender] = true; &#125; function changePrice(uint _price) onlyOwner &#123; price = _price; &#125;&#125;contract Mutex &#123; bool locked; modifier noReentrancy() &#123; require(!locked); locked = true; _; locked = false; &#125; // noReentrancy 被一個mutex所保護，必須要判斷locked是否是false才能執行 noReentrancy才能執行 // reentrant calls from within // msg.sender.call cannot call f again.因爲lock住了 // 使用 noReentrancy(modifier), function f() noReentrancy returns (uint) &#123; require(msg.sender.call()); return 7; &#125;&#125; Constant State Variables目前僅支援 uint, string使用 宣告一次後就不能再被改變 Constant Functions不會改變contract state的值 1234567pragma solidity ^0.4.0;contract C &#123; function f(uint a, uint b) constant returns (uint) &#123; return a * (b + 42); &#125;&#125; Fallback Function沒有名稱的function,並且沒有接收參數以及不會傳任何值。當呼叫某合約的方法時，沒有辦法成功 如果有合約直接收到ether的話（亦即不是透過send() or transfer() 那就得定義一個fallback function，不然會throw an exception. 1234567891011121314151617181920212223242526pragma solidity ^0.4.0;contract Test &#123; function() &#123; x = 1; &#125; uint x;&#125;// This contract keeps all Ether sent to it with no way// to get it back.contract Sink &#123; function() payable &#123; &#125;&#125;contract Caller &#123; function callTest(Test test) &#123; test.call(0xabcdef01); // hash: 0xabcdef01 不存在 // 故 test.x的結果會變成 test.x = 1 // The following will not compile, but even // if someone sends ether to that contract, // the transaction will fail and reject the // Ether. //test.send(2 ether); &#125;&#125; EventsEvent所寫入的資料會被記錄在一個Receipt（transaction logs)資料裡，並等待被打包進區塊鏈。 白話一點就是：通知全網有一件事情發生。 12345678910111213141516pragma solidity ^0.4.0;contract ClientReceipt &#123; event Deposit( address indexed _from, bytes32 indexed _id, uint _value ); function deposit(bytes32 _id) payable &#123; // Any call to this function (even deeply nested) can // be detected from the JavaScript API by filtering // for `Deposit` to be called. Deposit(msg.sender, _id, msg.value); &#125;&#125; 在javascript API的使用方式如下：1234567891011121314151617181920var abi = /* abi as generated by the compiler */;var ClientReceipt = web3.eth.contract(abi);var clientReceipt = ClientReceipt.at(0x123 /* address */);var event = clientReceipt.Deposit();// watch for changesevent.watch(function(error, result)&#123; // result will contain various information // including the argumets given to the Deposit // call. if (!error) console.log(result);&#125;);// Or pass a callback to start watching immediatelyvar event = clientReceipt.Deposit(function(error, result) &#123; if (!error) console.log(result);&#125;); Inheritance使用 is 來繼承其他contract. 提供多重繼承同時也包含多型當一個合約R繼承其他A,B,C的合約時，只有R的合約被打包進去blockchain，其他ABC不會。（因為是將A,B,C的內容複製到R的合約內) 像是Python的繼承特性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556pragma solidity ^0.4.0;contract owned &#123; function owned() &#123; owner = msg.sender; &#125; address owner;&#125;// 使用 \"is\" 來繼承，可以存取繼承合約的 non-private members (包含 internal function and state variables)，無法透過 this 來做externally access.contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125;&#125;// 當成是 interface，等待被繼承實作contract Config &#123; function lookup(uint id) returns (address adr);&#125;contract NameReg &#123; function register(bytes32 name); function unregister();&#125;// 可以實現多重繼承// 注意的是\"owned\" 一樣也被mortal繼承，故只有一個\"owned\"的instance (和C++的vritual inheritance一樣)contract named is owned, mortal &#123; function named(bytes32 name) &#123; Config config = Config(0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970); NameReg(config.lookup(1)).register(name); &#125;// 可以override 繼承的function.注意要與原本的型態要一致 function kill() &#123; if (msg.sender == owner) &#123; Config config = Config(0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970); NameReg(config.lookup(1)).unregister(); // 依然可以呼叫繼承合約內的函式 mortal.kill(); &#125; &#125;&#125;// 如果繼承的contract中有的人的contractor需要parameter,// 那就得在 is 後面的地方輸入參數，// 如下 \"named(\"GoldFeed\");contract PriceFeed is owned, mortal, named(\"GoldFeed\") &#123; function updateInfo(uint newInfo) &#123; if (msg.sender == owner) info = newInfo; &#125; function get() constant returns(uint r) &#123; return info; &#125; uint info;&#125; 多重繼承要注意的點：12345678910111213141516171819202122232425pragma solidity ^0.4.0;contract owned &#123; function owned() &#123; owner = msg.sender; &#125; address owner;&#125;contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125;&#125;contract Base1 is mortal &#123; function kill() &#123; /* do cleanup 1 */ mortal.kill(); &#125;&#125;contract Base2 is mortal &#123; function kill() &#123; /* do cleanup 2 */ mortal.kill(); &#125;&#125;contract Final is Base1, Base2 &#123;&#125; 呼叫 Final.kill 僅會呼叫到 Base2的 kill function.而忽略掉 Base1 的. Abstract Contracts不實作合約內的function內容，被繼承時在實作。但可以定義變數，建構子等等。 例子：12345pragma solidity ^0.4.0;contract Feline &#123; function utterance() returns (bytes32);&#125; Interfaces和Abstract很像，不過不能有任何的function被實作以下為限制條件 Cannot inherit other contracts or interfaces. Cannot define constructor. Cannot define variables. Cannot define structs. Cannot define enums. 12345pragma solidity ^0.4.11;interface Token &#123; function transfer(address recipient, uint amount);&#125; Libraries和contract(class)很像，不過僅會在特地的address部署一次而已。 因為佈一個contract需要gas，不過如果要重複使用Set的話，又不想重複宣告contract，那就可以用Libraries來實作出一個Set，並且佈出去就會產生一個地址 (linker)，其他合約就可以透過linker來使用Set. 直接看例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950pragma solidity ^0.4.11;library Set &#123; // We define a new struct datatype that will be used to // hold its data in the calling contract. struct Data &#123; mapping(uint =&gt; bool) flags; &#125; // Note that the first parameter is of type \"storage // reference\" and thus only its storage address and not // its contents is passed as part of the call. This is a // special feature of library functions. It is idiomatic // to call the first parameter 'self', if the function can // be seen as a method of that object. function insert(Data storage self, uint value) returns (bool) &#123; if (self.flags[value]) return false; // already there self.flags[value] = true; return true; &#125; function remove(Data storage self, uint value) returns (bool) &#123; if (!self.flags[value]) return false; // not there self.flags[value] = false; return true; &#125; function contains(Data storage self, uint value) returns (bool) &#123; return self.flags[value]; &#125;&#125;contract C &#123; Set.Data knownValues; function register(uint value) &#123; // The library functions can be called without a // specific instance of the library, since the // \"instance\" will be the current contract. require(Set.insert(knownValues, value)); &#125; // In this contract, we can also directly access knownValues.flags, if we want.&#125; Style Guide （套用eslint for solidity) Indentation: 4 spaces (avoid using tabs.) Order of Functions: (function的寫法的優先順序) constructor fallback function (if exists) external public internal private Web3.js 學習目標瞭解：1.如何把key pair抓出來2.如何簽驗章3.如何進行加解密4.如何發events 環簽章 同態加密Confidential transaction（https://www.elementsproject.org/elements/confidential-transactions/ ZKsnark(包含零知識證明)參考：（應用例子：不公開UTXO，也能讓礦工驗證，不過礦工不能解密，不然會失去confidential的特性，不讓receiver知道UTXO）https://z.cash/technology/zksnarks.html","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://a10000005588.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/tags/Solidity/"}]},{"title":"使用truffle來練習撰寫認養寵物的智能合約","slug":"truffle-petshop","date":"2017-09-07T14:02:57.000Z","updated":"2020-07-26T09:17:54.837Z","comments":true,"path":"2017/09/07/truffle-petshop/","link":"","permalink":"http://a10000005588.github.io/2017/09/07/truffle-petshop/","excerpt":"本篇是翻譯自Truffle官方所釋出的Dapp教學文檔Pet-Shophttp://truffleframework.com/tutorials/pet-shop 執行環境開發前準備首先要安裝testrpc、truffle :12345npm install -g ethereumjs-testrpc// 安裝測試用ethereum私有鍊npm install -g truffle// 開發智能合約的一套框架","text":"本篇是翻譯自Truffle官方所釋出的Dapp教學文檔Pet-Shophttp://truffleframework.com/tutorials/pet-shop 執行環境開發前準備首先要安裝testrpc、truffle :12345npm install -g ethereumjs-testrpc// 安裝測試用ethereum私有鍊npm install -g truffle// 開發智能合約的一套框架 安裝truffle上已經預先包好的練習專案(Truffle box: ETHEREUM PET SHOP)：12345678mkdir pet-shop-tutorial // 創建一個目錄cd pet-shop-tutorial // 切換到該目錄truffle unbox pet-shop// 安裝truffle打包好的pet-shop練習專案檔 目錄架構 /contracts: 存放合約的地方，檔名為.sol，而Migrate.sol是負責紀錄其他合約如何deploy到區塊鏈，不能刪除！ /migrations: 負責將合約掛到區塊鏈上，並且追蹤合約的更動狀況。 /test: 包含Javascript and solidity檔案，負責測試合約內容。 truffle.js : truffle的設定檔 合約內容在/contract 建立 Adoption.sol宣告一個contract:12345678910111213141516171819202122232425262728pragma solidity ^0.4.4;// 告訴compiler 現在要用哪個版本編譯contract Adoption &#123; //宣告一個 contract的class 叫 Adoption // 存放領養飼主的地址（預設是有16隻狗等待被認養） address[16] public adopters; // 有人要認養某隻寵物(petId)，判斷是否可以認養， // 回傳該認養的寵物ID以證明該寵物成功被某用戶認養 function adopt(uint petId) public returns (uint) &#123; require(petId &gt;= 0 &amp;&amp; petId &lt;= 15); // 判斷petId，若不符合結束該函式，不再往下執行 adopters[petId] = msg.sender; // 透過msg.sender取得呼叫該函式的使用者 // 也就是認養該寵物的用戶ID return petId; &#125; // 回傳所有的認養者，回傳值的型態為address[16] function getAdopters() public returns (address[16]) &#123; return adopters; &#125; &#125; 編譯(Compiling)和部署(Migrating)合約寫好合約後，需要將.sol檔進行編譯成.bytecode，才能在EVM (ethereum virtual machine上執行). 然後在terminal上執行 testrpc 啟動 啟動後會出現： 數組帳戶的address以及私鑰 HD wallet的資訊（稍後會提到metatask，會使用到Mnemonic section的資訊) Mnemonic為數個變數的資訊，如下Mnemonic: spider level team helmet shaft clarify abuse recipe stem ankle angry fee 執行 truffle compile 會看到 .sol檔被編譯 Migrationmigrate.sol描述如何將合約的內容部署到鏈上，並且處理合約上state的更動。 在 /migration 檔案內： 1_initial_migration.js： 123456// 引入編譯合約的內容var Migrations = artifacts.require(\"./Migrations.sol\");module.exports = function(deployer) &#123; deployer.deploy(Migrations);&#125;; 透過該檔案可以追蹤後續contract的變化，已部署過的合約且沒有被修改就不用再被部署（不然又會消耗gas). 2_deploy_contracts.js注意，這邊的命名開頭要編號，因為truffle進行migrate時會依據該編號而進行。 12345var Adoption = artifacts.require(\"./Adoption.sol\");module.exports = function(deployer) &#123; deployer.deploy(Adoption);&#125;; 在terminal執行 truffle migrate 會看到如下結果123456789101112Using network &apos;development&apos;.Running migration: 1_initial_migration.js Deploying Migrations... Migrations: 0x75175eb116b36ff5fef15ebd15cbab01b50b50d1Saving successful migration to network...Saving artifacts...Running migration: 2_deploy_contracts.js Deploying Adoption... Adoption: 0xb9f485451a945e65e48d9dd7fc5d759af0a89e21Saving successful migration to network...Saving artifacts... 若看到上述表面表示我們寫的第一隻 Adoption.sol的合約已經成功被部署到鏈上！ 為Smart Contract寫測試我們可以用javascript或solidity寫測試，不過本範例用solidity來寫。 在 /test 目錄下創建 TestAdoption.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748pragma solidity ^0.4.11;// 引用truffle內建的檔案 // Assert.sol用來做Unit test (判斷function input ?= output)import \"truffle/Assert.sol\";// 當測試執行，truffle會在testrpc中測試該合約，// 該DeployedAddresses用來取得被部署合約的addressimport \"truffle/DeployedAddresses.sol\";// 要被測試的合約import \"../contracts/Adoption.sol\";contract TestAdoption &#123; Adoption adoption = Adoption(DeployedAddresses.Adoption()); // Testing The adopt() Function function testUserCanAdoptPet() &#123; // 呼叫Adoption中的adopt方法 uint returnedId = adoption.adopt(8); uint expected = 8; // 判斷returnID 是否等於 expected的值 Assert.equal(returnedId, expected, \"Adoption of pet ID 8 should be recorded.\"); &#125; // Testing Retrieval of a Single Pet's Owner function testGetAdopterAddressByPetId() &#123; // 透過this取得目前合約的地址 address expected = this; address adopter = adoption.adopters(8); Assert.equal(adopter, expected, \"Owner of pet ID 8 should be recorded.\"); &#125; // Testing Retrieval of All Pet Owners function testGetAdopterAddressByPetIdInArray() &#123; address expected = this; address[16] memory adopters = adoption.getAdopters(); Assert.equal(adopters[8], expected, \"Owner of pet ID 8 should be recorded.\"); &#125; &#125; 執行 truffle test 若看到以下畫面表示test通過123456789101112131415Using network &apos;development&apos;.Compiling ./contracts/Adoption.sol...Compiling ./test/TestAdoption.sol...Compiling truffle/Assert.sol...Compiling truffle/DeployedAddresses.sol... TestAdoption ✓ testUserCanAdoptPet (91ms) ✓ testGetAdopterAddressByPetId (70ms) ✓ testGetAdopterAddressByPetIdInArray (89ms) 3 passing (670ms) 使用UI和Smart Contract互動當解開truffle box的pet-shop，可以看到在 /src目錄底下會有已經預設好的UI檔供練習用。 使用Web3.js初始化前端環境Web3.js為用來和ethereum溝通的javascript library.（而練習專案前端是使用jQuery) 在 /src/js/app.js檔案的內容改為以下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131App = &#123; web3Provider: null, contracts: &#123;&#125;, init: function() &#123; // 載入寵物的資料 $.getJSON('../pets.json', function(data) &#123; var petsRow = $('#petsRow'); var petTemplate = $('#petTemplate'); for (i = 0; i &lt; data.length; i ++) &#123; petTemplate.find('.panel-title').text(data[i].name); petTemplate.find('img').attr('src', data[i].picture); petTemplate.find('.pet-breed').text(data[i].breed); petTemplate.find('.pet-age').text(data[i].age); petTemplate.find('.pet-location').text(data[i].location); petTemplate.find('.btn-adopt').attr('data-id', data[i].id); petsRow.append(petTemplate.html()); &#125; &#125;); return App.initWeb3(); &#125;, initWeb3: function() &#123; // 初始化web3.js並且設置provider連接testrpc // 如果偵測到有metamask注入在瀏覽器的web3 instance if (typeof web3 !== 'undefined') &#123; App.web3Provider = web3.currentProvider; // 將currentProvider = metamask // web3 = new Web3(web3.currentProvider); &#125; else &#123; // 若沒有metamask or mist等等之類的， // 那就用自己開啟testrpc當成是provider App.web3Provider = new web3.providers.HttpProvider('http://localhost:8545'); web3 = new Web3(App.web3Provider); &#125; return App.initContract(); &#125;, initContract: function() &#123; $.getJSON('Adoption.json', function(data) &#123; // 取得contract的artifact(Adoption.json) // 例如contract address, ABI (Application Binary Interface)： // 即如何使用contract的變數、函式等等 var AdoptionArtifact = data; // truffle提供`truffle-contract`來幫助我們監聽已經被migrate的contract // 並把contract的artifact傳給truffle-contract'，好讓我們可以跟合約溝通 App.contracts.Adoption = TruffleContract(AdoptionArtifact); // 為contract設置Provider(我們是用metamask) App.contracts.Adoption.setProvider(App.web3Provider); // 從Adpotion.json的合約資料中，判斷寵物的是否已被認養並做標示 return App.markAdopted(); &#125;); return App.bindEvents(); &#125;, bindEvents: function() &#123; $(document).on('click', '.btn-adopt', App.handleAdopt); &#125;, handleAdopt: function() &#123; event.preventDefault(); var petId = parseInt($(event.target).data('id')); var adoptionInstance; // 使用web3來取得user's accounts // 這時metamask會跳出交易訊息出來 web3.eth.getAccounts(function(error, accounts) &#123; if (error) &#123; console.log(error); &#125; // 選擇第一個accounts作為我們的用戶 var account = accounts[0]; App.contracts.Adoption.deployed().then(function(instance) &#123; adoptionInstance = instance; // 在這裡要執行會花費gas的transaction // 取得認養用戶的account，以及點選欲認養的petId return adoptionInstance.adopt(petId, &#123;from: account&#125;); &#125;).then(function(result) &#123; // 若回傳結果正常執行markAdopted刷新UI上寵物認養中的狀態 return App.markAdopted(); &#125;).catch(function(err) &#123; console.log(err.message); &#125;); &#125;); &#125;, markAdopted: function(adopters, account) &#123; var adoptionInstance; App.contracts.Adoption.deployed().then(function(instance) &#123; // 取得Adpotion合約的內容 adoptionInstance = instance; // 呼叫合約中的getAdopters方法 // 利用`call`可以直接讀取Blockchain上的資料，不用花費ether(gas) return adoptionInstance.getAdopters.call(); &#125;).then(function(adopters) &#123; for (i = 0; i &lt; adopters.length; i++) &#123; if (adopters[i] !== '0x0000000000000000000000000000000000000000') &#123; $('.panel-pet').eq(i).find('button').text('Pending...').attr('disabled', true); &#125; &#125; &#125;).catch(function(err) &#123; console.log(err.message); &#125;); &#125;&#125;;$(function() &#123; $(window).load(function() &#123; App.init(); &#125;);&#125;); 在Chrome上和Dapp互動安裝 metamask的擴充套件 長這樣： 由於我們要測試自己的Dapp，點選該圖左上角切換到自己開啟testrpc:8545的私有鏈 因為是初次登入，點選I forgot my password 將一開始開啟testrpc 產生的 Mnemonic（數組變數名稱）貼到wallet seed.Mnemonic:1spider level team helmet shaft clarify abuse recipe stem ankle angry fee (Warning：你的testrpc產生的Mnemonic變數組會跟上面的不一樣) 設置自己的新密碼，確認後點選OK 進入後就會看到自己的第一筆account資訊了 若有顯示帳戶表示成功與testrpc連接(原本testrpc是預設100 ether，顯示出來不是100 ether的原因是因為部署合約到自己的private blockchain也需要費用) 安裝和設置lite-server啟動Dapplite-server已經包含在pet-shop的box內 在 bs-config.json檔案中 12345&#123; &quot;server&quot;: &#123; &quot;baseDir&quot;: [&quot;./src&quot;, &quot;./build/contracts&quot;] &#125;&#125; 該設置告訴server要執行的基底目錄在哪。 ./src：前端的內容./build/contracts：放置合約的內容 在script檔中 1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;lite-server&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;&#125;, 設置 &quot;dev&quot; : lite-server&quot;方便我們可以直接在terminal下執行 npm run dev 來運行Dapp 運行成功後的樣子 若要進行認養：點選 Adopt按鈕 點選Sumit後即完成認養的動作，並且把該認養的資訊透過合約掛到testrpc的鏈上，並在該寵物上狀態改成 Pending... （已認養） 延伸 將前端改成用Vue.js可以考慮用以下package： Vue-Truffle-Webpackhttps://github.com/wilfreddenton/vue-truffle-webpack 顯示該隻狗被哪位用戶認養走 改成要付足夠的錢才能認養該隻狗","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/tags/Solidity/"},{"name":"Truffle","slug":"Truffle","permalink":"http://a10000005588.github.io/tags/Truffle/"}]},{"title":"利用Hexo來記錄自己的學習並使用Material-flow主題","slug":"How_To_Use_Hexo","date":"2017-09-05T14:58:47.000Z","updated":"2020-07-26T09:17:23.972Z","comments":true,"path":"2017/09/05/How_To_Use_Hexo/","link":"","permalink":"http://a10000005588.github.io/2017/09/05/How_To_Use_Hexo/","excerpt":"如果要打造自己風格的Blog，那就不能錯過HexoHexo是一套開源的架個人部落格的框架，","text":"如果要打造自己風格的Blog，那就不能錯過HexoHexo是一套開源的架個人部落格的框架， 其優點如下： 文章以markdown格式為主。 並且能一鍵部署在Github，公開給大家看。 有很多第三方的template theme來裝飾自己的Blog 我目前這個Blog的主題是使用NextT囉 以下會詳細介紹怎麼用Hexo快速架站 Hexo架設流程安裝Hexo1npm install hexo-cli -g 初始化一個Hexo專案，並且運行之1234567hexo init blogcd blognpm installhexo server// 也可以用 hexo s -p 8080 // 指定欲開啟的port number為多少 可以看到新建立好的Blog長這樣 (X) 新增一篇文章1hexo new [layout] &lt;title&gt; [layout]有以下幾種(default為 post)： post：就po一篇文章，文章都放置在 source/_posts中 page：建立獨立的頁面，例如建立about頁面 draft：發佈一篇草稿，如果要公開則下 hexo publish [layout] &lt;title&gt;，將草稿移動到 source/_posts 佈署到自己的github安裝 hexo-deployer-git1npm install hexo-deployer-git --save 修改 _config.yml12345deploy: type: git repo: &lt;repository url&gt; // 儲存庫（Repository）網址 branch: [branch] // 分支名稱 message: [message] // 自定提交訊息 新增好文章後需要產生部署用靜態檔案執行：hexo generate 會產生public目錄 執行 hexo deploy 即可一鍵部署public目錄內容到github.io網站上 注意：github上的repo命名要與你的帳號一樣，否則還得處理路徑問題 若要直接新增好文章後部署：hexo generate --deploy 之後若要重新執行hexo deploy，請先用 hexo clean清除靜態頁面，然後在執行deploy. 使用Material-flow 來改造自己的Blog詳情請看Material-flow 的Github上文件 https://github.com/stkevintan/hexo-theme-material-flow 修改自己的Description在大頭貼下方的描述，若要修改的話得到： ./theme/material-flow/layout/_widget/about.ejs中修改！ 延伸若要對自己Blog做擴充都可以再參考Hexo以及NextT的官方文檔 Hexo官方連結：https://hexo.io/zh-tw/ 如果對其他theme有興趣也可以參考這網站 Hexo官方主題：https://hexo.io/zh-tw/docs/writing.htmlHexo主題排名：https://www.zhihu.com/question/24422335","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://a10000005588.github.io/categories/Hexo/"}],"tags":[{"name":"Frontend","slug":"Frontend","permalink":"http://a10000005588.github.io/tags/Frontend/"}]}]}
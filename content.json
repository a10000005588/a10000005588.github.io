{"meta":{"title":"William's 隨手札記","subtitle":"Blog of William","description":"Just record it.","author":"William L.K.","url":"http://a10000005588.github.io"},"pages":[{"title":"Stay Hungry, Stay Foolish.","date":"2019-02-05T11:53:34.000Z","updated":"2021-01-28T12:06:11.473Z","comments":true,"path":"about/index.html","permalink":"http://a10000005588.github.io/about/index.html","excerpt":"","text":"Hi 我叫William L.K. 也可以直接叫我LK，佛系Programmer (=´ᴥ`)，想到就Code. 平常我會先在Github產出筆記，覺得有不錯的會搬移到這邊來，若有看到不對勁的地方，請在那篇貼文留言，LK非常感謝各路大大們的拔刀相助 下面則是一些跟個人感想跟一些想法紀錄。 2020 下班自修的經驗分享 2020年的想法與自修規劃 2019 2019年的想法與規劃"},{"title":"後端工程筆記區","date":"2021-01-20T11:53:34.000Z","updated":"2021-01-28T12:21:40.917Z","comments":true,"path":"backend/index.html","permalink":"http://a10000005588.github.io/backend/index.html","excerpt":"","text":"Spring FrameworkSpring 為開發Java時，最主流的後端框架，目前共紀錄以下筆記。 Spring Security 功能介紹 Spring Annotation筆記整理 Computer Science跟計算機概論或是較底層的內容就放這邊 靜態與動態函式庫的介紹與差異(Static 與 Shared Libraries)"},{"title":"區塊鏈筆記區","date":"2021-01-28T11:44:44.000Z","updated":"2021-01-28T12:03:12.899Z","comments":true,"path":"blockchain/index.html","permalink":"http://a10000005588.github.io/blockchain/index.html","excerpt":"","text":"目前共收錄了關於以太坊(Etherum)相關的學習紀錄 以太坊 以太坊測試網連接：Connect to the Rospen Network 如何查看透過智能合約存在以太坊上的資料 ERC Token介紹：ERC20 &amp; ERC721 使用OpenZeppelin搭配Truffle來打造智能合約 Solidity學習紀錄 使用truffle來練習撰寫認養寵物的智能合約 共識演算法 分散式系統共識算法筆記：Paxos和Raft"},{"title":"categories","date":"2021-01-27T14:55:20.000Z","updated":"2021-01-27T14:58:58.337Z","comments":true,"path":"categories/index.html","permalink":"http://a10000005588.github.io/categories/index.html","excerpt":"","text":"Testing"},{"title":"雲端工程筆記區","date":"2019-02-05T11:53:34.000Z","updated":"2021-01-27T23:51:29.255Z","comments":true,"path":"cloud/index.html","permalink":"http://a10000005588.github.io/cloud/index.html","excerpt":"","text":""},{"title":"前端工程筆記區","date":"2021-01-20T11:53:34.000Z","updated":"2021-01-27T23:52:06.994Z","comments":true,"path":"frontend/index.html","permalink":"http://a10000005588.github.io/frontend/index.html","excerpt":"","text":""},{"title":"工具使用筆記區","date":"2021-01-28T11:44:59.000Z","updated":"2021-01-28T11:55:47.120Z","comments":true,"path":"tools/index.html","permalink":"http://a10000005588.github.io/tools/index.html","excerpt":"","text":"部落格建置 利用Hexo來記錄自己的學習並使用Material-flow主題"},{"title":"程式語言的筆記區","date":"2021-01-05T11:53:34.000Z","updated":"2021-01-28T12:28:09.874Z","comments":true,"path":"programming/index.html","permalink":"http://a10000005588.github.io/programming/index.html","excerpt":"","text":"目前我看了有Java, Golang, Cpp，寫最多的還是Java． Golang 筆記 Go Interface介紹 Go的錯誤處理機制介紹 Defer, Panic與Recover Golang的特色介紹 Go使用Array、Slice與Map的介紹 Go Module 入門與使用介紹 Javascript 筆記 Javascript筆記:Closure(閉包)概念 Javascript筆記:使用prototype chain(原型鍊)來達成繼承效果 Design Pattern 筆記 Command Pattern 命令模式 [Design Pattern in Java] Adaptor Pattern 轉接器模式 [Design Pattern in Java] Composite Pattern 合成模式 [Design Pattern in Java] Facade Pattern 表象模式 [Design Pattern in Java] Factory Pattern 工廠模式 [Design Pattern in Java] Iterator Pattern 反覆器模式 [Design Pattern in Java] Observer Pattern 觀察者模式 [Design Pattern in Java] Singleton Pattern 獨體模式 [Design Pattern in Java] State Pattern 狀態模式 [Design Pattern in Java] Strategy Pattern 策略模式 [Design Pattern in Java] Template Pattern 樣板模式 [Design Pattern in Java]"}],"posts":[{"title":"認識與學習Bash [Linux鳥哥 Ch10]","slug":"linux","date":"2021-01-28T12:38:19.000Z","updated":"2021-01-28T12:39:20.392Z","comments":true,"path":"2021/01/28/linux/","link":"","permalink":"http://a10000005588.github.io/2021/01/28/linux/","excerpt":"","text":"Bash shell 功能打過的指令都是記錄在 ./bash_history.// 注意駭客可以透過 history 來查看你先前打過指令 ex MySQL 登入帳戶密碼資訊 alias 取代很長的指定若不想要每次打這麼長指令，可以用alias 來取代例如： ls -a 可以透過 alias lm=’ls -al’ 以lm來取代 type 查看指令是內部指令或外部指令像上面例子 lm=’ls -al’ 的lm 為我們自行定義的外部指令那cd, ls這些則是內部指令 透過 type lm, 可以看到lm 為外部指令 若覺得下的指令太長 可以透過 \\將三個檔案cp到 /root內…並用 \\來接續指令12cp /var/spool/mail/root /etc/crontab \\ &gt; /etc/fstab /root 取得版本號uname -r 可用變數將版本號存起來123version=$(uname -r) // 將版本號放到version變數echo $version 變數設定規則// 等號不能有空格1myname=VBird // 變數內容有空白，可用”” 或 ‘’包起來1var=&quot;lang is $LANG&quot; // 可用跳脫字元 “\\” 將特殊符號變成一般字元 //變數為擴增變數內容時，可以用$變數名稱 或${變數} 累加內容1PATH=$PATH:/home/bin // 變數需要在其他子程序執行，需要以 export 來使變數成為環境變數1export PATH 什麼是子程序？ 在目前的shell情況下，開啟另外一個shell亦即為子程序 // 取消變數的方法為 unset // $() 被兩個逗號包起來的指令會優先執行 123cd /lib/modules/$(uname -r)/kernal// 先用 uname -r 取得當前linux kernal版本號，再cd到該版本的目錄 透過 env 可以看到目前設置的環境變數HOME: 家目錄SHELL:目前shell使用的程式，預設是 /bin/bashHISTSIZE: 紀錄歷史指令得數目PATH: 執行黨搜尋的路徑LANG: 語系資料RANDOM: 隨機亂數 RANDOM會產出 0~32767若想要隨機取出0~9declare -i number=$RANDOM*10/32768 ; echo $number 透過 set 可以看到所有變數 (環境變數+自定義變數)透過 PS1 設定 提示字元ex: PS1=’[\\u@\\h \\w \\A ##]\\$ ‘設定命令提示字元顯示目前輸入幾次指令 ！ 變數鍵盤的讀取、陣列與宣告: read, array, declareread: 讀取來自使用者 鍵盤的輸入ex: 提示使用者30秒內輸入自己的大名，並將大名塞入 $named 變數內123read -p &quot;Please keyin your name: &quot; -t 30 namedecho $named delcare: 宣告變數的類型123456declare [-aixr] variable-a : 將後面名為variable定義為 array類型-i : integer-x : 變成環境變數-r : 設置成read only 注意：若sum=100+300+200 echo $sum 會得到 “100+300+200”字串，並非是600的結果，需要用 declare -i sum 才能得到integer sum unlimit 檔案系統與程序的限制關係限制使用者所使用的系統資源，包括CPU時間，記憶體數量 123456789ulimit [-SHacdltu] [配額]-H : hard limit 嚴德的限制，若超過則不能再用-S : Soft limit 警告的限制，超過只是會警告-a : 列出目前限制的數量，若不接參數則列出全部-c : 當某些程式發生錯誤，系統會將該程式在記憶體的資訊寫成檔案 (可除錯用)-f : 此shell 可以建立的最大檔案容量-u : 單一使用者可以使用的最大process數量... 變數的刪除、取代與替換直接看範例： 刪除#：從前面開始刪除, 刪除符合取代文字的 『最短的』那一個##： ．．．．『最長的』 \\%：從後面開始刪除，…..刪除『最短的』\\%%： 『最長的』 替換username=${username-root}若username為空值，替換成root 若加上: 可以強制替換username=${username:-root} 加上? 可以判斷是否有無此變數 bash的進站與歡迎訊息 : /etc/issue, /etc/motdcat /etc/issue bash的環境設定檔login 與 non-login shell login shell取得bash時需要完整輸入登入流程(輸入帳號密碼) /etc/profile: 系統整體的設定（最好別修改) ~/.bash_profile ~/.bash_login ~/.profile: 屬於使用者個人設定 系統登入shell時，優先載入 /etc/profile 再來才會依序載入使用者設定檔~/.bash_profile~/.bash_login~/.profile 只會讀取上面的一個，由上而下然而上面三個檔案可能會有包含執行 ~/.bashrc 的內容。。。 1234567# if running bash if [ -n \"$BASH_VERSION\" ]; then # include .bashrc if it exists if [ -f \"$HOME/.bashrc\" ]; then # here is the .bashrc . \"$HOME/.bashrc\" fi fi non-login shell直接打開另外一個終端機(shell)，該shell為 non-login shell 在non-login shell內要載入使用者， 得手動 ./bashrc &gt;, &gt;&gt;, |&gt; : 取代&gt;&gt; : 累加 命令執行的判斷依據： ; , &amp;&amp; ||分號 ; ： 可以執行連續指令1sync; sync; shutdown -h now $? 、 &amp;&amp; 、 || 可以判斷指令是否成功執行$?：若前一個指令執行的結果正確，在linux底下會回傳一個 $?=0的值 (cmd1 &amp;&amp; cmd2): 若cmd1執行完畢且正確執行($?=0)，則開始執行 cmd2 若cmd1執行完畢且執行錯誤($? != 0)，則不執行 cmd2 (cmd1 || cmd2): 若cmd1執行完畢且正確執行($?=0)，則cmd2不執行 若cmd1執行完畢且執行錯誤($? != 0)，則開始執行 cmd2 pipe 管線命令： 資料需要經過多個處理手續1ls -al /etc | less 透過 | 可以將 /etc 撈出來的資訊給 less解讀 擷取命令： cut, grep cut: 將某一段訊息切割出來 1echo $PATH | cut -d &apos;:&apos; -f 3,5 列出 PATH中的第3和第5個路徑 grep: 過濾出 有符合字元的訊息 排序命令： sort, wc, uniqsort 可以使語系統一 LANG=C 讓資料排序好一些 1cat /etc/passwd | sort uniq: 排序完成 並將重複的資料僅列出一個顯示 12last | cut -d &apos; &apos; -f1 | sort | uniq -c知道每位使用者的登入次數 wc: 知道某個檔案的組成 1cat /etc/man.config | wc tee: 雙向重新導向12345last | tee last.list | cut -d &quot; &quot; -fi這個範例可以讓我們將last 的輸出存一份到last.list 檔案中last | /home | tee ~/homefile | more 這個範例是將 ls 的資料存一份到 ~/homefile ，同時螢幕也有輸出訊息 字元轉換命令: tr, col, join, paste, expandtr: 刪除一段訊息中的文字、或者是進行文字的轉換 col: 經常被用來將 man page 轉存為純文字檔案以方便查閱 1man col | col -b &gt; /root/col.man join: 兩個檔案當中，有相同資料的那一行，才將它加在一起 分割命令: split1cat termcap* &gt;&gt; termcapback 使用 ls -al / 輸出的資訊中，每十行紀錄變成一個檔案1ls -al / | split -l 10 lsroot 1wc -l lsroot* 參數代換： xargs: 產生某個指令的參數有些指令不其實並不支援管線命令，因此我們可以透過xarg該指令引用 standard input之用。 減號 -的用途tar -cvf - /home | tar -xvf - 我將/home裡面的檔案給他打包，但打包的資料不是記錄到檔案，而是傳送到stdout; 經過管線後，將tar -cvf - /home 傳送給後面的tar -xvf - 後面 - 取用前一個指令的stdout， 因此不需要使用file","categories":[{"name":"Devops","slug":"Devops","permalink":"http://a10000005588.github.io/categories/Devops/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://a10000005588.github.io/tags/Linux/"}]},{"title":"Go new與make的介紹與差異 [Golang]","slug":"Go-new與make的介紹與差異","date":"2020-11-08T03:19:59.000Z","updated":"2020-11-08T05:01:19.326Z","comments":true,"path":"2020/11/08/Go-new與make的介紹與差異/","link":"","permalink":"http://a10000005588.github.io/2020/11/08/Go-new與make的介紹與差異/","excerpt":"Golang中，make與new都是建構變數來使用","text":"Golang中，make與new都是建構變數來使用 new的介紹new(T)會建構一個T型別的 “沒有名字” 的變數，以T的zeroed value來初始化T，且new(T) 回傳 “指向T的指標” 若T是 string，那zeroed值為 &quot;&quot; 若T是 int，那zeroed值為 0 若T是 channel, func, map, slice，那zeroed值為 nil 範例1234567p := new(int) // 宣告一個指向int不具名變數的`指標p`，`指標p`指向一個初始化的zeroed value為0fmt.Print(*p) // 印出 0*p = 2 // 將不具名變數的值設置為2fmt.Print(*p) // 印出 2 其中new算是golang語法的簡寫，其中123func newInt() *int &#123; return new(int)&#125; 就等於下列寫法1234func newInt() *int &#123; var dummy int return &amp;dummy // 回傳dummy的指標&#125; 注意: 謹慎操作new出來的map因為用new初始化的map會是 nil map，故以下操作會出現panic 12345678func main() &#123; book := new(map[string]string) // 宣告一個指標叫做book, 指向一個map為index是string // 映射到string型態的book名稱 b := *book // 取得book指標所指向的map b[\"ISBN-001\"] = \"go programming language\" // panic: assignment to entry in nil map&#125; 上述範例會出錯的原因是因為， b是一個nil map，沒有指向任何的記憶體位置，所以對一個nil值操作當然會冒出error 解法就得透過 make 方法為nil map分配確定的內存地址了 new 不是 Keyword要注意一點是 new 並非是golang的關鍵字，故可以在func內重新宣告123func delta(old, new int) int &#123; return new - old&#125; make的介紹 make(T, args)用來為 slices, maps, 以及 channel分配其記憶體位址的空間與初始化值，並回傳一個型態T的參考！ make不會回傳指標！ 範例123456func main() &#123; books := make([]string, 100) // 初始化長度為100的book字串陣列，每個array內的值都是 \"\" receiver := make(chan string) // 初始化channel，但不會回傳指標 booksMapper := make(map[string]string)&#125; 由於make回傳的是參考，所以若將make宣告的s2 傳給func modifySlice對s2做修改時，也會影響s2的內容 12345678func modifySlice(s []int) &#123; s[0] = 1&#125;s2 := make([]int, 3)fmt.Printf(\"%#v\", s2) // s2為 []int&#123;0, 0, 0&#125;modifySlice(s2)fmt.Printf(\"%#v\", s2) // s2被modifySlice()方法給變成 []int&#123;1, 0, 0&#125; new與make的差異 new會回傳指標，但是初始化的值為zeroed value，特別是在對map做初始化時，其zeroed valued為 nil，意思就是不會分配其記憶體位置 make只能用來對特別型態(如map, slice, func, channle)分配其記憶體內存地址，以及為這些特殊型態設定該初始值 (string就是””, int為0) 所以若要傳指標時，就需要考慮用new，而非是make了 參考 golang 筆記：make 與 new 的差別 by 愷開 https://medium.com/d-d-mag/golang-%E7%AD%86%E8%A8%98-make-%E8%88%87-new-%E7%9A%84%E5%B7%AE%E5%88%A5-68b05c7ce016 Allocation with make https://golang.org/doc/effective_go.html#allocation_make Allocation with new https://golang.org/doc/effective_go.html#allocation_new The Go Programming Language, Author: Alan A. A. Donovan, Brian W. Kernighan 不要向nil map写入(panic: assignment to entry in nil map) #7 https://github.com/kevinyan815/gocookbook/issues/7 理解 Go make 和 new 的区别 by 三月沙 https://sanyuesha.com/2017/07/26/go-make-and-new/","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/tags/Golang/"}]},{"title":"Go Module 入門與使用介紹","slug":"Go-Module-入門與使用介紹介紹","date":"2020-11-07T14:46:02.000Z","updated":"2021-01-28T12:18:22.322Z","comments":true,"path":"2020/11/07/Go-Module-入門與使用介紹介紹/","link":"","permalink":"http://a10000005588.github.io/2020/11/07/Go-Module-入門與使用介紹介紹/","excerpt":"Go Module 為目前最主流的依賴解決的方案 發佈於 Go 11.1版，於Go 1.14推薦在Production環境上使用","text":"Go Module 為目前最主流的依賴解決的方案 發佈於 Go 11.1版，於Go 1.14推薦在Production環境上使用 Go Modules的出現解決了以下幾點爭議： 依賴問題 淘汰GOPATH的機制 統一社群中其他依賴管理工具 為何 GOPATH 不在被推薦使用簡單介紹GOPATH原先是透過定義好的目錄結構如下： 1234567go|--bin|--pkg|--src |--github.com |--golang.org ... 各目錄分別為： bin: 儲存所編譯產生的二進位檔案 pkg: 儲存預先編譯的目的檔案，以加快程式的後續編譯速度 src: 儲存所有 .go 檔案或原始程式碼 一般會以 $GOPATH/src/github.com/ 儲存 Go的應用程式和函式庫 棄用原因: 無法明確定義與參照依賴(Dependency)的版本因為.go 專案都必須要儲存在 $GOPATH/src 底下，但該依賴管理方式並沒有提供版本控制的概念，會造成以下問題： 執行go get 取得遠端的依賴包時，會無法得知目前所載的版本 無法處理 v1,v2,v3等不同版本的參考問題，假設有的Library叫做 /foo/bar 但不管幾版，都會在GOPATH底下，其路徑都會是一樣的 (都在github.com/foo/bar) Go modules的基本使用方式指令 go mod init: 產生 go.mod 檔案 go mod download: 下載go.mod檔案中指明的所有依賴 go mod tidy: 整理所有依賴 go mod graph: 檢視現有的依賴結構 go mod edit: 編輯 go.mod 檔案 go mod vendor: 會出專案所有的依賴到vendor目錄 go mod verify: 驗證一個模組是否被竄改過 go mod why: 檢視為何需要依賴該模組 環境變數可透過 go env 來檢視常用的環境變數，以下為與Go Module相關的環境變數 12345678910111213141516171819202122232425262728293031323334353637# GOMODULES新增的環境變數GO111MODULE=\"on\"GOPROXY=\"https://proxy.golang.org,direct\"GONOPROXY=\"\"GOSUMDB=\"sum.golang.org\"GONOSUMDB=\"\"GOPRIVATE=\"\"# 以下為原本GOPATH就有的環境變數GOARCH=\"amd64\"GOBIN=\"/Users/user/go/bin\"GOCACHE=\"/Users/user/Library/Caches/go-build\"GOENV=\"/Users/user/Library/Application Support/go/env\"GOEXE=\"\"GOFLAGS=\"\"GOHOSTARCH=\"amd64\"GOHOSTOS=\"darwin\"GOINSECURE=\"\"GOMODCACHE=\"/Users/user/go/pkg/mod\"GOOS=\"darwin\"GOPATH=\"/Users/user/go\"GOROOT=\"/usr/local/Cellar/go/1.15/libexec\"GOTMPDIR=\"\"GOTOOLDIR=\"/usr/local/Cellar/go/1.15/libexec/pkg/tool/darwin_amd64\"GCCGO=\"gccgo\"AR=\"ar\"CC=\"clang\"CXX=\"clang++\"CGO_ENABLED=\"1\"GOMOD=\"/dev/null\"CGO_CFLAGS=\"-g -O2\"CGO_CPPFLAGS=\"\"CGO_CXXFLAGS=\"-g -O2\"CGO_FFLAGS=\"-g -O2\"CGO_LDFLAGS=\"-g -O2\"PKG_CONFIG=\"pkg-config\"GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/3t/8jsg2cz52yn2glq8rk_9y7x40000gn/T/go-build233814295=/tmp/go-build -gno-record-gcc-switches -fno-common\" GO111MODULE透過GO111MODULE作為該專案是否使用 Go modules的開關，可設定以下內容 auto: 只要專案包含 go.mod 檔案，就使用Go modules (在Go 1.11~1.14，為預設) on: 啟用Go modules (推薦使用) off: 禁用Go modules 為何叫做 GO111MODULE?因為go modules是在 go1.11版本所提出的 GOPROXY設定GO模組的proxy, 使Go在後續拉取模組的版本時，直接透過映像檔網站快速拉取，而非到Github這種Version control service平台 GOPROXY預設值為 https://proxy.golang.org,direct，透過逗號將代理的地方給隔開 若不想使用GOPROXY, 可設置為 GOPROXY=”off” 其中最後有 direct 一詞的用意是，若前面的proxy值都沒辦法載到模組，例如在 https://proxy.golang.org抓不到，那麼就會回到原位置(例如Github)去下載 GOSUMDBGOSUMDB為Go checksum database，驗證拉取的模組版本資料未經過竄改 預設值為 sum.golang.org，也可設置成 off，禁止Go在後續操作中做驗證版本的動作 GONOPROXY/GONOSUMDB/GOPRIVATE設定私有模組的環境變數，一般來說建議直接設定 GONOPROXY，會作為 GONOPROXY與GONOSUMDB的預設值 值可設定多組，例如1$ go env -w GOPRIVATE=\"git.xxx.com,github.com/eddycjy/mquote\" 設定之後字首為 git.xxx.com 以及 github.com/eddycjy/mquote 的模組會被認為是私有模組 也可以直接用設定 *，以下表示來自.example.com 的子域名的都表示來自私有倉庫 1$ go env -w GOPRIVATE=\"*.example.com\" 啟用方式Go modules預設不是開啟的，透過GO111MODULE來做設定，可用auto, on, off做設定 透過env進行設定 go env -w1$ go env -w GO111MODULE=on 初始化一個專案在一個資料夾內，透過 go mod init 初始化一個專案 12$ go mod init github.com/jellyhola/module-repogo: creating new go.mod: module github.com/jellyhola/module-repo 這時會產生一個 go.mod 檔案，會紀錄目前專案模組為 github.com/jellyhola/module-repo，go版本為1.15123module github.com/jellyhola/module-repogo 1.15 這時定義一份 main.go 檔案，import github.com/example/hello123456789101112package mainimport \"rsc.io/quote\"func main() &#123; Hello()&#125;//Hello :print quote.Hello()func Hello() string &#123; return quote.Hello()&#125; 這時專案目錄會自動產生 go.sum檔案, 以及go.mod會多紀錄使用了 rsc.io/quote模組以及使用的版本為 1.5.2 go.sum123456golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8=golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=rsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPXsUe+TKr0=rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA= go.mod12345module github.com/jellyhola/module-repogo 1.15require rsc.io/quote v1.5.2 建議將 go.sum與go.mod這兩個檔案提交到版本控制 由於本身rsc.io/quote這個模組，下載go時就已經安裝完畢，故不用透過 go get來額外下載 接著可用go list -m all 檢視目前專案所使用的依賴 12345$ go list -m allgithub.com/jellyhola/module-repogolang.org/x/text v0.0.0-20170915032832-14c0d48ead0crsc.io/quote v1.5.2rsc.io/sampler v1.3.0 可看到目前 golang.org/x/text這項模組，為untagged的狀況，接著可以透過 go get來更新此模組到最新的tag 123$ go get golang.org/x/textgo: golang.org/x/text upgrade =&gt; v0.3.4go: downloading golang.org/x/text v0.3.4 可看到 go.mod內容改變了12345678module github.com/jellyhola/module-repogo 1.15require ( golang.org/x/text v0.3.4 // indirect rsc.io/quote v1.5.2) 其中 // indirect 表示該模組為間接依賴，表示目前應用程式的import敘述中，並沒有發現這模組的明確參考，有可能是 事先手動go get拉取下來的模組 該專案所依賴模組之所依賴的 試著跑一下專案，驗證模組是否能正常運作 script12$ go run main.go你好，世界。% 拉取的模組會存在哪？go mod會將拉取的模組放置在 $GOPATH/pkg/mod 與 $GOPATH/pkg/sumdb 目錄下！ 12$ ls $GOPATH/pkgcache github.com golang.org rsc.io 若想要清除已經快取的模組版本，使用 go clean -modcache 指令 Go module 進階探討Go modules的go get探討使用go get取得模組時，會分別進行3個步驟 finding: 查找模組是否存在 downloading: 進行下載 extracting: 分析下載的模組的雜湊值是否正確 像上一節所拉取的模組 golang.org/x/text 其拉取的資訊如下 script12版本資訊-commit的時間-雜湊值v0.0.0-20170915032832-14c0d48ead0c commit的時間會是以UTC時區為準 go get拉取的指令若沒有指定版本，會直接拉取到 v0.0.0版 go get行為 go get: 直接拉取dependency，只會更新指定的他自己 go get -u: 更新現有的dependency，會強制更新該denpendency所依賴的其他模組 go get -u -t: 更新所有denpendency，以及包含單元測試使用到的 go get版本指定 go get golang.org/x/text@latest : 拉取最新的版本，若存在tag，優先使用之 go get golang.org/x/text@master : 拉取master分支的最新commit go get golang.org/x/text@v0.3.2 : 拉取tag為v0.3.2的commit go get golang.org/x/text@342b2e : 拉取hash為342b2e的commit，最後轉為 v0.3.2 Go modules的go run與go build執行go build時，會根據go.mod自動下載該專案所需的模組，才進行編譯 若是要使用 vendor目錄作為denpendency, 在執行 go mod vendor產生vendor目錄後，需要執行 go build -mod=vendor才可使用 go build -mod=vendor 使用vendor目錄作為denpendency來編譯 Go modules匯入路徑說明Go modules在主版本編號為 v0與v1的情況會省略其編號，在v2以上則需要明確指定！ 假如要匯入 v2以上的golang.org/example@v2.0.0，則必須要在import底下明確指定v2 123import ( \"github.com/example/v2\") 為何省略v0與v1??因為官方鼓勵開發人員將模組建立到v1版本就不在變動。 所以若開發人員在發佈v2版本時，會被擁有明確的v1版本尾綴，近一步導致v1版本變成雜訊且沒有什麼意義 在匯入路徑忽略v0版本，因為根據語意化版本標準，v0的這些版本大多沒有相容性保證 Go modules 語意化版本控制一個go modules的版本資訊如下12//主版本號.次版本號.修訂號v1.2.3 主版本編號：做了不相容的API修改之類的 次版本編號: 做了向下相容的功能性新增 修訂好: 向下相容的功能除錯 若是先行版本的話，那加上 pre 後綴1v1.2.3-pre 發佈新版本時應遵循語意化版本規則，否則無法被go get所拉取 go list的功能提供該專案所有denpendency的資訊 透過 go list -m -u all 可以檢視所有的dependency資訊 123456$ go list -m -u allgithub.com/jellyhola/module-repogolang.org/x/text v0.3.4golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6ersc.io/quote v1.5.2rsc.io/sampler v1.3.0 -m: 顯示所有依賴的模組 -u: 顯示能夠升級的版本","categories":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/tags/Golang/"}]},{"title":"Gitbook的使用紀錄","slug":"gitbook-tutorial","date":"2020-10-03T22:47:21.000Z","updated":"2021-01-28T12:12:54.817Z","comments":true,"path":"2020/10/04/gitbook-tutorial/","link":"","permalink":"http://a10000005588.github.io/2020/10/04/gitbook-tutorial/","excerpt":"Gitbook提供了能夠將markdown格式轉寫成一本電子書的樣子","text":"Gitbook提供了能夠將markdown格式轉寫成一本電子書的樣子 本地端執行安裝方式，用 npm 安裝 1npm install -g gitbook-cli 使用方式找一個資料夾，執行1gitbook init 會產生 reamdme.md 介紹本書內容 summary.md 用來定義gitbook目錄 summary.md 結構123* ch1 * ch1-1 * ch1-2 檔案結構的話就長這樣12345- ch1|- ch1-1|- ch1-2-readme.md-summary.md 運行gitbook1gitbook serve 預設會運行在 localhost:4000 安裝Plugin事先安裝gitbook-plugin套件1npm install gitbook-plugin 若要安裝留言板等套件，需要先定義 book.json ，可以定義使用的plugin book.json12345678&#123; &quot;plugins&quot;: [&quot;disqus&quot;], &quot;pluginsConfig&quot;: &#123; &quot;disqus&quot;: &#123; &quot;shortName&quot;: &quot;你的留言板名稱&quot; &#125; &#125;&#125; 例如可使用 Google Analytics ( Google 分析 )、Disqus ( 社群&amp;留言板 ) 和 youtube …等外掛，也可以在Gitbook npm網站中找到自己要的plugin 定義玩使用的plungin外掛，請執行1gitbook install Disqus留言板1npm i gitbook-plugin-disqus 12345678&#123; &quot;plugins&quot;: [&quot;disqus&quot;], &quot;pluginsConfig&quot;: &#123; &quot;disqus&quot;: &#123; &quot;shortName&quot;: &quot;你的留言板名稱&quot; &#125; &#125;&#125; 內容綱要 InTopic TOC如果要實現右邊側邊欄本頁md檔案的階層式，可安裝 InTopic TOC GitBook plugin: InTopic TOC 於book.json中定義12345678910&#123; &quot;plugins&quot;: [ &quot;intopic-toc&quot; ], &quot;pluginsConfig&quot;: &#123; &quot;intopic-toc&quot;: &#123; &quot;label&quot;: &quot;In this article&quot; &#125; &#125;&#125; 接著執行1gitbook install 參考Gitbook Github Docs Gitbook Online Platform Docs 用 GitBook 來寫本書吧","categories":[{"name":"Tools","slug":"Tools","permalink":"http://a10000005588.github.io/categories/Tools/"}],"tags":[{"name":"Note","slug":"Note","permalink":"http://a10000005588.github.io/tags/Note/"}]},{"title":"靜態與動態函式庫的介紹與差異(Static 與 Shared Libraries)","slug":"Static_vs_Shared_Lib","date":"2020-08-17T13:38:37.000Z","updated":"2021-01-28T12:10:16.323Z","comments":true,"path":"2020/08/17/Static_vs_Shared_Lib/","link":"","permalink":"http://a10000005588.github.io/2020/08/17/Static_vs_Shared_Lib/","excerpt":"剛好在複習Golang的時候看到Go有支援載入C Language的Static Library與Shared Libraries，於是來複習一下他們之間的差異","text":"剛好在複習Golang的時候看到Go有支援載入C Language的Static Library與Shared Libraries，於是來複習一下他們之間的差異 介紹首先要先了解，Library的意義，就單純為一個檔案將會共用的程式碼打包再一起的檔案就稱為Library 假設現在若要使用print這個方法來印出東西在螢幕，故可以將print編譯成Library，供各個開發者直接使用，不用讓開發者自己定義print方法，要煩惱如何與OS溝通並印出畫面的邏輯程式碼 Static LibraryStatic Libarary通常為我們自己寫好的程式碼，經過Compile之後，所得到的就是 Static Library Shared則是我們也是將程式碼經過Compile，也是得到 Shared Library 聽起來過程都很像，那到底差異在哪？ 其實從字面上曉得，從使用其意義來解釋 在專案程式使用其Static Library時，該專案進行Compile，Compiler會在Compile Time時將Static Library的程式碼給”複製”到專案程式碼中。 假如我們Static Lib中有個print()方法，那專案Compile時就會把print()方法copy到APP中，APP啟動時就會有print()方法 12CODE (import static lib) -&gt; Compiled STATIC LibAPP 啟動 -&gt; PRINT() Shared Library顧名思義就是直接共享Library內的程式碼 當專案使用的是Shared Library，那專案進行Compile時，Compiler會去Link Shared Libaray的方法，而不是用複製的。 假如Shared Library Lib中同樣有個print()方法，那專案Compile就會連結該Shared Lib中的print()方法，於是APP啟動也同樣會有print()方法可使用 12CODE (import shared lib) -&gt; CompiledAPP 啟動 -&gt; 連結使用 Shared Lib內的 print() Shared Library支援動態連結載入 使用情境若要給客戶提供一個有100個功能的APP 交付給客戶的若是 Static Library建築出的APP: 1客戶聽著，你只要有這一個檔案，就包含了你需要的100個功能 若交付給客戶的功能，每一隻功能都用Shared Library實作，那麼。。。 1客戶聽著，我這個檔案很小，但同時要連結100的檔案 (Shared Library)，一個都不能少，才能啟動 優缺點 Static Shared 專案大小 專案size比較肥大 專案的size較小 啟動狀況 程式碼在Compile時都放在一起了，直接運行該專案就好 若某個Shared Lib不見，專案會無法啟動 是否支援動態連結 無，專案運作時較耗費記憶體 有支援，當執行到有使用Shared Library的class時，才會載入之到記憶體，避免記憶體空間浪費 Library編譯的檔案格式 Shared Libraries .so (Linus) .dll (Win) .dylib (Mac) Static Libraries .a .lib 參考Static vs. Shared Librarieshttps://www.youtube.com/watch?v=-vp9cFQCQCo Static 與 Shared 的函式庫撰寫https://fred-zone.blogspot.com/2006/03/static-shared.html 動態連結函式庫https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://a10000005588.github.io/categories/Computer-Science/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://a10000005588.github.io/tags/Computer-Science/"}]},{"title":"State Pattern 狀態模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-State-Pattern-狀態模式","date":"2020-08-08T14:10:35.000Z","updated":"2021-01-28T12:17:50.577Z","comments":true,"path":"2020/08/08/Design-Pattern-Java-State-Pattern-狀態模式/","link":"","permalink":"http://a10000005588.github.io/2020/08/08/Design-Pattern-Java-State-Pattern-狀態模式/","excerpt":"透過統一的”狀態類別”，來定義物件的內部狀態是如何","text":"透過統一的”狀態類別”，來定義物件的內部狀態是如何 以糖果機為例子，沒有使用State Pattern的狀況我們現在有個糖果機，通常一台糖果機可以進行投幣，轉動手把，並吐出一顆糖果 所以該糖果機共有四種狀態 (NoCoinState目前沒有錢幣, HasCoinState目前有錢幣, SoldCandyState售出糖果中, NoCandyState沒有糖果中)，如附圖所示： 我們會很直覺的定義糖果機類別與這四個狀態為全域變數，並且實作一下糖果機具備的動作方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344class CandyMachine &#123; public static int NoCandyState = 0; public static int NoCoinState = 1; public static int HasCoinState = 2; public static int SoldCandyState = 3; int state = NoCandyState; // 一開始糖果機是沒有糖果的 int count = 0; // 糖果數目 CandyMachine(int count) &#123; this.count = count; this.state = NoCoinState; // 有了糖果，等待被投錢 &#125; public void insertCoin() &#123; System.out.println(\"投入錢幣\"); this.state = HasCoinState; &#125; public void turnCrank() &#123; System.out.println(\"轉動把手中......\"); // 判斷目前是否有錢 if (this.state == HasCoinState) &#123; this.state = SoldCandyState; this.dispense(); &#125; else &#123; System.out.println(\"目前沒有錢幣\"); &#125; &#125; public void dispense() &#123; // 有錢的話就吐一顆糖果出來 System.out.println(\"糖果機吐了一顆糖果\"); this.count--; if (this.count == 0) &#123; // 沒有糖果了，回歸到沒糖果狀態 this.state = NoCandyState; &#125; else &#123; // 還有糖果的話，顯示目前沒有錢幣 this.state = NoCoinState; &#125; &#125;&#125; 那我們現在可以來跟糖果機互動一下 12345678910111213141516public class main &#123; public static void main(String[] args) &#123; CandyMachine candyMachine = new CandyMachine(1); // 先投錢，在轉動 System.out.println(\"====先投錢，在轉動====\"); candyMachine.insertCoin(); candyMachine.turnCrank(); // 不投錢，直接轉動 System.out.println(\"====不投錢，直接轉動====\"); candyMachine.turnCrank(); // 投錢，但糖果機目前沒糖果了 System.out.println(\"=====投錢，但糖果機目前沒糖果了====\"); candyMachine.insertCoin(); &#125;&#125; 12345678910====先投錢，在轉動====投入錢幣轉動把手中......糖果機吐了一顆糖果====不投錢，直接轉動====轉動把手中......目前沒有錢幣=====投錢，但糖果機目前沒糖果了====投入錢幣目前沒有糖果，錢退還給您 目前看起來運作的很正常 假如有新需求：轉動時會有機率可以再多送一顆！那這時候…我們得對CandyMachine的dispense()做個調整： 12345678910111213141516171819202122232425 public void dispense() &#123; // 定義機率，如果機率小於10%就吐出兩顆糖果 Random rand = new Random(); if (rand.nextInt(10) &lt;= 5) &#123; System.out.println(\"恭喜中獎，糖果機吐了二顆糖果\"); if (this.count &gt;= 2) &#123; // 吐出兩顆糖果 this.count--; this.count--; &#125; &#125; else &#123; // 沒中獎，只吐一顆 this.count--; // 有錢的話就吐一顆糖果出來 System.out.println(\"糖果機吐了一顆糖果\"); &#125; if (this.count == 0) &#123; // 沒有糖果了，回歸到沒糖果狀態 this.state = NoCandyState; &#125; else &#123; // 還有糖果的話，顯示目前沒有錢幣 this.state = NoCoinState; &#125;&#125; 這時可以看到，每次若有新需求，就需要一直對CandyMachine類別一直做修正，其未來若有更多狀態時，程式碼會變得不好維護 使用狀態模式改善目前糖果機的設計先來看看該設計模式的圖表是長怎樣 狀態模式的類別圖 這時我們可以看到，將原本糖果機內的static全域變數狀態，都統一變成一個state變數 (為StateComponent介面型態)。 這時我們就想把每個狀態 (NoCoinState目前沒有錢幣, HasCoinState目前有錢幣, SoldCandyState售出糖果中, NoCandyState沒有糖果中) 都統一變成 ConcreteState類別，來實作State抽象介面，以利Client類別可以抽換狀態 接著直接來改造糖果機，先定義每個狀態都會有對應的方法 因為當糖果機為某種狀態時，若呼叫其動作，就會印出對應的資訊 這裡我們先為每個動作都先拋出例外，因為有些方法有的狀態可能不需要使用 1234567891011abstract class State &#123; void insertCoin() &#123; throw new UnsupportedOperationException(); &#125; void turnCrank() &#123; throw new UnsupportedOperationException(); &#125; void dispense() &#123; throw new UnsupportedOperationException(); &#125;&#125; 定義糖果機的雛形糖果機擁有了各個狀態的類別，並且提供getXXX()方法，供其他狀態可以抽換自己的狀態 1234567891011121314151617181920212223242526272829303132333435363738class CandyMachine &#123; public State state; public int count; State noCoinState; State hasCoinState; State soldCandyState; State noCandyState; CandyMachine(int count) &#123; this.count = count; noCoinState = new NoCoinState(this); hasCoinState = new HasCoinState(this); soldCandyState = new SoldCandyState(this); noCandyState = new NoCandyState(this); &#125; public void setState(State state) &#123; this.state = state; &#125; public State getNoCoinState() &#123; return this.noCoinState; &#125; public State getHasCoinState() &#123; return this.hasCoinState; &#125; public State getSoldCandyState() &#123; return this.soldCandyState; &#125; public State getNoCandyState() &#123; return this.noCandyState; &#125;&#125; 實作各個狀態每個狀態都會引入CandyMachin類別，以便能夠幫助糖果機進行狀態變化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class NoCoinState extends State &#123; CandyMachine candyMachine; NoCoinState(CandyMachine candyMachine) &#123; this.candyMachine = candyMachine; &#125; @Override void insertCoin() &#123; System.out.println(\"投入錢幣\"); this.candyMachine.setState(this.candyMachine.getHasCoinState()); &#125; @Override public void turnCrank() &#123; System.out.println(\"目前沒有錢幣\"); &#125;&#125;class HasCoinState extends State &#123; CandyMachine candyMachine; HasCoinState(CandyMachine candyMachine) &#123; this.candyMachine = candyMachine; &#125; @Override public void insertCoin() &#123; System.out.println(\"目前已經有錢幣了！\"); &#125; @Override public void turnCrank() &#123; System.out.println(\"轉動手把中\"); // 切換到下一個狀態 candyMachine.setState(this.candyMachine.getSoldCandyState()); this.candyMachine.state.dispense(); &#125; @Override public void dispense() &#123; System.out.println(\"目前沒有錢幣\"); &#125;&#125;class SoldCandyState extends State &#123; CandyMachine candyMachine; SoldCandyState(CandyMachine candyMachine) &#123; this.candyMachine = candyMachine; &#125; @Override public void insertCoin() &#123; System.out.println(\"目前正在吐糖果中，請勿投幣！\"); &#125; @Override public void turnCrank() &#123; System.out.println(\"目前正在吐糖果中，請勿轉動！\"); &#125; @Override public void dispense() &#123; System.out.println(\"開始吐糖果\"); // 定義機率，如果機率小於10%就吐出兩顆糖果 Random rand = new Random(); if (rand.nextInt(10) &lt;= 5) &#123; System.out.println(\"恭喜中獎，糖果機吐了二顆糖果\"); if (this.candyMachine.count &gt;= 2) &#123; // 吐出兩顆糖果 this.candyMachine.count--; this.candyMachine.count--; &#125; &#125; else &#123; // 沒中獎，只吐一顆 this.candyMachine.count--; // 有錢的話就吐一顆糖果出來 System.out.println(\"糖果機吐了一顆糖果\"); &#125; if (this.candyMachine.count == 0) &#123; this.candyMachine.setState(this.candyMachine.getNoCandyState()); &#125; else &#123; this.candyMachine.setState(this.candyMachine.getNoCoinState()); &#125; &#125;&#125;class NoCandyState extends State &#123; CandyMachine candyMachine; NoCandyState(CandyMachine candyMachine) &#123; this.candyMachine = candyMachine; &#125; @Override public void insertCoin() &#123; System.out.println(\"目前沒有糖果，請勿投幣！\"); &#125; @Override public void turnCrank() &#123; System.out.println(\"目前沒有糖果，請勿投幣\"); &#125;&#125; 操作糖果機12345678910111213141516public class main &#123; public static void main(String[] args) &#123; CandyMachine candyMachine = new CandyMachine(2); // 先投錢，在轉動 System.out.println(\"====先投錢，在轉動====\"); candyMachine.state.insertCoin(); candyMachine.state.turnCrank(); // 不投錢，直接轉動 System.out.println(\"====不投錢，直接轉動====\"); candyMachine.state.turnCrank(); // 投錢，但糖果機目前沒糖果了 System.out.println(\"=====投錢，但糖果機可能目前沒糖果了====\"); candyMachine.state.insertCoin(); &#125;&#125; 123456789====先投錢，在轉動====投入錢幣轉動手把中開始吐糖果恭喜中獎，糖果機吐了二顆糖果====不投錢，直接轉動====目前沒有糖果，請勿投幣=====投錢，但糖果機目前沒糖果了====目前沒有糖果，請勿投幣！ 用這張圖可以更了解糖果機是如何與狀態們做互動 小結我們可以看到套用狀態模式後，若未來要新增狀態時，直接實作State抽象類別，並且只會需要更動到跟新增狀態類別的相關連狀態，使得我們程式更好維護","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"}]},{"title":"Composite Pattern 合成模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Composite-Pattern-合成模式","date":"2020-08-06T13:34:16.000Z","updated":"2021-01-28T12:17:21.724Z","comments":true,"path":"2020/08/06/Design-Pattern-Java-Composite-Pattern-合成模式/","link":"","permalink":"http://a10000005588.github.io/2020/08/06/Design-Pattern-Java-Composite-Pattern-合成模式/","excerpt":"將有階層關係的類別狀態給扁平化，給使用者看到的是一致性的關係","text":"將有階層關係的類別狀態給扁平化，給使用者看到的是一致性的關係 若沒有合成模式會怎樣？假如現在我們來到一間自助吧，有一個菜單類別，但這個菜單類別裡面還會有甜點這個子菜單 大概長下面這樣 於是我們大概會這樣實作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class BuffetMenu &#123; String name; ArrayList&lt;String&gt; items; DessertMenu dessertMenu; BuffetMenu() &#123; this.name = \"自助餐菜單\"; this.items = new ArrayList&lt;&gt;(); this.dessertMenu = new DessertMenu(); // 初始化項目 this.init(); &#125; private void init() &#123; this.items.add(\"牛肉麵\"); this.items.add(\"海鮮飯\"); this.items.add(\"牛排\"); &#125; public void setMenuItem(String item) &#123; this.items.add(item); &#125; public void showMenuItem() &#123; for(String item: items) &#123; System.out.println(this.name + \":\" + item); &#125; &#125; public void print() &#123; System.out.println(\"開始介紹\" + this.name); showMenuItem(); &#125;&#125;class DessertMenu &#123; String name; ArrayList&lt;String&gt; items; ChocolateMenu chocolateMenu; DessertMenu() &#123; this.name = \"甜點菜單\"; this.items = new ArrayList&lt;&gt;(); this.init(); &#125; private void init() &#123; this.items.add(\"雞蛋餅乾\"); this.items.add(\"巧克力\"); this.items.add(\"棉花糖\"); &#125; public void setMenuItem(String item) &#123; this.items.add(item); &#125; public void showMenuItem() &#123; for(String item: items) &#123; System.out.println(this.name + \":\" + item); &#125; &#125; public void print() &#123; System.out.println(\"開始介紹\" + this.name); showMenuItem(); &#125;&#125; 可以看到DessertMenu類別包含在BuffetMenu類別了 我們現在有位服務生提供介紹菜單內容，定義如下 123456789101112131415class Waitress &#123; BuffetMenu buffetMenu; Waitress(BuffetMenu buffetMenu) &#123; this.buffetMenu = buffetMenu; &#125; public void introduceMenu() &#123; // 介紹菜單 this.buffetMenu.print(); this.buffetMenu.showMenuItem(); this.buffetMenu.dessertMenu.print(); this.buffetMenu.dessertMenu.showMenuItem(); &#125;&#125; 然後我們請服務生開始介紹菜單 123456789public class main &#123; public static void main(String[] args) &#123; BuffetMenu buffetMenu = new BuffetMenu(); Waitress waitress = new Waitress(buffetMenu); waitress.introduceMenu(); &#125;&#125; 12345678開始介紹自助餐菜單自助餐菜單:牛肉麵自助餐菜單:海鮮飯自助餐菜單:牛排開始介紹甜點菜單甜點菜單:雞蛋餅乾甜點菜單:棉花糖甜點菜單:巧克力 但假如現在變成這樣呢：甜點內的巧克力又有不同類型的巧克力，那我們又要再修改上面的程式碼，將Chocolate類別加入到Dessert類別內 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class DessertMenu &#123; String name; ArrayList&lt;String&gt; items; ChocolateMenu chocolateMenu; // 多了巧克力菜單 DessertMenu() &#123; this.chocolateMenu = new ChocolateMenu(); this.name = \"甜點菜單\"; this.items = new ArrayList&lt;&gt;(); this.init(); &#125; private void init() &#123; this.items.add(\"雞蛋餅乾\"); this.items.add(\"棉花糖\"); &#125; public void setMenuItem(String item) &#123; this.items.add(item); &#125; public void showMenuItem() &#123; for(String item: items) &#123; System.out.println(this.name + \":\" + item); &#125; &#125; public void print() &#123; System.out.println(\"開始介紹\" + this.name); &#125;&#125;// 多了巧克力菜單class ChocolateMenu &#123; String name; ArrayList&lt;String&gt; items; ChocolateMenu() &#123; this.name = \"巧克力菜單\"; items = new ArrayList&lt;&gt;(); this.init(); &#125; private void init() &#123; this.items.add(\"白巧克力\"); this.items.add(\"黑巧克力\"); this.items.add(\"酒釀巧克力\"); &#125; public void setMenuItem(String item) &#123; this.items.add(item); &#125; public void showMenuItem() &#123; for(String item: items) &#123; System.out.println(this.name + \":\" + item); &#125; &#125; public void print() &#123; System.out.println(\"開始介紹\" + this.name); &#125;&#125; 這時要修改服務生的腦袋，使其知道巧克力菜單的內容。。。 123456789101112131415class Waitress &#123; BuffetMenu buffetMenu; Waitress(BuffetMenu buffetMenu) &#123; this.buffetMenu = buffetMenu; &#125; public void introduceMenu() &#123; // 介紹菜單 this.buffetMenu.print(); this.buffetMenu.dessertMenu.print(); this.buffetMenu.dessertMenu.chocolateMenu.print(); &#125;&#125; 但這時候就會發現，每次若新增一個子菜單時，呼叫者就需要直接對其操作，才能夠印出該子菜單的項目列表 一但子菜單內又有子菜單，那整個程式碼的維護的代價就會非常的高 123可以看到子菜單內若又有子菜單，要印出該名稱的話，那這行程式碼會越來越長。。。this.buffetMenu.dessertMenu.chocolateMenu.print(); 維護修改的代價舉個例子，我們想要叫服務生說明，哪些菜/甜點是素食的，這時會改code改到想哭 解決服務生不用笨拙地存取菜單與其子菜單們：合成模式登場合成模式主要幫我們建立一個類別關係，建立起父類別與子類別的階層關係，並讓客戶端以一致的方式存取樹狀結構內的各個類別 先講結論，以上的菜單們，套用合成模式後，服務生不用透過以下方式存取子菜單並介紹出來了，而是直接可以用一致的方式將所有菜單與子菜單都呼叫出來1234567891011public void introduceMenu() &#123; // 介紹菜單 &lt;-- 可以不用一一在呼叫菜單與子菜單和子菜單的子菜單。。。 public void introduceMenu() &#123; // 介紹菜單 this.buffetMenu.print(); this.buffetMenu.showMenuItem(); this.buffetMenu.dessertMenu.print(); this.buffetMenu.dessertMenu.showMenuItem(); this.buffetMenu.dessertMenu.chocolateMenu.print(); this.buffetMenu.dessertMenu.chocolateMenu.showMenuItem(); &#125; 這時我們先來看 合成模式 的類別關係圖 Component類別：定義了其所有底下葉節點與合成類別的結構 所有的Leaf節點與Composite節點都會繼承(實作)該Component類別 Component是老大哥，老大哥會的下面的也會學到 Leaf類別：會實作Component類別，但由於Leaf節點沒有子類別，所以只會有operation()的方法供呼叫 Composite類別：合成類別，將以下兩點做合成 所要執行的功能operation() 管理子類別的方法 add() remove() getChild() 對應Composite類別關係圖到我們上述所畫的菜單關係圖，就會長得如下： 把上面所提到的這張圖作轉換 就會變成這樣子 (省略Chocolate類別的菜單項目) 定義MenuComponent抽象類別定義MenuComponent, 提供菜單基本的方法 這邊主要不是定義成Interface, 而是抽象類別的主要原因是因為，我們會給 子菜單去繼承菜單所具有的方法 但又因會給菜單項目(MenuItem)繼承(如 牛肉麵, 海鮮飯, 牛排)，但菜單項目不需要像是 add(), remove()等方法，所以會在該方法內先拋出 UnsupportedOperationException() Menu.java123456789101112131415161718192021222324252627282930313233abstract class MenuComponent &#123; void add(MenuComponent menuComponent) &#123; throw new UnsupportedOperationException(); &#125; void remove(MenuComponent menuComponent) &#123; throw new UnsupportedOperationException(); &#125; MenuComponent getChild(int i) &#123; throw new UnsupportedOperationException(); &#125; String getName() &#123; throw new UnsupportedOperationException(); &#125; String getDescription() &#123; throw new UnsupportedOperationException(); &#125; double getPrice() &#123; throw new UnsupportedOperationException(); &#125; boolean isVegetarian() &#123; throw new UnsupportedOperationException(); &#125; void print() &#123; throw new UnsupportedOperationException(); &#125;&#125; 可以看到我們定義了以下方法，並等待真正的菜單類別來實作其細節 add(): 可新增 實作MenuComponent的物件 remove(): 移除 實作MenuComponent的物件 getChild(): 取得Menu內的菜單項目/子菜單 getName(): 取得菜單名稱 getPrice: 取得菜單項目價格 isVegetarian(): 確認是否為素食 print(): 印出自己的所有菜單項目/子菜單內容 12345還記得最上面的若要請服務生確認菜色是否是素食，但要到處修改的慘痛的經驗嗎？這時候若在共通的介面，定義好一個isVegetarian(), 請菜色自行提供是否是素食，是的話回傳true, 不是就回傳false, 如此一來服務生就可以在呼叫print()時，可以直接判斷這道項目是否是素食囉關於print()的實現細節後面會介紹 開始實作菜單元件：定義自助式菜單接著開始實作自助餐的完整菜單吧！ BuffetMenu.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class BuffetMenu extends MenuComponent &#123; // 宣告要放置菜單項目與子菜單的ArrayList ArrayList&lt;MenuComponent&gt; menuItems = new ArrayList&lt;&gt;(); // 菜單名稱 String name; BuffetMenu() &#123; this.name = \"自助式菜單\"; &#125; @Override void add(MenuComponent menuComponent) &#123; this.menuItems.add(menuComponent); &#125; @Override void remove(MenuComponent menuComponent) &#123; this.menuItems.remove(menuComponent); &#125; @Override MenuComponent getChild(int i) &#123; return this.menuItems.get(i); &#125; @Override String getName() &#123; return this.name; &#125; @Override String getDescription() &#123; return \"自助式菜單提供了主菜們(牛肉麵, 海鮮飯, 牛排), 以及甜點菜單, 請盡情享用！\"; &#125; // 不用實作getPrice 因為菜單沒有價格 // 不用實作isVegetarian 因為菜單沒有價格 // 如果是菜單的話, print使用iterator, 將ArrayList型態的menus中的menuComponent一一取出來, 並呼叫 @Override void print() &#123; System.out.println(this.getName()); System.out.println(this.getDescription()); Iterator iterator = menuItems.iterator(); while(iterator.hasNext()) &#123; // 取出來的可能是菜單項目, 也可能是子菜單 MenuComponent menuComponent = (MenuComponent)iterator.next(); menuComponent.print(); &#125; &#125;&#125; 可以看到在BuffetMenu中，已經除了 getPrice()和isVegetarian()這兩項菜單不用去實作，其他都有定義邏輯 這邊要注意的是 print() 我們使用 iterator, 將菜單內的MenuComponent一一取出來，並且在呼叫其print(), 依序對自助式菜單內的菜單項目做介紹這樣 定義菜單項目接著我們定義一個牛肉麵類別 BeefNoodles, 實作 MenuComponent 123456789101112131415161718192021222324252627282930313233class BeefNoodles extends MenuComponent &#123; // 菜單名稱 String name; @Override String getName() &#123; return this.name; &#125; @Override String getDescription() &#123; return \"好吃的牛肉麵, 道地的四川口味～～\"; &#125; @Override double getPrice() &#123; return 120; &#125; @Override boolean isVegetarian() &#123; return false; // 牛肉麵不是素食 &#125; // 不是菜單, 所以只要呼叫名稱與描述就好 @Override void print() &#123; System.out.println(this.getName()); System.out.println(this.getDescription()); System.out.println(this.getPrice()); &#125;&#125; 由於牛肉麵是菜單的項目，所以只要實作跟他自己有關的方法就好，在print()也只要就印出自己名稱是什麼，以及描述, 價格。 實作子菜單: 甜點菜單跟剛剛實作自助餐的細節非常類似 DessertMenu.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class DessertMenu extends MenuComponent &#123; // 宣告要放置菜單項目與子菜單的ArrayList ArrayList&lt;MenuComponent&gt; menuItems = new ArrayList&lt;&gt;(); // 菜單名稱 String name; DessertMenu() &#123; this.name = \"甜點菜單\"; &#125; @Override void add(MenuComponent menuComponent) &#123; this.menuItems.add(menuComponent); &#125; @Override void remove(MenuComponent menuComponent) &#123; this.menuItems.remove(menuComponent); &#125; @Override MenuComponent getChild(int i) &#123; return this.menuItems.get(i); &#125; @Override String getName() &#123; return this.name; &#125; @Override String getDescription() &#123; return \"甜點菜單提供了一星米其林主廚所製作的甜點們！\"; &#125; // 不用實作getPrice 因為菜單沒有價格 // 不用實作isVegetarian 因為菜單沒有價格 // 如果是菜單的話, print使用iterator, 將ArrayList型態的menus中的menuComponent一一取出來, 並呼叫 @Override void print() &#123; System.out.println(this.getName()); System.out.println(this.getDescription()); Iterator iterator = menuItems.iterator(); while(iterator.hasNext()) &#123; // 取出來的可能是菜單項目, 也可能是子菜單 MenuComponent menuComponent = (MenuComponent)iterator.next(); menuComponent.print(); &#125; &#125;&#125; 最後也是一樣，將甜點項目都實作一輪，不過這邊都很類似就不敘述了 重新定義服務生可以看到服務生很快樂, 只要呼叫MenuComponent的print(), 就把所有菜單都介紹出來囉 123456789101112class Waitress &#123; MenuComponent menuComponent; Waitress(MenuComponent menuComponent) &#123; this.menuComponent = menuComponent; &#125; public void introduceMenu() &#123; // 這時只要呼叫print(), 就可以把全部菜單的項目與名稱都介紹出來了！ this.menuComponent.print(); &#125;&#125; 客戶開始進來，請服務生介紹1234567891011121314151617181920212223public class main &#123; public static void main(String[] args) &#123; MenuComponent buffetMenu = new BuffetMenu(); MenuComponent beefNoodles = new BeefNoodles(); MenuComponent seaRice = new SeaRice(); MenuComponent steak = new Steak(); buffetMenu.add(beefNoodles); buffetMenu.add(seaRice); buffetMenu.add(steak); // 定義子菜單 MenuComponent dessertMenu = new DessertMenu(); MenuComponent eggCookie = new EggCookie(); MenuComponent cottonCandy = new CottonCandy(); dessertMenu.add(eggCookie); dessertMenu.add(cottonCandy); // 將子菜單加入自助式菜單 buffetMenu.add(dessertMenu); Waitress waitress = new Waitress(buffetMenu); // 請服務生開始介紹！ waitress.introduceMenu(); &#125;&#125; 12345678910111213141516171819自助式菜單自助式菜單提供了主菜們(牛肉麵, 海鮮飯, 牛排), 以及甜點菜單, 請盡情享用！牛肉麵好吃的牛肉麵, 道地的四川口味～～120.0海鮮飯好吃的海鮮飯～～200.0牛排好吃的牛排～～400.0甜點菜單甜點菜單提供了一星米其林主廚所製作的甜點們！雞蛋餅乾雞蛋口味的餅單, 大人小孩都愛～～60.0棉花糖棉花糖好滋味～～30.0 小結透過合成模式, 將取得菜單與子菜單的動作給一致化了 服務生只要呼叫實作MenuComponent的菜單與子菜單們, 就可以一口氣將所有菜單與子菜單的項目們全都介紹出來！ 未來若要擴充子菜單的項目，也不用擔心需要再修改服務生的類別，只要新的菜單有實作MenuComponent就好 達到 “對修改關閉, 對擴充開放”的原則！ 將每個菜單的Iterator給合併起來: IteratorComposite還記得剛剛有提到如何判斷該菜單是否是素食的情況呢？？ (待續)","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"}]},{"title":"Iterator Pattern 反覆器模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Iterator-Pattern-反覆器模式","date":"2020-08-03T15:50:41.000Z","updated":"2021-01-28T12:17:35.127Z","comments":true,"path":"2020/08/03/Design-Pattern-Java-Iterator-Pattern-反覆器模式/","link":"","permalink":"http://a10000005588.github.io/2020/08/03/Design-Pattern-Java-Iterator-Pattern-反覆器模式/","excerpt":"將處理陣列或是取值方式的邏輯給封裝起來，不需讓使用者直接處理操作取值的邏輯","text":"將處理陣列或是取值方式的邏輯給封裝起來，不需讓使用者直接處理操作取值的邏輯 沒有Iterator Pattern的情況假設現在有2種菜單, 分別叫做中式料理菜單 與 西式料理菜單 中式料理菜單是用ArrayList的方式儲存菜單項目 美式料理菜單是用Array[]儲存 中式料理菜單1234567891011121314151617class ChineseMenu &#123; ArrayList&lt;String&gt; menu; ChineseMenu() &#123; this.setMenuItem(); &#125; public void setMenuItem() &#123; this.menu = new ArrayList&lt;&gt;(); this.menu.add(\"麻婆豆腐\"); this.menu.add(\"豬血糕\"); &#125; public ArrayList&lt;String&gt; getMenu() &#123; return menu; &#125;&#125; 美式料理菜單123456789101112131415161718class AmericanMenu &#123; String[] menu; AmericanMenu() &#123; this.menu = new String[3]; this.setMenuItem(); &#125; public void setMenuItem() &#123; this.menu[0] = \"漢堡\"; this.menu[1] = \"薯條\"; this.menu[2] = \"炸雞\"; &#125; public String[] getMenu() &#123; return menu; &#125;&#125; 接著定義一個類別：服務生，但服務生需要知道要怎麼撈內容, ArrayList與Array的撈法就會不一樣，要寫兩個for loop… 12345678910111213141516171819202122232425class Waitress &#123; ChineseMenu chineseMenu; AmericanMenu americaMenu; Waitress( ChineseMenu chMenu, AmericanMenu amerMenu ) &#123; this.chineseMenu = chMenu; this.americaMenu = amerMenu; &#125; // 這時候服務生需要針對各個menu做菜色介紹 public void introduceMenu() &#123; System.out.println(\"=======介紹中式料理========\"); for(String dish: chineseMenu.getMenu()) &#123; System.out.println(dish); &#125; System.out.println(\"=======介紹美式式料理========\"); for(int i=0; i&lt;americaMenu.getMenu().length; i++) &#123; System.out.println(americaMenu.menu[i]); &#125; &#125;&#125; 接著呼叫服務生，介紹菜單 123456789public class main &#123; public static void main(String[] args) &#123; ChineseMenu chineseMenu = new ChineseMenu(); AmericanMenu americanMenu = new AmericanMenu(); Waitress waitress = new Waitress(chineseMenu, americanMenu); waitress.introduceMenu(); &#125;&#125; 1234567=======介紹中式料理========麻婆豆腐豬血糕=======介紹美式式料理========漢堡薯條炸雞 問題可以看到服務生必須要了解如何從菜單取出來，變成每一次若又有新的菜單，那每次服務生又得曉得新菜單的取得方式是怎樣，如此一來就得一直增加for loop, 有N個菜單就有N個for loop, 不大好維護。 Iterator模式登場該模式主要目的：『讓服務生不需知道其取出細節是如何，只要透過一個標準的介面(Iterator)，就可以直接呼叫菜單內容』 定義 Iterator 介面1234interface Iterator&lt;T&gt; &#123; Boolean hasNext(); T next();&#125; 改良一下Menu 將各個Menu實作同一個介面1234567891011121314151617181920212223242526272829303132333435363738394041interface Menu&lt;T&gt; &#123; void setMenuItem(); T getMenu();&#125;class ChineseMenu implements Menu&lt;ArrayList&lt;String&gt;&gt; &#123; ArrayList&lt;String&gt; menu; ChineseMenu() &#123; this.setMenuItem(); &#125; public void setMenuItem() &#123; this.menu = new ArrayList&lt;&gt;(); this.menu.add(\"麻婆豆腐\"); this.menu.add(\"豬血糕\"); &#125; public ArrayList&lt;String&gt; getMenu() &#123; return menu; &#125;&#125;class AmericanMenu implements Menu&lt;String[]&gt; &#123; String[] menu; AmericanMenu() &#123; this.menu = new String[3]; this.setMenuItem(); &#125; public void setMenuItem() &#123; this.menu[0] = \"漢堡\"; this.menu[1] = \"薯條\"; this.menu[2] = \"炸雞\"; &#125; public String[] getMenu() &#123; return menu; &#125;&#125; 這時改用實作兩個Iterator類別 ChineseMenuIterator與AmericanMenuIterator，負責定義如何取出菜單內容 12345678910111213141516171819202122232425262728293031323334353637383940414243class ChineseMenuIterator implements Iterator&lt;String&gt; &#123; ArrayList&lt;String&gt; menu; int count = -1; public ChineseMenuIterator(Menu&lt;ArrayList&lt;String&gt;&gt; menu) &#123; this.menu = menu.getMenu(); &#125; // ChineseMenu是使用ArrayList定義菜單列表 public Boolean hasNext() &#123; if (count + 1 &gt;= menu.size()) &#123; return false; &#125; return true; &#125; public String next() &#123; count++; return this.menu.get(count); &#125;&#125;class AmericanMenuIterator implements Iterator&lt;String&gt; &#123; String[] menu; int count = -1; public AmericanMenuIterator(Menu&lt;String[]&gt; menu) &#123; this.menu = menu.getMenu(); &#125; public Boolean hasNext() &#123; if (count + 1 &gt;= menu.length) &#123; return false; &#125; return true; &#125; public String next() &#123; count++; return this.menu[count]; &#125;&#125; 這時回到服務生，若要介紹菜單內容的話，只要使用上面定義的 ChineseMenuIterator與AmericanMenuIterator, 就可以直接取出菜單項目內容了，服務生不需要在曉得要怎麼處理撈取的細節，看到一堆for loop了 Waitress class123456789101112131415161718192021222324252627282930class Waitress &#123; ChineseMenu chineseMenu; AmericanMenu americaMenu; ChineseMenuIterator chineseMenuIterator; AmericanMenuIterator americanMenuIterator; Waitress( ChineseMenu chMenu, AmericanMenu amerMenu, ChineseMenuIterator chineseMenuIterator, AmericanMenuIterator americanMenuIterator ) &#123; this.chineseMenu = chMenu; this.americaMenu = amerMenu; this.chineseMenuIterator = chineseMenuIterator; this.americanMenuIterator = americanMenuIterator; &#125; // 這時候服務生只要透過iterator, 就可以直接用一個for loop全部取出來 public void introduceMenu() &#123; System.out.println(\"=======介紹中式料理========\"); while(chineseMenuIterator.hasNext()) &#123; System.out.println(chineseMenuIterator.next()); &#125; System.out.println(\"=======介紹美式料理========\"); while(americanMenuIterator.hasNext()) &#123; System.out.println(americanMenuIterator.next()); &#125; &#125;&#125; 再度呼叫服務生介紹菜單 Main class123456789101112131415public class main &#123; public static void main(String[] args) &#123; ChineseMenu chineseMenu = new ChineseMenu(); ChineseMenuIterator chineseMenuIterator = new ChineseMenuIterator(chineseMenu); AmericanMenu americanMenu = new AmericanMenu(); AmericanMenuIterator americanMenuIterator = new AmericanMenuIterator(americanMenu); Waitress waitress = new Waitress( chineseMenu, americanMenu, chineseMenuIterator, americanMenuIterator); waitress.introduceMenu(); &#125;&#125; 小結透過Iterator介面定義如何實作抽取資料結構的內容，讓使用者可以不用費心去了解要怎麼取得，直接呼叫已經有實作Iterator介面的class 備註Collection 類別中其實就已經定義了Iterator介面，不過為了介紹反覆器模式，故在ArrayList中簡單實作了Iterator介面內容 Reference: https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"}]},{"title":"Template Pattern 樣板模式  [Design Pattern in Java]","slug":"Design-Pattern-Java-Template-Pattern-樣板模式","date":"2020-07-29T15:33:47.000Z","updated":"2021-01-28T12:17:59.406Z","comments":true,"path":"2020/07/29/Design-Pattern-Java-Template-Pattern-樣板模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/29/Design-Pattern-Java-Template-Pattern-樣板模式/","excerpt":"樣板, 顧名思義就是把同樣的邏輯定義成一個樣板, 可讓其他類別共同使用 樣板也會開放可客製化的方法 (抽象方法), 供其他類別實作","text":"樣板, 顧名思義就是把同樣的邏輯定義成一個樣板, 可讓其他類別共同使用 樣板也會開放可客製化的方法 (抽象方法), 供其他類別實作 樣板主要核心 將共同演算法邏輯包裝好 定義非共同的方法為抽像方法, 請使用樣板方法的類別自行實作 透過泡茶與泡咖啡來瞭解樣板模式吧這時候若直接寫code, 會分別定義出 Tea 與 Coffee class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Tea &#123; Tea() &#123;&#125; public void prepare() &#123; System.out.println(\"=======開始準備茶的動作=======\"); boilWater(); steepTeaBag(); addLenmon(); pourIntoCup(); System.out.println(\"=======結束=======\"); &#125; private void boilWater() &#123; System.out.println(\"燒開水\"); &#125; private void steepTeaBag() &#123; System.out.println(\"泡開茶包\"); &#125; private void addLenmon() &#123; System.out.println(\"加入檸檬\"); &#125; private void pourIntoCup() &#123; System.out.println(\"倒入杯中\"); &#125;&#125;class Coffee &#123; Coffee() &#123;&#125; public void prepare() &#123; System.out.println(\"=======開始準備咖啡的動作=======\"); boilWater(); greedCoffeeGrinds(); addCreamer(); pourIntoCup(); System.out.println(\"=======結束=======\"); &#125; private void boilWater() &#123; System.out.println(\"燒開水\"); &#125; private void greedCoffeeGrinds() &#123; System.out.println(\"磨咖啡豆\"); &#125; private void addCreamer() &#123; System.out.println(\"加奶精\"); &#125; private void pourIntoCup() &#123; System.out.println(\"倒入杯中\"); &#125;&#125; 使用以上定義的方法 123456789public class main &#123; public static void main(String[] args) &#123; Tea tea = new Tea(); tea.prepare(); Coffee coffee = new Coffee(); coffee.prepare(); &#125;&#125; 套用Template Pattern吧仔細比較泡茶和泡咖啡, 都會有著以下類似的動作 煮沸開水 將(茶的茶包/咖啡藥磨成粉)泡開 &lt;– 這個動作一樣, 但茶是用茶包, 咖啡是需要先磨成粉 添加有的沒的 (咖啡會用奶精/茶會放檸檬) &lt;– 這邊的也是一樣 倒進杯中 剛好茶與咖啡都是含有咖啡因的飲料，這時就可以定義一個樣板叫做 CaffeineBeverage, 並把上述 2,3步驟,定義成抽象方法, 讓茶與咖啡類別自己去實作自己的邏輯 12345678910111213141516171819202122232425262728abstract class CaffeineBeverage &#123; String name = \"咖啡因飲料\"; CaffeineBeverage(String name) &#123; this.name = name; &#125; public void prepare() &#123; System.out.println(\"=======開始準備 \" + this.name + \" 的動作=======\"); boilWater(); brew(); addCondiments(); pourIntoCup(); System.out.println(\"=======結束=======\"); &#125; private void boilWater() &#123; System.out.println(\"燒開水\"); &#125; // 定義如何泡的抽象方法, 讓茶與咖啡自行定義 abstract void brew(); // 定義要添加其他配料, 讓茶與咖啡自行定義 abstract void addCondiments(); private void pourIntoCup() &#123; System.out.println(\"倒進杯中\"); &#125;&#125; 接著Tea與Coffee實現該樣板類別 CaffeineBeverage並根據自己的邏輯實作abstract方法 brew()與addCondiments() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Tea extends CaffeineBeverage &#123; Tea(String name) &#123; super(name); &#125; public void prepare() &#123; System.out.println(\"=======開始準備茶的動作=======\"); boilWater(); brew(); addCondiments(); pourIntoCup(); System.out.println(\"=======結束=======\"); &#125; @Override void brew() &#123; System.out.println(\"泡開茶包\"); &#125; @Override void addCondiments() &#123; System.out.println(\"加入檸檬\"); &#125;&#125;class Coffee extends CaffeineBeverage&#123; Coffee(String name) &#123; super(name); &#125; public void prepare() &#123; System.out.println(\"=======開始準備咖啡的動作=======\"); boilWater(); brew(); addCondiments(); pourIntoCup(); System.out.println(\"=======結束=======\"); &#125; @Override void brew() &#123; System.out.println(\"磨咖啡豆\"); &#125; @Override void addCondiments() &#123; System.out.println(\"加奶精\"); &#125;&#125; 接著一樣使用之 123456789public class main &#123; public static void main(String[] args) &#123; CaffeineBeverage tea = new Tea(\"茶\"); tea.prepare(); CaffeineBeverage coffee = new Coffee(\"咖啡\"); coffee.prepare(); &#125;&#125; 小結透過以上方法可以看到 樣板模式 將重複的地方給統整起來成為演算法邏輯, 並定義一個抽象類別, 將需要客製化的部分定義成抽象方法, 統一的部分就直接定義實體方法 如此一來各個類別在實作時，就不用在自己去做重複一樣的動作(例如燒開水, 倒入杯中) 只要直接繼承樣板抽象類別就有囉, 然後在自己實作自己需要的部分 (如茶有自己的茶包泡法, 咖啡則有自己的咖啡豆要磨 才能泡) 以實現樣板模式的精神 透過hook方法將封裝的演算法邏輯部分做控制使用待補充","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"}]},{"title":"Facade Pattern 表象模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Facade-Pattern-表象模式","date":"2020-07-29T12:20:24.000Z","updated":"2021-01-28T12:17:26.218Z","comments":true,"path":"2020/07/29/Design-Pattern-Java-Facade-Pattern-表象模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/29/Design-Pattern-Java-Facade-Pattern-表象模式/","excerpt":"將複雜的類別關係, 用一個類別包裝起來, 供呼叫 不會讓使用者直接看到背後複雜的邏輯, 只會看到 “表面的現象”, 故叫做表象模式","text":"將複雜的類別關係, 用一個類別包裝起來, 供呼叫 不會讓使用者直接看到背後複雜的邏輯, 只會看到 “表面的現象”, 故叫做表象模式 以一個家庭劇院來解說如果坐在客廳, 想要營造一個家庭劇院 我們得做以下事情： 打開燈, 調整亮度 打開電視, 切換到DVD模式 打開音響, 調整大小聲 打開DVD, 讀取要看的片 等等之類的, 以下定義這些服務的class 12345678910111213141516171819202122232425262728293031class LightService &#123; LightService() &#123;&#125; public void lightOn() &#123; System.out.println(\"Turn on the light\"); &#125;&#125;class TVService &#123; TVService() &#123;&#125; public void openTV() &#123; System.out.println(\"Turn on the TV\"); &#125;&#125;class SoundService &#123; SoundService() &#123;&#125; public void openSound() &#123; System.out.println(\"Turn on the Sound\"); &#125;&#125;class DVDPlayerService &#123; DVDPlayerService() &#123;&#125; public void openDVD() &#123; System.out.println(\"Turn on the DVD\"); &#125;&#125; 然後直覺上會呼叫之 1234567891011121314public class main &#123; public static void main(String[] args) &#123; LightService lightService = new LightService(); TVService tvService = new TVService(); SoundService soundService = new SoundService(); DVDPlayerService dvdPlayerService = new DVDPlayerService(); lightService.lightOn(); tvService.openTV(); soundService.openSound(); dvdPlayerService.openDVD(); &#125;&#125; 其結果為： 表象模式登場不過對於使用者來說, 其實就只想要享受家庭劇院的娛樂, 所以其實我們可以用包裝的方式, 將上面main裡面相關服務的class都包在一個class內, 叫做MovieTheaterFacadeService 12345678910111213141516class MovieTheaterFacadeService &#123; MovieTheaterFacadeService() &#123;&#125; public void startMovieTheaterService() &#123; LightService lightService = new LightService(); TVService tvService = new TVService(); SoundService soundService = new SoundService(); DVDPlayerService dvdPlayerService = new DVDPlayerService(); lightService.lightOn(); tvService.openTV(); soundService.openSound(); dvdPlayerService.openDVD(); &#125;&#125; 如此一來, 我們的使用者(main()), 只要呼叫 MovieTheaterFacadeService 就可以直接享受家庭劇院, 不用親自去處理過程中的事 1234567public class main &#123; public static void main(String[] args) &#123; MovieTheaterFacadeService movieTheaterFacadeService = new MovieTheaterFacadeService(); movieTheaterFacadeService.startMovieTheaterService(); &#125;&#125; 總結透過以上的例子, 可以看到表象模式最大的用處就是將複雜的服務類別們給包裝在一起, 並開放單一個類別供使用者使用, 讓使用者僅需要看到表面即可, 不用理解細節是什麼。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"}]},{"title":"Adaptor Pattern 轉接器模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Adaptor-Pattern-轉接器模式","date":"2020-07-29T00:15:30.000Z","updated":"2021-01-28T12:17:17.461Z","comments":true,"path":"2020/07/29/Design-Pattern-Java-Adaptor-Pattern-轉接器模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/29/Design-Pattern-Java-Adaptor-Pattern-轉接器模式/","excerpt":"假如要使用A, 但無法直接使用, 只能使用B介面 所以我們用轉接器類別包裝A的方法，並且實作B，達到轉接的效果","text":"假如要使用A, 但無法直接使用, 只能使用B介面 所以我們用轉接器類別包裝A的方法，並且實作B，達到轉接的效果 用螢幕轉接器的例子直接解釋例如我們有個 HDMI的線, 叫做 HDMI interface 12345interface HDMI &#123; // 定義連接裝置的方法格式 boolean connect(String device);&#125; 但現在有個螢幕只有支援VGA的插孔 所以我們需要個 HDMI轉VGA的Adaptor類別, 把VGA的類別引入進來, 並使用之 12345678910111213141516class HdmiToVgaAdpator implements HDMI &#123; VGA vgaCable = null; HdmiToVgaAdpator(VGA vgaCable) &#123; this.vgaCable = vgaCable; &#125; // 必須要實作HDMI的方法 public boolean connect(String device) &#123; // 介接Vga線的connect功能 System.out.println(\"使用轉接器的connect功能!\"); vgaCable.connect(device); return true; &#125;&#125; 因為有使用到VGA類別, 所以來定義一下 123456789101112interface VGA &#123; // 定義連接裝置的方法格式 boolean connect(String device);&#125;class VGACable implements VGA &#123; public boolean connect(String device) &#123; System.out.println(\"VGA線連接: \" + device); return true; &#125;&#125; 來定義有台筆電, 是只有具備hdmi孔, 但具備著可以連接到某裝置進行投影 1234567class Labtop &#123; // 該台筆電只有hdmi孔, 並指定要連接的螢幕(device) public void connectToDevice(HDMI hdmi, String device) &#123; System.out.println(\"筆電只有hdmi孔, 使用實作hdmi介面的 'hdmi轉vga的轉接器' 類別！\"); hdmi.connect(device); &#125;&#125; 接著來使用吧 1234567891011public class main &#123; public static void main(String[] args) &#123; Labtop laptop = new Labtop(); // 如果某筆電只有hdmi插孔, 但要接的投影螢幕只有vga laptop.connectToDevice( new HdmiToVgaAdpator( // 這時可以使用Hdmi轉Vga的轉接器！ 轉接器需要帶入實際具有VGA功能的VGA線物件 new VGACable()), \"老舊投影機\"); &#125;&#125; 我們可以看到結果為: 筆電使用了 實作hdmi介面的轉接器 (轉接器因為實作了hdmi interface, 所以可以插入筆電的hdmi孔) 接著轉接器引入了VGA cable類別, 故轉接器就可以使用VGA的connect()功能 最後就觸發VGA功能, 與投影裝置連動 實際應用場景通常轉接器模式可用在轉接那些已經過時的模組&amp;方法 例如有模組是用Java較舊迭代Collection的版本去寫的, 為Enumeration Interface 但現在新的專案中，是使用Iterator方式去迭代Collection 12345678910class NewLoopService &#123; // 使用Java 5版本之後支援的Iterator public void loopCollection(Collection col, Iterator itr) &#123; itr = col.iterator(); while(itr.hasNext()) &#123; System.out.println(itr.next()); &#125; &#125;&#125; 使用NewLoopService12345678910111213class main() &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"apple\"); list.add(\"banana\"); // 宣告Iterator的變數 Iterator itr; NewLoopService loopService = new NewLoopService(); loopService.loopCollection(list, itr); &#125;&#125; 但現在若只能用舊版的 Enumeration 方式去迭代 這時就可以寫一個 EnumeratorAdaptor 來實作可兼容Iterator的類別, 並可呼叫 Enumeration的方法 1234567891011121314151617181920212223// 實作Iterator的方法class EnumeratorAdaptor&lt;E&gt; implement Iterator &#123; Enumeration&lt;E&gt; enumeration; EnumeratorAdaptor(Enumeration&lt;E&gt; enumeration) &#123; this.enumeration = enumeration; &#125; // 實作Iterator 介面所需的方法 public boolean hasNext() &#123; // 但實際上是使用Enumeration的方法 return this.enumeration.hasMoreElements(); &#125; public Object next() &#123; return this.enumeration.nextElement(); &#125; // 但這時候會遇到Enumeration沒有的方法, 但又必須要實作 滿足Iterator的介面規範, 這時可以throw Exception來處理 public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125; 這時我們可以在main()中改用轉接器, 來間接使用Enumeration了！ 1234567891011121314151617181920212223242526class main() &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"apple\"); list.add(\"banana\"); // 使用 `實作Iterator介面` 的轉接器 EnumeratorAdaptor itr; NewLoopService loopService = new NewLoopService(); loopService.loopCollection(list, itr); &#125;&#125;class NewLoopService &#123; // 使用Java 5版本之後支援的Iterator public void loopCollection(Collection col, Iterator itr) &#123; itr = col.iterator(); // 這時會是使用EnumeratorAdaptor內的hasNext()與next() 達到轉接的效果 while(itr.hasNext()) &#123; System.out.println(itr.next()); &#125; &#125;&#125; 透過以上方法, 可以把要使用Enumeration方式的service, 但該Service又是只能吃Iterator的輸入, 那就可以實作一個 EnumeratorAdaptor, 帶入Service, 並透過轉接器使用 Enumeration的方式去撈出Collection內容.","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"}]},{"title":"Observer Pattern 觀察者模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Observer-Pattern-觀察者模式","date":"2020-07-26T08:59:48.000Z","updated":"2021-01-28T12:17:41.422Z","comments":true,"path":"2020/07/26/Design-Pattern-Java-Observer-Pattern-觀察者模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/26/Design-Pattern-Java-Observer-Pattern-觀察者模式/","excerpt":"觀察者模式可以讓物件了解資料變化的情況。物件甚至可以在執行期間決定是否要繼續被通知，又或者是可以主動去詢問資料的狀態。在此模式中也會了解一對多，以及物件鬆綁的意義是如何。","text":"觀察者模式可以讓物件了解資料變化的情況。物件甚至可以在執行期間決定是否要繼續被通知，又或者是可以主動去詢問資料的狀態。在此模式中也會了解一對多，以及物件鬆綁的意義是如何。 以氣象監測系統的概況來當做例子假設系統中有三個組成要件：(1) 氣象站: 獲取實際氣象的物理裝置，假設有三個:溫度,濕度,壓力感應(2) Weather Data物件: 追蹤來自氣象站的資料，並且顯示在佈告版上(3) 佈告版: 將Weather Data物件給予的資料呈現出來 整個例子會有，一個氣象站(產出假的氣象資料)，Weather Data物件(獲取氣象資料並通知佈告版)，佈告版將拿到的資料給呈現出來 沒使用觀察者模式 Observer Pattern的情況初學者會很直覺的寫出這樣的程式架構： 佈告欄CurrentConditionsDisplay.class123456789101112131415161718public class CurrentConditionsDisplay &#123; private int temp; private int humidity; private int pressure; public void update() &#123; this.temp = temp; this.humidity = humidity; this.pressure = pressure; &#125; // 顯示資料 public void display() &#123; System.out.println(temp); System.out.println(humidity); System.out.println(pressure); &#125;&#125; WeatherData.class1234567891011121314151617181920212223242526272829303132public class WeatherData &#123; // instance variable declarations // 宣告佈告欄 CurrentConditionsDisplay currentConditionsDisplay; StatisticsDisplay statisticsDisplay; // 建構子 public WeatherData( CurrentConditionsDisplay currentConditionsDisplay, StatisticsDisplay statisticsDisplay ) &#123; this.currentConditionsDisplay = currentConditionsDisplay; this.statisticsDisplay = statisticsDisplay; &#125; public int getTemperature() &#123;...&#125; public int getHumidity() &#123;...&#125; public int getPressure() &#123;...&#125; public void measurementsChanged() &#123; float temp = getTemperature(); float humidity = getHumidity(); float pressure = getPressure(); // 對佈告欄類別進行更新他們的顯示內容 currentConditionsDisplay.update(temp, humidity, pressure); statisticsDisplay.update(temp, humidity, pressure); // 其他WeatherData function... &#125;&#125; 但是以上程式結構會有耦合性的狀況： 所以接下來來了解觀察者模式的內涵 觀察者模式解析定義了物件之間一對多關係，如此一來，當一個物件改變狀態時，其他相依者都會收到通知並自動做改變 其示意圖如下： 主題與觀察者們定義了一對多的關係 若要實踐出可以隔離主題和觀察者們的方式，以 Subject介面和Observer介面最為常見 在這張圖要注意一個重點是，由於現在已經針對介面實作，現在的Subject中的註冊Observer都是以註冊”介面“為主！而非是像上面一開始的新手例子是直接針對實踐而寫 如此一來如果要在新增一個佈告欄叫做ForecastDisplay，直接實踐Observer就好，這樣就不用動到實踐Subject介面的WeatherData之程式碼 以觀察者模式來重寫氣象監測系統Subject.interface 12345public interface Subject &#123; void registerObserver(Observer o); void removeObserver(Observer o); void notifyObservers();&#125; ObserverInterface 123public interface Observer &#123; void update(float temperature, float humidity, float pressure);&#125; WeatherData.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.ArrayList;public class WeatherData implements Subject&#123; private ArrayList observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList(); &#125; public void registerObserver(Observer o) &#123; int i = observers.indexOf(o); observers.add(o); &#125; public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if(i&gt;=0) &#123; observers.remove(i); &#125; &#125; // 向觀察者們送以改動的資料 // 可以看到現在我們是直接註冊Observer介面，如此一來觀察者類別的實作就不用去在意 // 只要知道要註冊的對象必須要有實作Observer介面就好 public void notifyObservers() &#123; for(int i=0; i&lt;observers.size(); i++) &#123; Observer observer = (Observer)observers.get(i); observer.update(temperature, humidity, pressure); &#125; &#125; // 執行向觀察者們通知資料 public void measurementsChanged() &#123; notifyObservers(); &#125; // 讀取假資料，可以改動這地方，改為向氣象局網站爬資料 public void setMeasurements( float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125;&#125; 這裡我們只實踐一個佈告欄 CurrentConditionDisplay CurrentConditionDisplay.java12345678910111213141516171819202122public class CurrentConditionDisplay implements Observer &#123; private float temperature; private float humidity; private float pressure; private Subject weatherData; public CurrentConditionDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; public void update(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; display(); &#125; public void display() &#123; System.out.println(\"Current condition: \"+temperature + \"F degrees and \" + humidity + \"% humidity and \"+ pressure + \" pressure\"); &#125;&#125; 執行程式 12345678910public class Main &#123; public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); CurrentConditionDisplay currentDisplay = new CurrentConditionDisplay(weatherData); weatherData.setMeasurements(80, 64, 30.4f); &#125;&#125; 可以看到以下結果 1Current condition: 80.0F degrees and 64.0% humidity and 30.4 pressure 之後只要透過主題呼叫觀察者的update()的方法，就可以通知新的資料給觀察者 並且透過註冊的方式+只加入針對實踐Observer介面的觀察者，如此一來可以達到分離主題物件與觀察者物件的邏輯，之後新增新的佈告欄就不用動到主題的程式邏輯。 補充java sdk也有自行提供Observer方法其中會有setChange()的方法，主要讓呼叫者定義什麼時候才要通知新的資料給觀察者，避免每次資料一改變就一直通知觀察者。Ex: 如果沒有setChanged的方法，WeahterData物件就會持續不斷的通知觀察者，所以若我們希望溫度差距半度才更新，溫度差距插到半度以上，主題才會呼叫觀察者的update()的方法。 12345678910111213141516setChanged() &#123; changed = ture;&#125;notifyObservers(Object arg) &#123; if(changed) &#123; for every observer on the list &#123; call update(this. org) &#125; changed = false; &#125;&#125;notifyObsergers() &#123; notifyObservers(null);&#125;","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"}]},{"title":"Strategy Pattern 策略模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Strategy-Pattern-策略模式","date":"2020-07-26T08:58:12.000Z","updated":"2021-01-28T12:17:55.339Z","comments":true,"path":"2020/07/26/Design-Pattern-Java-Strategy-Pattern-策略模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/26/Design-Pattern-Java-Strategy-Pattern-策略模式/","excerpt":"可以在執行期動態更換物件的行為 『策略模式』定義了演算法家族，將他們個別封裝起來，可以讓他們之間互相替換，此模式不會影響到使用此演算法的程式。","text":"可以在執行期動態更換物件的行為 『策略模式』定義了演算法家族，將他們個別封裝起來，可以讓他們之間互相替換，此模式不會影響到使用此演算法的程式。 沒有思考使用設計模式的時候:模擬鴨子版本假設我們要開發模擬鴨子遊戲，會有各種不同的鴨子，這時候會們通常都會先設計出一個class叫做 Duck，然後Duck會包含鴨子的共同行為：發出叫聲 quack(), 游泳 swin(), 以及展現外觀 display()，然後有綠頭鴨 MallardDuck class和 紅頭鴨 RedheadDuck class分別繼承 Duck類別 (做UML) 若現在需要讓每隻鴨子都會飛，我們會很直覺的在 Duck class中加入 fly() 但若現在有個橡皮鴨子，會不小心繼承到Duck class的fly(), 但橡皮鴨不會飛！ 用繼承的可以改善作法直接在橡皮鴨 class中的fly() 不定義任何事情 (做UML) 問題若又遇到誘餌鴨，就會面臨fly()沒定義任何事情，quack()也沒定義任何事情因為若有很多新型態的鴨子，會導致每一個不同的鴨子都得檢視該鴨子是否可飛或可叫 (做UML) 改用介面做改善將fly與quack從Duck抽離出來變成 Flyable與Quackable介面，讓有需要飛或叫的鴨子實作之 問題重複的程式碼會變超多，因為同樣會飛或叫的鴨子都各自實作了Flyable與Quackable介面的程式碼，該程式碼邏輯都是相同的。 設計守則(一) 找出程式中需要更動之處，並將之獨立出來，不要和那些不需要更動的程式碼混在一起 把會變動的部分取出來並將之封裝起來，以便以後可以輕易地擴充此部分，而不影響不需要更動的部分。 將鴨子的行為從Duck類別取出來！ 抽離會變動的部分成為獨立類別將飛行行為 fly,與呱呱叫行為 quack獨立成class 並且在Duck類別設置 “可以設定行為的方法”，可以在“執行期”動態地改變鴨子的飛行或呱呱叫行為 設計守則(二)寫程式是針對介面而寫，而不是針對實踐 用介面代表每個行為: FlyBehavior, QuackBehavior用各個鴨子的行為類別去實踐FlyBehavior和QuackBehavior介面而不是由Duck類別實踐該介面 :::info寫程式是針對介面去寫：其真正意思是『寫程式是針對超型態(supertype)而寫』 使用超型態的話可以不用理會以後執行時的真正物件型態：為“多型”的實踐 ex: Animal interface { makeSound() }Dog implment Animal { makeSound() { bark() }}Cat implement Animal { makeSound() { meow() }} Animal animal = new Dog();animal.makeSound(); 有個好處是，可以不用直接在一開始僵化某個變數的宣告型態 ex: Dog x = new dog(); // 僵化了x變數為dog型態 而是可以在執行期，也就是使用的時候指定該物件型態 ex: 1234567// 定義getAnimal為回傳Dog();x = getAnimal(); // 得到 Dog型態x.makeSound(); // 發出狗叫聲// 將getAnimal() 中改成傳回Cat();x = getAnimal(); // 得到 Cat型態x.makeSound(); // 發出貓叫聲 ::: 實踐鴨子的行為 FlyBehavior介面，用FlyWithWings(實踐所有有翅膀的鴨子會飛的行為)與FlyNoWay(實踐所有不會飛的鴨子的動作)這兩個類別來實作 QuackBehavior介面，用Quack(真的呱呱叫)、Squeak(橡皮吱吱叫)與MuteQuack(叫不出聲音)這三個類別來實作 1以上設計將飛行與呱呱叫的行為可以被其他物件再三利用，將鴨子的行為抽離出來 問題與思考 是否該先把系統做出來，在看看哪些地方需要更動，再回頭將需更動的邏輯獨立出來？ 答：不儘然，設計系統中可以預先考慮到未來哪些地方可能需要變動 鴨子是不是也可以設計成一個介面？ 答: 不恰當，因為已經將會變動的邏輯(fly與quack)抽離出dock class, 那dock class就可以直接為每隻鴨子都會有同樣邏輯的類別，讓不同類型的鴨子直接繼承使用 整合鴨子的行為將飛行與呱呱叫的動作，委託其他人處理 (在Dock類別中宣告 FlyBehavior與QuackBehavior，透過Behavior介面取得 有實作該Behavior介面的行為們 ex: FlyBehavior介面會有FlyWithNoWings類別實作) 123456789101112public class Duck &#123; FlyBehavior flyBehavior; QuackBehavior quackBehavior; public void performQuack() &#123; quackBehavior.quack(); &#125; public void performFly() &#123; flyBehavior.fly(); &#125;&#125; 現在由綠頭鴨(MallarDuck)來使用Duck的quackBehavior所擁有的有實踐自己的子類別 Quack()用flyBehavior的FlyWithNoWings 且MallarDuck繼承了Duck類別，所以可以使用quackBehavior和flyBehavior取用自己對應的動作12345678910public class MallardDuck extends Duck &#123; // constructor pubilc MallardDuck() &#123; quackBehavior = new Quack(); flyBehavior = new FlyWithNoWings(); &#125; quackBehavior.performQuack(); flyBehavior.performFly();&#125; 完整測試的code：實作一個MiniDuckDuck class12345678910111213141516171819public abstract class Duck &#123; FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck() &#123;&#125; public abstract void display(); public void performFly() &#123; flyBehavior.fly(); &#125; public void performQuack() &#123; quackBehavior.quack(); &#125; public void swim() &#123; System.out.println(\"All ducks float, even decoys!\"); &#125;&#125; FlyBehavior and QuackBehavior介面與實踐之的動作FlyBehavior.inrface123public interface FlyBehavior &#123; void fly();&#125; 各種實踐Fly的類別 FlyWithWings.java12345public class FlyWithWings implements FlyBehavior &#123; public void fly() &#123; System.out.println(\"I am flying\"); &#125;&#125; FlyNoWay.java12345public class FlyNoWay implements FlyBehavior &#123; public void fly() &#123; System.out.println(\"I cannot fly\"); &#125;&#125; QuackBehavior.java123public interface QuackBehavior &#123; public void quack();&#125; 各種實踐Quack的類別 Quack.java12345public class Quack implements QuackBehavior &#123; public void quack() &#123; System.out.println(\"Quack\"); &#125;&#125; MuteQuack.java12345public class MuteQuack implements QuackBehavior &#123; public void quack() &#123; System.out.println(\"&lt;&lt;Silence&gt;&gt;\"); &#125;&#125; Squeak.java12345public class Squeak implements QuackBehavior &#123; public void quack() &#123; System.out.println(\"Squeak\"); &#125;&#125; 實踐綠頭鴨的類別：MallardDuck.java1234567891011public class MallardDuck extends Duck &#123; // constructor public MallardDuck() &#123; quackBehavior = new Quack(); flyBehavior = new FlyWithWings(); &#125; public void display() &#123; System.out.println(\"I am a real Mallard duck\"); &#125;&#125; 測試用類別：MiniDuckSimulator.java12345678910public class MiniDuckSimulator &#123; public static void main(String[] args) &#123; Duck mallard = new MallardDuck(); // 會呼叫 MallardDuck繼承來的performQuack() // 進而委託 quackBehavior處理quack行為，而非在自己class內處理 mallard.performQuack(); mallard.performFly(); &#125;&#125; 動態設定行為在鴨子類別中可以加入設置flyBehavior和quackBehavior的方法 可以隨時呼叫以下方法改變鴨子的行為12345678910public abstract class Duck &#123;... public void setFlyBehavior(FlyBehavior fb) &#123; flyBehavior = fb; &#125; public void setQuackBehavior(QuackBehavior qb) &#123; quackBehavior = qb; &#125;&#125; 例如有個 “模型鴨“ 12345678910public class ModelDuck extends Duck &#123; public ModelDuck() &#123; flyBehavior = new FlyNoWay(); quackBehavior = new Quack(); &#125; public void display() &#123; System.out.println(\"Model duck\"); &#125;&#125; 建立一個新的FlyBehavior型態，具有火箭噴射的功能 12345public class FlyRocketPowered implements FlyBehavior &#123; public void fly() &#123; System.out.println(\"I am flying a rocket\"); &#125;&#125; 改變測試類別，加上模型鴨子，使模型鴨具有火箭動力！ 123456789101112131415public class MiniDuckSimulator &#123; public static void main(String[] args) &#123; Duck mallard = new MallardDuck(); ... /** * 具有噴射動力的模型鴨子 */ Duck modelDuck = new ModelDuck(); modelDuck.performFly(); // 不會飛 // 動態地更換飛行的行為 modelDuck.setFlyBehavior(new FlyRocketPowered()); modelDuck.performFly(); // 噴射！ &#125;&#125; 以上的行為為將兩個類別(FlyBehavior與QuackBehavior)組合起來使用，為”Composition 合成”的精神，與繼承不一樣的是，鴨子Duck的行為不是繼承而來，而是透過適當的行為物件『合成』而來！ 設計守則多用合成，少用繼承 合成可以將演算法封裝成類別，更可以『在執行動態地改變行為』，只要合成的行為物件，符合特定的介面標準即可","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"}]},{"title":"Factory Pattern 工廠模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Factory-Pattern-工廠模式","date":"2020-07-26T08:57:20.000Z","updated":"2021-01-28T12:17:31.169Z","comments":true,"path":"2020/07/26/Design-Pattern-Java-Factory-Pattern-工廠模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/26/Design-Pattern-Java-Factory-Pattern-工廠模式/","excerpt":"工廠模式提供了可創建(new)各種不同類別(class)的實例(instance) 工廠模式主要又涵蓋了 (1) 簡單工廠模式 Simple Factory Pattern (2) 工廠方法模式 (3) 抽象方法模式 簡單工廠方法是最初階的用法，會違反OOP的Open-close principle(OCP)然而工廠方法和抽象方法則比較能讓模組間耦合度降低。 以下會依序做介紹","text":"工廠模式提供了可創建(new)各種不同類別(class)的實例(instance) 工廠模式主要又涵蓋了 (1) 簡單工廠模式 Simple Factory Pattern (2) 工廠方法模式 (3) 抽象方法模式 簡單工廠方法是最初階的用法，會違反OOP的Open-close principle(OCP)然而工廠方法和抽象方法則比較能讓模組間耦合度降低。 以下會依序做介紹 簡單工廠模式 Simple Factory Method簡單工廠模式僅提供一個工廠類別，接收參數(決定生產哪種產品)，來產生出對應的產品物件(Object) 以生產Pizza為例，假設我們有個披薩簡單工廠(SimplePizzaFactory)可以生產兩種不同口味的Pizza(Cheese和Potato): SimplePizzaFactory.java 123456789101112public class SimplePizzaFactory &#123; public Pizza createPizza(String type) &#123; Pizza pizza = null; if(type.equals(\"cheese\")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals(\"potato\")) &#123; pizza = new PotatoPizza(); &#125; return pizza; &#125;&#125; 工廠會回傳抽象的Pizza類別 Pizza.java1234567891011121314151617public abstract class Pizza &#123; String name; String ingridient; void prepare() &#123; System.out.println(\"Preparing\" + name); System.out.println(\"Ingredient\" + ingridient); &#125; void bake() &#123; System.out.println(\"Bake for 20 mins\"); &#125; String getName() &#123; return name; &#125;&#125; 以及實作了兩個口味的披薩 CheesePizza和PotatoPizza CheesePizza.java12345public class CheesePizza extends Pizza &#123; String name = \"CheesePizza\"; String ingridient = \"Cheese\";&#125; PotatoPizza.java1234public class PotatoPizza extends Pizza &#123; String name = \"PotatoPizza\"; String ingridient = \"Potato\";&#125; Pizza都定義完畢後，定義SimplePizzaFactory.java SimplePizzaFactory.java123456789101112131415161718public class SimplePizzaFactory &#123; public void orderPizza(String type) &#123; Pizza pizza = null; pizza = createPizza(type); pizza.prepare(); pizza.bake(); &#125; public Pizza createPizza(String type) &#123; Pizza pizza = null; if(type.equals(\"cheese\")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals(\"potato\")) &#123; pizza = new PotatoPizza(); &#125; return pizza; &#125;&#125; 在Main.java透過SimplePizzaFactory製作兩個Pizza: Main.java123456789public class Main &#123; public static void main(String[] args) &#123; SimplePizzaFactory simplePizzaFactory = new SimplePizzaFactory(); simplePizzaFactory.orderPizza(\"cheese\"); simplePizzaFactory.orderPizza(\"potato\"); &#125;&#125; 執行Main.java 123456Preparing: CheesePizzaIngredient: CheeseBake for 20 minsPreparing: PotatoPizzaIngredient: PotatoBake for 20 mins 但此若之後要擴充Pizza的種類，例如要多一個叫做OnionPizza，勢必得修改SimplePizzaFacotory.java SimplePizzaFactory.java1234567891011121314151617181920public class SimplePizzaFactory &#123; public void orderPizza(String type) &#123; Pizza pizza = null; pizza = createPizza(type); pizza.prepare(); pizza.bake(); &#125; public Pizza createPizza(String type) &#123; Pizza pizza = null; if(type.equals(\"cheese\")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals(\"potato\")) &#123; pizza = new PotatoPizza(); &#125; else if (type.equals(\"onion\")) &#123; // 新增洋蔥口味pizza pizza = new OnionPizza(); &#125; return pizza; &#125;&#125; :::danger上述做法破壞了OOD的OCP(Open-Close Principle)的原則，亦即進行擴充時不修改到SimplePizzaFactory的程式碼。::: 工廠方法模式為了改善簡單工廠模式，工廠方法模式透過”抽象方法”的模式，讓之後擴充的工廠實作該”抽象方法”，以進行其他類別的擴充 舉例：有個PizzaFactory負責定義了Pizza工廠該做的一件事(抽象方法)叫做 createPizza(); PizzaFactory.java 12345678910public abstract class PizzaFactory &#123; public void orderPizza(String type) &#123; Pizza pizza = null; pizza = createPizza(type); pizza.prepare(); pizza.bake(); &#125; abstract Pizza createPizza(String type);&#125; 原本我們已經有兩種口味(Cheese和Potato) Pizza，叫做原味披薩(OriginalPizzaFactory), 使OringinalPizzaFactory去實作PizzaFactory的createPizza()方法 OringinalPizzaFactory.java123456789101112public class OriginalPizzaFactory extends PizzaFactory &#123; public Pizza createPizza(String type) &#123; Pizza pizza = null; if(type.equals(\"cheese\")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals(\"potato\")) &#123; pizza = new PotatoPizza(); &#125; return pizza; &#125;&#125; 若要新增洋蔥口味的Pizza的話，那就直接在定義一個額外的工廠叫做，特別披薩工廠 (SpecialPizzaFactory)進行擴充，如此一來就不用更動到到原本原味披薩工廠(OriginalPizzaFactory)的程式碼 SpecialPizzaFactory.java123456789public class SpecialPizzaFactory extends PizzaFactory &#123; public Pizza createPizza(String type) &#123; Pizza pizza = null; if(type.equals(\"onion\")) &#123; pizza = new OnionPizza(); &#125; return pizza; &#125;&#125; 記得多新增一個洋蔥披薩的類別 OnionPizza.java123456public class OnionPizza extends Pizza &#123; public OnionPizza() &#123; name = \"OnionPizza\"; ingridient = \"Onion\"; &#125;&#125; 在Main.java中呼叫原味和特別口味的披薩 Main.java1234567891011public class Main &#123; public static void main(String[] args) &#123; PizzaFactory originalPizzaFactory = new OriginalPizzaFactory(); originalPizzaFactory.orderPizza(\"cheese\"); originalPizzaFactory.orderPizza(\"potato\"); PizzaFactory specialPizzaFactory = new SpecialPizzaFactory(); specialPizzaFactory.orderPizza(\"onion\"); &#125;&#125; 透過下面的圖可以看到，透過定義一個抽象方法的工廠，若要擴充產品(在這裡我們用的是Pizza)類別的話，透過實作該抽象方法工廠，來進行擴充。 由於我們亦把Pizza類別給獨立出來成為一個抽象類別，若要新增其他口味的Pizza也可以達到不違反OCP精神的擴充，如下圖所示： 抽象工廠抽象工廠顧名思義就是定義一個抽象介面工廠，欲擴充的話就實作該抽象介面工廠 以披薩原料工廠(PizzaIngredientFactory)為例，有醬料和蔬菜兩種原料：方面給之後我們要製作的中式和美式披薩的原料實作，做擴展： PizzaIngredientFactory.java1234public interface PizzaIngredientFactory &#123; public Sauce createSauce(); public Vegetable createVegetable();&#125; 抽象工廠(原料工廠)在透過工廠方法來製作原料產品我們再分別產生美式版本(AmericaIngredientFactory)和中式版本(ChinesePizzaFactory)的披薩原料工廠，可以看到使用了createSauce和createVegetable，透過工廠方法來產生原料產品 AmericaIngredientFactory.java12345678public class AmericaIngredientFactory implements PizzaIngredientFactory &#123; public Sauce createSauce() &#123; return new TomatoSauce(); &#125; public Vegetable createVegetable() &#123; return new Potato(); &#125;&#125; ChineseIngredientFactory.java12345678public class ChineseIngredientFactory implements PizzaIngredientFactory &#123; public Sauce createSauce() &#123; return new SoySauce(); &#125; public Vegetable createVegetable() &#123; return new Onion(); &#125;&#125; 接著定義剛剛原料工廠有使用到的原料類別們(Sauce: SoySauce與PotatoSauce; Vegetable: Onion和Potato，該原料亦在實作Pizza類別的具體類別亦會用到 :::infoPizza.java123456789public abstract class Pizza &#123; String name; // 在Pizza類別中已經有宣告會用到的原料有哪些，是以介面來實作，方便做擴展 Sauce sauce; Vegetable vegetable; ...&#125; ::: 定義醬料Sauce原料們： Sauce.java12345public abstract class Sauce &#123; String name; public abstract String getSauce();&#125; SoySauce.java12345678910public class SoySauce extends Sauce &#123; public SoySauce() &#123; name = \"soy sauce\"; &#125; public String getSauce() &#123; System.out.println(\"The sauce is :\" + name); return this.name; &#125;&#125; TomatoSauce.java1234567891011public class TomatoSauce extends Sauce &#123; public TomatoSauce() &#123; name = \"tomato sauce\"; &#125; public String getSauce() &#123; System.out.println(\"The sauce is :\" + name); return this.name; &#125;&#125; 接下來換定義Vegetable原料們 Vegetable.java12345public abstract class Vegetable &#123; String name; public abstract String getVegetable();&#125; Onion.java123456789public class Onion extends Vegetable &#123; public Onion() &#123; name = \"onion\"; &#125; public String getVegetable() &#123; System.out.println(\"The vegetable is :\" + name); return this.name; &#125;&#125; Potato.java1234567891011public class Potato extends Vegetable &#123; public Potato() &#123; name = \"potato\"; &#125; public String getVegetable() &#123; System.out.println(\"The vegetable is :\" + name); return this.name; &#125;&#125; 將披薩修改成包含上述原料 (Sauce和Vegetable) Pizza.java123456789101112131415161718192021public abstract class Pizza &#123; String name; Sauce sauce; Vegetable vegetable; // 將prepare修改成抽象，該方法需要收集Pizza所需的原料，原料來自於原料工廠！ public abstract void prepare(); public void bake() &#123; System.out.println(\"Bake for 30 mins\"); &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 定義兩個style的Pizza: 中式披薩(Chinese Pizza)和美式披薩(America Pizza)，在這兩隻類別可以看到我們傳入了原料工廠，以決定哪種風格的披薩就用對應風格的原料工廠 ChinesePizza.java1234567891011121314151617public class ChinesePizza extends Pizza &#123; PizzaIngredientFactory ingredientFactory; public ChinesePizza(PizzaIngredientFactory ingredientFactory) &#123; this.ingredientFactory = ingredientFactory; &#125; public void prepare() &#123; System.out.println(\"Preparing: \" + name); sauce = ingredientFactory.createSauce(); sauce.getSauce(); vegetable = ingredientFactory.createVegetable(); vegetable.getVegetable(); &#125;&#125; AmericaPizza.java123456789101112131415161718public class AmericaPizza extends Pizza &#123; PizzaIngredientFactory ingredientFactory; public AmericaPizza(PizzaIngredientFactory ingredientFactory) &#123; this.ingredientFactory = ingredientFactory; &#125; public void prepare() &#123; System.out.println(\"Preparing: \" + name); sauce = ingredientFactory.createSauce(); sauce.getSauce(); vegetable = ingredientFactory.createVegetable(); vegetable.getVegetable(); &#125;&#125; 接著再利用工廠方法，定義中式和美式的披薩工廠，製作出中式和美式的披薩 PizzaFactory.java12345678910public abstract class PizzaFactory &#123; public void orderPizza(String type) &#123; Pizza pizza = null; pizza = createPizza(type); pizza.prepare(); pizza.bake(); &#125; abstract Pizza createPizza(String type);&#125; AmericaPizzaFactory.java123456789101112131415public class AmericaPizzaFactory extends PizzaFactory &#123; protected Pizza createPizza(String style) &#123; Pizza pizza = null; // 使用了美式原料工廠 PizzaIngredientFactory ingredientFactory = new AmericaIngredientFactory(); if(style.equals(\"America\")) &#123; pizza = new AmericaPizza(ingredientFactory); pizza.setName(\"America style pizza\"); &#125; return pizza; &#125;&#125; :::info可以在對美式工廠新增其他種不同口味的Pizza，用不同的原料工廠來達成::: ChinesePizzaFactory.java123456789101112131415public class ChinesePizzaFactory extends PizzaFactory &#123; protected Pizza createPizza(String style) &#123; Pizza pizza = null; // 使用了中式原料工廠 PizzaIngredientFactory ingredientFactory = new ChineseIngredientFactory(); if(style.equals(\"Chinese\")) &#123; pizza = new ChinesePizza(ingredientFactory); pizza.setName(\"Chinese style pizza\"); &#125; return pizza; &#125;&#125; 最後在Main.java中來製作披薩： Main.java1234567891011public class Main &#123; public static void main(String[] args) &#123; PizzaFactory AmericaPizzaFactory = new AmericaPizzaFactory(); AmericaPizzaFactory.orderPizza(\"America\"); PizzaFactory ChinesePizzaFactory = new ChinesePizzaFactory(); ChinesePizzaFactory.orderPizza(\"Chinese\"); &#125;&#125; 可以看到抽象工廠方法可以幫我們把相關產品集結起來(上述例子為原料們)，可以產生出不同組的原料類別們，另外抽象工廠通常還會再搭配工廠方法，來建立其產品(披薩們，各個披薩會用到各個不同的抽象工廠所建立的原料工廠)，如同該連結所做的-&gt;連結在透過工廠方法來製作原料產品)","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"}]},{"title":"Singleton Pattern 獨體模式 [Design Pattern in Java]","slug":"Design-Pattern-Java-Singleton-Pattern-獨體模式","date":"2020-07-26T08:56:27.000Z","updated":"2021-01-28T12:24:58.355Z","comments":true,"path":"2020/07/26/Design-Pattern-Java-Singleton-Pattern-獨體模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/26/Design-Pattern-Java-Singleton-Pattern-獨體模式/","excerpt":"每次引用類別都只會產出相同的物件 適合用在: 執行緒池(thread pool)，快取區(cache)，對話盒、處理對話設定和登錄的物件，和驅動程式溝通的物件。","text":"每次引用類別都只會產出相同的物件 適合用在: 執行緒池(thread pool)，快取區(cache)，對話盒、處理對話設定和登錄的物件，和驅動程式溝通的物件。 作法假如有一個類別叫做MyClass，現在要讓MyClass變成獨體模式，讓外面的類別只能透過 MyClass.getInstance() 取得MyClass物件。 12345678910111213141516public class MyClass &#123; // 設定成private與static，不能給外面類別存取 private static MyClass uniqueInstance; // 將建構式設定成 private，這樣就可以避免直接被類別 new出來 private MyClass() &#123;&#125; // 設置成static，使外面類別可以直接存取MyClass.getInstance方法 public static MyClass getInstance() &#123; // 若第一次取得MyClass， new 出MyClass(); if(uniqueInstance == null) &#123; uniqueInstance = new MyClass(); &#125; return uniqueInstance; &#125;&#125; 其他類別要取用MyClass 12345678910public static void main(String args[]) &#123; // 1. 第一次取用getInstance Myclass instance = MyClass.getInstance(); // 2. 第二次取用getInstance時，MyClass的uniqueInstance已經有值了，得到與上面instance一樣的object Myclass instance1 = MyClass.getInstance(); if(instance == instance1) &#123; System.out.println(&quot;instance and instance1 are the same&quot;); &#125;&#125; 多執行緒下獨體模式會遇到的狀況假如有兩個thread(thread 1和thread 2)，同時要跟MyClass取得物件，但會面臨thread1和thread2會取得不同的MyClass物件，情況如下： 解法一：只要把getInstance()給同步化 (會有效能不佳的狀況，可能造成效率下降100倍)12345678910111213public class MyClass &#123; private static MyClass uniqueInstance; private MyClass() &#123;&#125; // 設定成synchronized，就可以讓執行緒依序進入getInstance內 public static synchronized MyClass getInstance() &#123; if(uniqueInstance == null) &#123; uniqueInstance = new MyClass(); &#125; return uniqueInstance; &#125;&#125; 但我們只需要第一次進入getInstance才進行同步化就好，不然其他次要取得uniqueInstnace都得變成同步的方式，造成取用Instance的緩慢 解法二：率先建立實體，不要等到有人呼叫getInstance才new出MyClass實體1234567891011public class MyClass &#123; // 直接初始話MyClass()，並設成private private static MyClass uniqueInstnace = new MyClass(); private MyClass() &#123;&#125; public static MyClass getInstance() &#123; return uniqueInstance; &#125; &#125; 此作法依賴JVM載入此類別時，馬上建立此唯一的獨體物件，JVM保證在任何執行緒存取uniqueInstnace靜態變數之前，一定先建立此實體 解法三：利用 “雙重檢查上鎖” 在getInstance()中減少使用同步化利用雙重檢查上鎖，首先檢查是否實體已經建立了，若沒有，“才”進行同步化，如此一來只有第一次進入getInstance才同步化，才是我們所想要的。 `java=public class MyClass { // volatile為Java 6之後才有的關鍵字，能夠使執行緒們取得相同的uniqueInstance private volatile static MyClass uniqueInstance; private MyClass() {} public static MyClass getInstance() { // 只有第一次才徹底執行以下程式碼 // 當執行緒遇到被宣告成volatile的uniqueInstnace，會變得謹慎 if(uniqueInstance == null) { synchronized(MyClass.class) { // 再檢查一次，若為null則new MyClass(); if(uniqueInstance == null) { uniqueInstance = new MyClass(); } } } return uniqueInstance; } }","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"}]},{"title":"Command Pattern 命令模式 [Design Pattern in Java]","slug":"Design-Pattern-Command-Pattern-命令模式","date":"2020-07-26T08:52:42.000Z","updated":"2021-01-28T12:17:01.716Z","comments":true,"path":"2020/07/26/Design-Pattern-Command-Pattern-命令模式/","link":"","permalink":"http://a10000005588.github.io/2020/07/26/Design-Pattern-Command-Pattern-命令模式/","excerpt":"命令模式主要將執行的命令, 與執行者做鬆綁的動作","text":"命令模式主要將執行的命令, 與執行者做鬆綁的動作 沒有命令模式會是怎樣的寫法？？假如我們現在要寫一個 遙控器 RemoteControl (執行者), 上面會有很多按鈕功能 (命令) 每個按鈕可能都對應各個功能, 例如 打開, 關閉某些房間的燈 於是我們定義了 Light 抽象類別, 有著 on()與off()開關燈的方法, 並且實作了 LivingRoomLight, KitchenLight這兩個房間並繼承 Light抽象類別的方法, 使他們都有開關的功能！ 接著在遙控器 RemoteControl類別內定義了 Light[] 陣列, 儲存欲執行的功能 (實作Light的類別們) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class main &#123; public static void main(String[] args) &#123; // 定義出一個遙控器instance RemoteControl remoteControl = new RemoteControl( new Light[]&#123; new LivingRoomLight(), new KitchenLight() &#125;); // 0: 打開LivingRoom Light // 1: 打開Kitchen Light remoteControl.turnOnLight(0); remoteControl.turnOnLight(1); // 0: 關閉LivingRoom Light // 1: 關閉Kitchen Light remoteControl.turnOffLight(0); remoteControl.turnOffLight(1); &#125;&#125;class RemoteControl &#123; Light[] lights = new Light[10]; RemoteControl(Light[] lights) &#123; // 將傳進來的lights放入到lights內 for(int i=0; i&lt;lights.length; i++) &#123; this.lights[i] = lights[i]; &#125; &#125; public void turnOnLight(int buttonNumber) &#123; this.lights[buttonNumber].on(); &#125; public void turnOffLight(int buttonNumber) &#123; this.lights[buttonNumber].off(); &#125;&#125;abstract class Light &#123; Light() &#123;&#125; abstract void on(); abstract void off();&#125;class LivingRoomLight extends Light &#123; LivingRoomLight() &#123;&#125; @Override public void on() &#123; System.out.println(\"Turn on the living room light\"); &#125; @Override public void off() &#123; System.out.println(\"Turn off the living room light\"); &#125;&#125;class KitchenLight extends Light &#123; KitchenLight() &#123;&#125; @Override public void on() &#123; System.out.println(\"Turn on the kitchen light\"); &#125; @Override public void off() &#123; System.out.println(\"Turn off the kitchem light\"); &#125;&#125; 執行結果如下 問題假如現在又想要添加電視與冷氣開關的功能 TV, AirConditioner, 那不就又要在RemoteControl類別內進行修改 12345678910111213141516171819202122class RemoteControl &#123; // 又新增了HomeDevice陣列...定義家具集合的類別 HomeDevice[] homeDevices = new HomeDevice[10]; Light[] lights = new Light[10]; RemoteControl(Light[] lights) &#123; // 將傳進來的lights放入到lights內 for(int i=0; i&lt;lights.length; i++) &#123; this.lights[i] = lights[i]; &#125; &#125; public void turnOnLight(int buttonNumber) &#123; this.lights[buttonNumber].on(); &#125; public void turnOffLight(int buttonNumber) &#123; this.lights[buttonNumber].off(); &#125; // 又在定義HomeDevice的開關功能...&#125; 可看到每次若要為遙控器類別新增功能, 都要對RemoteControl進行修改的動作, 如此一來可能會造成其他已經內嵌好的功能可能被改壞的狀況發生, 這時我們可以使用 Command 模式 來避免這種狀況發生 Command 命令模式的優勢命令模式可以幫我們把要賦予RemoteControl的這些功能給封裝起來, 成為一個獨立的個體, 不會跟RemoteControl給耦合再一起 (像上面turnOnLight, turnOffLight等功能) 我們可以把 Light 的開關功能都視作為 Command (命令)抽象介面, 該介面包含了一個 execute()功能, 接著由Command (命令)衍伸出 LightOnCommand與LightOffCommand這兩個實作類別, 負責定義Light的開與關的動作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 定義一個命令, 包含的執行execute的動作 */interface Command &#123; void execute();&#125;/** * 實作燈的開關命令 */class Light &#123; void on() &#123; System.out.println(\"Turn on the light\"); &#125;; void off() &#123; System.out.println(\"Turn off the light\"); &#125;;&#125;class LightOnCommand implements Command &#123; Light light; LightOnCommand() &#123; this.light = new Light(); &#125; public void execute() &#123; light.on(); &#125;&#125;class LightOffCommand implements Command &#123; Light light; LightOffCommand() &#123; this.light = new Light(); &#125; public void execute() &#123; light.off(); &#125;&#125;class NoCommand implements Command &#123; NoCommand() &#123;&#125; public void execute() &#123; System.out.println(\"Not yet defined\"); &#125;&#125; 接著我們需要在遙控器類別 RemoteControl 定義可放置Command的動作 setXXXCommand(), 以及呼叫Command的 pressOnButton()與pressOffButton() 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 定義遙控器類別 */class RemoteControl &#123; Command[] onCommands = new Command[7]; Command[] offCommands = new Command[7]; // 初始化一開始的插槽, 若沒功能就定義一個沒作用的command供呼叫 (可避免用 if (command != null) 這種判斷方式 RemoteControl() &#123; for(int i=0; i&lt;7; i++) &#123; onCommands[i] = new NoCommand(); offCommands[i] = new NoCommand(); &#125; &#125; public void setOnCommand(int slot, Command onCommand) &#123; this.onCommands[slot] = onCommand; &#125; public void setOffCommand(int slot, Command offCommand) &#123; this.offCommands[slot] = offCommand; &#125; public void pressOnButton(int slot) &#123; this.onCommands[slot].execute(); &#125; public void pressOffButton(int slot) &#123; this.offCommands[slot].execute(); &#125; // 顯示我們塞了哪些功能到slot內 public String toString() &#123; StringBuffer stringBuff = new StringBuffer(); stringBuff.append(\"\\n ------- Remote Control-------\\n\"); for (int i=0; i &lt; onCommands.length; i++) &#123; stringBuff.append(\"[slot \" + i + \"] \" + onCommands[i].getClass().getName() + \" \" + offCommands[i].getClass().getName() + \"\\n\"); &#125; return stringBuff.toString(); &#125;&#125; 透過這樣的做法, 我們可以看到原本RemoteControl內的與Light操作有關的動作, 都被我們透過 Command 抽象介面以及其 LightOnCommand與LightOffCommand實作類別給抽離出來了 於是我們可以來執行看看 123456789101112131415161718192021222324252627public class main &#123; public static void main(String[] args) &#123; RemoteControl remoteControl = new RemoteControl(); // 定義出兩種房間的燈 Light LivingRoomLight = new Light(\"Living Room\"); Light KitchenLight = new Light(\"Kitchen\"); // 設置Command按鈕 remoteControl.setOnCommand(0, new LightOnCommand(LivingRoomLight)); remoteControl.setOffCommand(0, new LightOffCommand(LivingRoomLight)); remoteControl.setOnCommand(1, new LightOnCommand(KitchenLight)); remoteControl.setOffCommand(1, new LightOffCommand(KitchenLight)); // 顯示有哪些功能 System.out.println(remoteControl.toString()); // 執行命令 //// 客廳的 remoteControl.pressOnButton(0); remoteControl.pressOffButton(0); //// 廚房的 remoteControl.pressOnButton(1); remoteControl.pressOffButton(1); &#125;&#125; 若接下來需要新增如浴室開關, 電視開關, 只要透過RemoteConrol的setCommand()方法, 即可以動態做設置, 不需更動到遙控器類別原本的程式碼！ (除非要改變遙控器的slot大小了) 進階的Command Pattern技巧等待補充 (為Command介面新增 undo()方法, 使動作復原) 應用場景運用在任務序列中, 多執行緒只要拿到Command物件, 並且執行execute方法負責執行完就好 或是用在日誌管理, 將執行過的動作給記錄起來, 並且若後續伺服器當機, 可將命令給復原","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://a10000005588.github.io/tags/Design-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"}]},{"title":"下班自修的經驗分享","slug":"下班自修的經驗分享","date":"2020-05-16T12:47:39.000Z","updated":"2021-01-28T12:13:44.948Z","comments":true,"path":"2020/05/16/下班自修的經驗分享/","link":"","permalink":"http://a10000005588.github.io/2020/05/16/下班自修的經驗分享/","excerpt":"最近剛好在Backend版上看到有人Po文問說: “下班後要如何精進自修”, 意外看到許多大大們在下面留言, 正好最近我也在思考要如何精進自己, 所以趁這機會來統整一下大大們提出來的想法並且與自己目前的進修方式做結合, 主要會以Full-Stack engineer的精進方式來做個紀錄分享.","text":"最近剛好在Backend版上看到有人Po文問說: “下班後要如何精進自修”, 意外看到許多大大們在下面留言, 正好最近我也在思考要如何精進自己, 所以趁這機會來統整一下大大們提出來的想法並且與自己目前的進修方式做結合, 主要會以Full-Stack engineer的精進方式來做個紀錄分享. 如果對某程式語言&amp;框架掌握度還不夠, 請先熟悉之！如果上班接觸到某種自己不熟悉的語言或框架, 像我目前需要寫Java &amp; Spring, 與Angular &amp; Typescript. 所以我會偏好先到線上程式語言線上平台進修之, 因為這些學習平台能夠提供完整的學習輪廓, 能夠讓我快速掌握該程式語言&amp;框架所需具備的硬知識為何. 說到線上程式學習平台, 我蠻推薦 Pluralsight, 因為該平台提供了該程式語言或框架推薦學習的影片, 並且透過測驗推估你對該技術的知識程度為何. 有興趣可以到該平台試試看, 不過每個月會收取29美元的花費, 不過這花費當作投資是蠻值得的. 若已經對程式語言&amp;框架有經驗, 可以嘗試看看Side Project為什麼會特地提到Side Project?? 那是因為在公司其實很難自己能夠負責專案的所有全貌, 例如可能只是負責寫API, 也可能只負責前端頁面的刻畫. 所以透過Side Project, 便能夠有機會嘗試所有技術的機會, 並且從中去體會到自己最想要加強的領域是哪邊, 例如後端效能? 前端渲染速度? Container, CI/CD的運作? 諸如此類, 從而培養一個Full-Stack的經驗. 所以下班後自己跑一個Side Project是個不錯的精進方式. 但要怎麼樣想出一個Side Project?我覺得學習最快的方式就是模仿, 可以到Github上搜尋有興趣的專案, 並且試著用自己的程式語言與框架自己做出一套是最快的方式. 像我因為很喜歡用Markdown方式來做筆記, 目前打算自己做個小型的線上筆記編輯系統, 並看到Github上有提供CodiMD 的開源專案可參考,來試著自己建造出一個看看. 之後有機會再分享到自己的部落格上怎麼一步一步進行的. 嘗試撰寫線上筆記或部落格吧我認為現在技術真的太多太多了, 如果沒有將自己看過的技術文章或學習影片給消化和記錄起來, 很快就又會忘記. 所以最好的方式是有個做筆記的習慣! 做筆記的話我都是用Hackmd先記錄起來, 之後等有空的時間會再消化審視自己寫過的內容, 並發佈到自己的Bloger上, 這樣有助於將學習過的知識給內化到自己的腦海中. 其他更進階的進修方法根據技能樹(RoadMap)來補充自己最常用,有興趣但所缺乏的觀念與技術這網站Roadmap提供了各開發者(Frontend, Backend, DevOps)所需要具備的技能樹為何, 若想要往後端精進, 可以看到下面這張圖會碰到哪些所需具備的能力. 看完之後會發覺有太多東西需要Cover了, 學海無涯 (茶). 經營 Stackoverflow這點是我看到大大們提出來可以嘗試的方式, 不過我目前也只有在Stackoverflow上面問幾個小問題, 對這方面還沒有涉略, 可參考下面大大所寫的Stackoverflow的介紹, 未來我會想在這邊嘗試看看能不能也試著回答別人遇到的問題. 工程師鍛鍊接軌世界的能力從stackoverflow 開始 - 阿貝好威的實驗室 小結下班後要再自修真的需要有興趣使然以及強大的毅力, 否則很容易就會半途而廢. 所以最重要的還是要讓自己有個規劃, 並且從實踐規劃中內化成自己的日常習慣, 久而久之就會讓自己變得更強的！","categories":[{"name":"Life","slug":"Life","permalink":"http://a10000005588.github.io/categories/Life/"}],"tags":[{"name":"Mindset","slug":"Mindset","permalink":"http://a10000005588.github.io/tags/Mindset/"}]},{"title":"Spring Security 功能介紹","slug":"Spring-Security介紹","date":"2020-04-11T13:34:23.000Z","updated":"2020-08-03T14:32:05.404Z","comments":true,"path":"2020/04/11/Spring-Security介紹/","link":"","permalink":"http://a10000005588.github.io/2020/04/11/Spring-Security介紹/","excerpt":"Spring Security 功能介紹先介紹以下常用認證功能","text":"Spring Security 功能介紹先介紹以下常用認證功能 User name / password 基本認證使用使用者名稱/密碼做驗證 SSO / Okta / LDAPSSO (Single Sign On)為OAuth的近一步實現，若已經透過Google取得token, 就可以在其他服務的小網站，都使用Google提供的身份驗證服務 Okta協助非營利組織的方式。從基本的單一登入（single sign-on，簡稱為 SSO）到進階的身份認證和存取權限的管理方案 LDAP (Lightweight Directory Access Protocol)為一種輕量的目錄服務協定，像是通訊錄一樣紀錄人員資訊，可以拿來做帳號整合,驗證。 LDAP目錄服務通常有層級結構，像是公司組織階層 OAuth (Intra App Authorization)OAuth讓用戶可以授權第三方網站存取他們在另外服務提供者(ex: Facebook, Line)的某些特定資訊，而非所有內容。 為什麼有OAuth出現？因為各個網站都做會員機制很麻煩，且小網站可能有資安風險。 故大網站像是Facebook, Line早已經做好超級安全的會員管理機制，大網站幫你管理個資，提供登入的服務。 但提供這樣服務的大廠越來越多，若小網站同時要提供用戶連結到多個有提供身分服務的大網站會變得很複雜，於是就訂定的工業標準：OAuth. 功能 進入小網站 -&gt; 跳轉到大網站登入畫面 -&gt; 登入成功大網站給予一個有時效的token 給小網站 -&gt; 小網站透過token跟大網站索取用戶的資訊 (這也是為什麼每次登入第三方都會詢問你是否要揭露以下資訊給小網站) 不過一般小網站”無法”直接取得token, 而是取得一個code, 再用這個code向大網站換得一個token(多這道手續的原因是因為，Internet可能會被路上經手的router或其他設備擷取,偽造,變更) 實際情況在 Line Login時, Line Notify中，組出一個URL，取得Authorization Code, 這一段取得的Code為明碼, 走的是http get，透過瀏覽器網址列來傳遞 (若沒有用SSL傳遞的話，會被任何人擷取看到). 接下來小網站取得Authorization Code後，在透過http post，從後端跟大網站換得token (因為走後端 大網站就知道小網站的身份和所拿的code) :::warningOAuth主要功能是授權，不是認證，所以後來才延伸出OpenID Connect (OIDC)來提供認證用。::::::infoAuthentication 檢查發送檢查人的身份是誰、是否合格;Authorization 則是規範使用者權限的規則，規定哪些能做、哪些不能 因此如果該 Request 未帶 token 或是 token 過期、不合法皆算是 Authentication Error ，跟 http status code 的 401 意思一樣 ; 如果 Request 的 token 認證成功但是該使用者的權限不足以執行該 Request 則是 Forbidden Error (即 因 Authorization 發生的錯誤) ，如 http status code 的 403 意思相同。 ::: :::success單純用大網站的OAuth當自己的會員系統還是有很大的問題最明顯的是當使用者同時有Google 與 Facebook的帳號時兩個帳號上面的Email可能不是一樣的自己的網站很可能無法辨認這是同一個人的帳戶所以一般還是會需要自己的會員系統做整合::: Microservice security (using tokens, JWT)JWT (JSON web token): JWT基於JSON的開放標準 (RFC 7519) 被用在身份提供者和服務提供者間傳遞，被認證的用戶身份訊息 可額外增加聲明訊息，該JWT token可以直接被用於認證(Authorization)，也可被加密 特別適用於SSO JWT 與 Session差別：Session:由於http協議為stateless,無法知道每次request是誰，但每次request若都要帳號密碼很麻煩 故用戶第一次發Request時，就產生一組token紀錄在db與session, 並將token給用戶，告訴用戶將token存在cookie，當下次發送request時，透過token證明自己身份。 JWT組成內容有三個部分(Header, Paylaod,Signature)並由. 做區隔，最後透過這三個部分，串成一個 Jwt 字串 Header: 1234&#123; &apos;typ&apos;: &apos;JWT&apos;, # 聲明類型 &apos;alg&apos;: &apos;HS256&apos; # 加密的方法: HMAC、SHA256、RSA 進行 Base64 編碼&#125; Payload: 放聲明內容，可以說就是存放溝通訊息的地方 在定義上有 3 種聲明 (Claims) Reserved (註冊聲明) Public (公開聲明) Private (私有聲明) 註冊聲明參數 (建議但不強制使用) iss (Issuer) - jwt簽發者 sub (Subject) - jwt所面向的用戶 aud (Audience) - 接收jwt的一方 exp (Expiration Time) - jwt的過期時間，這個過期時間必須要大於簽發時間 nbf (Not Before) - 定義在什麼時間之前，該jwt都是不可用的 iat (Issued At) - jwt的簽發時間 jti (JWT ID) - jwt的唯一身份標識，主要用來作為一次性token,從而迴避重放攻擊 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;iat&quot;: 1516239022&#125; Signature: 由三個部分組成 header (base64後的) payload (base64後的) secret 1HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), &apos;secret&apos;) :::warningsecret 要保存在 server 端，jwt 的 簽發驗證都必須使用這個 secret，當其他人得知這個 secret，那就意味著客戶端是可以自我簽發 jwt ，因此在任何場景都不應該外流::: 最後將 Header, Payload, Signature做base64編碼，組成 使用的時候，在reqeust的header加上 Authorization: Bearer &lt;token&gt; 12345post(&apos;api/user/1&apos;, &#123; headers: &#123; &apos;Authorization&apos;: &apos;Bearer &apos; + token &#125;&#125;) JWT 前後端互動示意圖 JWT優點 跨語言，因為 json 格式大部分語言都可使用 可儲存一些簡單但非敏感的商業邏輯 - role .. 構成內容簡單，佔用 Size 小方便傳輸 !!! 不需在 server 保存 session，所以它易於應用的擴展 Spring Security 教學視頻Spring Boot + Spring Security + JWT from scratch - Java Brainshttps://www.youtube.com/watch?v=X80nJ5T7YpE 參考資源：Okta 如何協助非營利組織-從 25 個免費的授權開始https://www.techsoup-taiwan.org.tw/okta LDAP 簡介https://poychang.github.io/ldap-introduction/ 一次搞懂OAuth與SSO在幹什麼?http://studyhost.blogspot.com/2017/01/oauthsso.html GraphQL 設計： Autentication 與 Authorization 大全https://ithelp.ithome.com.tw/articles/10208278 JSON Web Token(JWT) 簡單介紹https://mgleon08.github.io/blog/2018/07/16/jwt/ What is Spring Security really all about? Java Brains Brain Bytes https://www.youtube.com/watch?v=sm-8qfMWEV8&amp;list=PLqq-6Pq4lTTYTEooakHchTGglSvkZAjnE","categories":[{"name":"Spring","slug":"Spring","permalink":"http://a10000005588.github.io/categories/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://a10000005588.github.io/tags/Spring/"},{"name":"Authentication","slug":"Authentication","permalink":"http://a10000005588.github.io/tags/Authentication/"}]},{"title":"Spring Annotation筆記整理","slug":"Spring-Annotation介紹","date":"2020-03-10T14:13:00.000Z","updated":"2020-08-01T02:39:49.090Z","comments":true,"path":"2020/03/10/Spring-Annotation介紹/","link":"","permalink":"http://a10000005588.github.io/2020/03/10/Spring-Annotation介紹/","excerpt":"Spring Annotation 筆記這邊主要整理了我使用或是遇到的Spring Annotation資料查詢與統整的紀錄","text":"Spring Annotation 筆記這邊主要整理了我使用或是遇到的Spring Annotation資料查詢與統整的紀錄 API 相關 @Annotation@RestController將class設置為外部控制器 @RestControllerAdvice等同於@ControllerAdvice + @ResponseBody @ControllerAdvice為可在宣告的函式中使用@ExceptionHandler, @InitBinder或 @ModelAttribute註解的方法 @ExceptionHandler攔截所有控制器所發出的exception，並返回body型式 @RequestMapping控制器裡面的方法，使之成為外部請求 若要設置GET method, 如下(也可以改成 POST, PUT, DELETE) 定義一組restful api前綴路由ex : @RequestMapping(“/api/v1”) 1234567@RequstMapping(\"/api/v1\")public class hello &#123; @GetMapping(\"/hello\") public hello()&#123; return \"helloworld\"; &#125;&#125; 要使用的話得在postman中用 /api/v1/hello HTTP動作Annotation@PostMapping@GetMapping@PutMapping@DeleteMapping@RequestBody可以接收Body參數，得透過class宣告一組object來接收 123456789101112131415class Car &#123; private String type; private Integer number; public setType(String type) &#123; this.type = type; &#125; public setNumber(Integer number) &#123; this.number = number; &#125; public getType... public getNumber...&#125; 1234567@RequestMapping(\"/api/v1\")public class CarController&#123; // 透過宣告一個car，來接收Body的值 (type, number) @GetMapping(\"/car\") function getCar(@RequestBody Car car);&#125; @RequestHeader、@CookieValue處理request header部分的注解： Request Header的內容123456Host localhost:8080 Accept text/html,application/xhtml+xml,application/xml;q=0.9 Accept-Language fr,en-gb;q=0.7,en;q=0.3 Accept-Encoding gzip,deflate Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7 Keep-Alive 300 透過 @RequestHeader(“”)接受其Header值1234@RequestMapping(&quot;/displayHeaderInfo.do&quot;) public void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding, @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123; &#125; @SessionAttributes該註解用來綁定HttpSession中的attribute對象的值，便於在方法中的參數里使用。 該註解有value、types兩個屬性，可以通過名字和類型指定要使用的attribute 對象； 123456@Controller @RequestMapping(\"/editPet.do\") @SessionAttributes(\"pet\") public class EditPetForm &#123; // ... &#125; 參考資料:Spring MVC常用注解@PathVariable、@RequestHeader、@CookieValue、@RequestParam、@RequestBody、@SessionAttributes、@ModelAttribute https://www.cnblogs.com/EasonJim/p/8323017.html @JsonProperty (重點，遇到接不到request的值，用這就對了)用來接收application/json中，有大小不一型別的變數 ex: Postman script1234567&#123; \"contact\":&#123; \"cPhone\":\"0912345678\", \"cMail\":\" abc@test.com.tw \", \"cAddress\":\"台北市中正區信義路一段21-3號\" &#125;,...&#125; 若要接到 PHONE或Website，需要定義 @JsonProperty(“PHONE”), @JsonProperty(“Website”) 123456789101112131415161718@Datapublic class Lia201iReqDTO &#123; contactDto contact; @Data @AllArgsConstructor @NoArgsConstructor public static class contactDto &#123; @NotNull @JsonProperty(\"cPhone\") String cPhone; @JsonProperty(\"cMail\") String cMail; @JsonProperty(\"cAddress\") String cAddress; &#125;&#125; 參考資料Spring REST consuming JSON uppercase vs lowercasehttps://stackoverflow.com/questions/26890398/spring-rest-consuming-json-uppercase-vs-lowercase 驗證相關的Annotation@Valid與@Validated負責驗證有被定義校正的參數或object 先產生要校正的實體類(class)1234567891011121314151617public class Foo &#123; @NotBlank private String name; @Min(18) private Integer age; @Pattern(regexp = \"^1(3|4|5|7|8)\\\\d&#123;9&#125;$\",message = \"手机号码格式错误\") @NotBlank(message = \"手机号码不能为空\") private String phone; @Email(message = \"邮箱格式错误\") private String email; //... getter setter&#125; 於@Controller中 使用Valid做校正 12345678910111213141516@Controllerpublic class FooController &#123; // 對Foo class產生的foo做校正 @RequestMapping(&quot;/foo&quot;) public String foo(@Validated Foo foo &lt;1&gt;, BindingResult bindingResult &lt;2&gt;) &#123; if(bindingResult.hasErrors())&#123; for (FieldError fieldError : bindingResult.getFieldErrors()) &#123; //... &#125; return &quot;fail&quot;; &#125; return &quot;success&quot;; &#125;&#125; @Validate 與 @Valid差異@Valid能進行嵌套驗證， @Validate不行 因為@Valid能加在成員屬性上，反而@Validated不能用在成員屬性。 舉例：12345678910public class Item &#123; @NotNull(message = \"id不能為空值\") @Min(value = 1, message = \"id必須為正整數\") private Long id; @NotNull(message = \"props不能為空直\") @Size(min = 1, message = \"至少要有一個屬性\") private List&lt;Prop&gt; props;&#125; 然而 Prop class如下12345678910111213141516public class Prop &#123; @NotNull(message = \"pid不能為空\") @Min(value = 1, message = \"pid必須為正整數\") private Long pid; @NotNull(message = \"vid不能為空\") @Min(value = 1, message = \"vid必須為正整數\") private Long vid; @NotBlank(message = \"pidName不能為空\") private String pidName; @NotBlank(message = \"vidName不能為空\") private String vidName;&#125; 現在我們有個ItemController接受一個Item的參數，想要對Item進行驗證，如下所示： 12345678@RestControllerpublic class ItemController &#123; @RequestMapping(\"/item/add\") public void addItem(@Validated Item item, BindingResult bindingResult) &#123; doSomething(); &#125;&#125; 在上圖中，如果Item實體的props屬性不額外加註釋，只有@NotNull和@Size，無論入參採用@Validated還是@Valid驗證，Spring Validation框架只會對Item的id和props做非空和數量驗證，不會對props字段裡的Prop實體進行字段驗證，也就是@Validated和@Valid加在方法參數前，都不會自動對參數進行嵌套驗證&lt;/ span&gt; :::info這邊指的嵌套(Nested)驗證，指的是若class Item中還有一個變數List 且這個Props的class內也有自己定義驗證@Notnull, @NotBlank, 一層class內還有一個class定義自己的驗證，就叫做嵌套驗證::: 要進行嵌套驗證的話得在 class Props中加入@Valid 1234567891011public class Item &#123; @NotNull(message = \"id不能为空\") @Min(value = 1, message = \"id必须为正整数\") private Long id; @Valid // 嵌套验证必须用@Valid @NotNull(message = \"props不能为空\") @Size(min = 1, message = \"props至少要有一个自定义属性\") private List&lt;Prop&gt; props;&#125; 補充 負責校驗的Annotation12345678910111213141516171819@Null 被註釋的元素必須為 null@NotNull 被註釋的元素必須不為 null@AssertTrue 被註釋的元素必須為 true@AssertFalse 被註釋的元素必須為 false@Min(value) 被註釋的元素必須是一個數字，其值必須大於等於指定的最小值@Max(value) 被註釋的元素必須是一個數字，其值必須小於等於指定的最大值@DecimalMin(value) 被註釋的元素必須是一個數字，其值必須大於等於指定的最小值@DecimalMax(value) 被註釋的元素必須是一個數字，其值必須小於等於指定的最大值@Size(max=, min=) 被註釋的元素的大小必須在指定的範圍內@Digits (integer, fraction) 被註釋的元素必須是一個數字，其值必須在可接受的範圍內@Past 被註釋的元素必須是一個過去的日期@Future 被註釋的元素必須是一個將來的日期@Pattern(regex=,flag=) 被註釋的元素必須符合指定的正則表達式@NotBlank(message =) 驗證字符串非null，且長度必須大於0@Email 被註釋的元素必須是電子郵箱地址@Length(min=,max=) 被註釋的字符串的大小必須在指定的範圍內@NotEmpty 被註釋的字符串的必須非空@Range(min=,max=,message=) 被註釋的元素必須在合適的範圍內 補充: 用BindingResult接收@Valid拋出來的錯誤訊息假設有驗證錯誤的物件為 BindingResult bindingResult可透過bindResult取得錯誤資訊 舉例: 123456789public class FlightDTO &#123; @NotBlank private String terminal; // 航廈 @NotBlank private String type; // 航班種類 @NotBlank private String carrier; // 航空公司代碼 ...&#125; 若使用@Valid對FlightDTO做參數驗證，假設有一Request少輸入terminal資訊，就會發出bindingResult訊息，其中包含： 12345678910List&lt;FieldError&gt; fieldErrors = bindingResult.getFieldErrors();for(FieldError fieldError: fieldErrors) &#123; // 封裝錯誤格式 FieldResource fieldResource = new FieldResource( fieldError.getObjectName(), // 取得物件名稱：為FlightDTO fieldError.getField(), // 為properties(terminal) fieldError.getCode(), // 為@Notblank fieldError.getDefaultMessage() // 為@Notblank的錯誤資訊 );&#125; :::infoBindingResult為Error的子介面 BindingResulthttps://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/BindingResult.htmlError:https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/Errors.html::: 參考資料：使用spring validation完成数据后端校验https://www.cnkirito.moe/spring-validation/ @Validated和@Valid区别：Spring validation验证框架对入参实体进行嵌套验证必须在相应属性（字段）加上@Valid而不是@Validatedhttps://blog.csdn.net/qq_27680317/article/details/79970590 操作數據庫相關數據相關的Annotation@Entity表示是一個對應到DB Table的物件 @Id聲明該欄位為主鍵 @GeneratedValue指定ID生成的策略，若沒有設置的化, Hibernate對應的是為一個Not null的物件，得自行設定id到物件內。但通常會自行在新增資料時產生ID, 故@Id與@GeneratedValue會常常同時出現 因為Hibernate會遇見不同的Database，所以有各種不同的生成策略: GenerationType.AutoHibernate會根據採用的Database為何，來決定要用 GenerationType.Identity 或 GenerationType.SEQUENCE。(大部分的情況都會採用 GenerationType.SEQUENCE) GenerationType.IDENTITY透過auto-incremented database column來產生primary key.常見的MySQL和MMSQL都採用該方式，相對應的DDL語言為以下所示:1id BIGINT NOT NULL AUTO_INCREMENT GenerationType.SEQUENCE設定該策略，通常也會給入另一個Annotation @SequenceGenerator，如下 12345@Id@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"author_generator\")@SequenceGenerator(name=\"author_generator\", sequenceName = \"author_seq\", allocationSize=50)@Column(name = \"id\", updatable = false, nullable = false)private Long id 若沒有指定，Hibernate會使用預設的SequenceGenerator 可以看到若指定 sequenceGenerator的name為author_seq, Hibernate就會在 author_seq這個table查找下一個id值為多少 注意，在Postgres情況下不適合用該方法https://stackoverflow.com/questions/4288740/hibernate-use-of-postgresql-sequence-does-not-affect-sequence-table/4502062#4502062 GenerationType.SEQUENCE當不希望應用程式與某一種 Database Engine 綁死的時候，可以使用這種方法，透過另外一個表格來定義 ID 會透過SQL，建立存放各種column的seqeunce1CREATE TABLE APP_SEQ_STORE ( APP_SEQ_NAME VARCHAR(255) NOT NULL, APP_SEQ_VALUE BIGINT NOT NULL, PRIMARY KEY(APP_SEQ_NAME) ); Reference: https://thoughts-on-java.org/jpa-generate-primary-keys/@IdClass 复合主键复合主键由多个主键字段组成。每个主键字段必须是上面列出的支持类型之一。例如，以下项目实体类的主键由两个字段组成:12345@Entity @IdClass(ProjectId.class)public class Project &#123; @Id int departmentId; @Id long projectId;&#125; 在ProjectId.class中聲明兩個主鍵值1234Class ProjectId &#123; int departmentId; long projectId;&#125; @Embeddable嵌入式主键表示复合主键的另一种方法是使用可嵌入的类 12345678910@Entitypublic class Project &#123; @EmbeddedId ProjectId id;&#125;@EmbeddableClass ProjectId &#123; int departmentId; long projectId;&#125; @Column宣告該變數與資料庫欄位的對映 1234@Column(nam=”category_name” length=20)Public void getCategoryName()&#123; Return this.categoryName;&#125; 參考資料:SPRING中常用的注解（@ENTITY，@TABLE，@COLUMN，@REPOSITORY，@SERVICE）https://www.cnblogs.com/hoojjack/p/6568920.html JPA 主键@Id、@IdClass、@Embeddable、@EmbeddedIdhttps://blog.csdn.net/tracycater/article/details/78319021 @Data@Data 自動產生 getter(), setter(), toString(), 節省一大堆代碼的神Annotation 前置作業： 引入lombok要使用 @Data 注解要先引入lombok 1lombok為一個Library，可以用簡單的註解形式來簡化代碼，提高開發效率。 如何使用lobok 在maven中添加依賴 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 在編譯器中添加插件 以IDEA為例，在setting的plugin裡搜索lombok plugin，安裝插件。 直接在Class上加上@Data即可 例如一个简单的Person Class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Person &#123; private String name; private String address; private Integer age; private String hobbit; private String phone; public Person() &#123; &#125; public Person(String name, String address, Integer age, String hobbit, String phone) &#123; this.name = name; this.address = address; this.age = age; this.hobbit = hobbit; this.phone = phone; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getHobbit() &#123; return hobbit; &#125; public void setHobbit(String hobbit) &#123; this.hobbit = hobbit; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", address='\" + address + '\\'' + \", age=\" + age + \", hobbit='\" + hobbit + '\\'' + \", phone='\" + phone + '\\'' + '&#125;'; &#125;&#125; 使用了 @Data 12345678910@Data@AllArgsConstructor@NoArgsConstructorpublic class Person &#123; private String name; private String address; private Integer age; private String hobbit; private String phone;&#125; 在按快捷鍵 Ctrl + F12，可以查找到set,get,toString 方法。 使用 @Data 註解就可以有下面幾個註解的功能： @ToString、@Getter、@Setter、@EqualsAndHashCode、@NoArgsConstructor 。 :::info常用的幾個註解：@Data ： 注在類上，提供類的get、set、equals、hashCode、canEqual、toString方法@Setter ： 注在屬性上，提供 set 方法@Getter ： 注在屬性上，提供 get 方法構造函數 @AllArgsConstructor会生成一个包含所有变量，同时如果变量使用了NotNull annotation ， 会进行是否为空的校验，全部参数的Constructor函数的自动生成，该注解的作用域也是只有在实体类上，参数的顺序与属性定义的顺序一致。 範例:123456789101112131415import lombok.AllArgsConstructor;@AllArgsConstructorclass MyClass&#123; private String one; private Integer three; private Integer two; &#125;自動生成建構子:public MyClass(String one, Integer three, Integer two) &#123; this.one = one; this.three = three; this.two = two; &#125; 參考: https://stackoverflow.com/questions/49106072/how-to-specify-the-order-of-parameters-in-allargsconstructor-in-lombok @NoArgsConstructor產生沒有參數的建構子generate a constructor with no parameters. @RequiredArgsConstructor会生成一个包含常量（final），和标识了@NotNull的变量 的构造方法。 @EqualsAndHashCode ： 注在类上，提供对应的 equals 和 hashCode 方法@Log4j/@Slf4j ： 注在类上，提供对应的 Logger 对象，变量名为 log::: :::warning注意的是，同时使用@Data 和 @AllArgsConstructor 后 ，默认的无参构造函数失效，如果需要它，要重新设置 @NoArgsConstructor::: 參考資料 @Data注解 与 lombokhttps://www.jianshu.com/p/c1ee7e4247bf学习Spring Boot：（十五）使用Lombok来优雅的编码https://blog.wuwii.com/springboot-15.html Spring載入Bean與標示為Bean有關的Annotation@Bean定義可共物件化的類別，叫做Bean，並且放置在Spring Ioc Container中並且給其管理，等待被呼叫使用。 配置方式1. 程式碼Java Code配置Spring 的@Bean通常宣告在掛有@Configuration的Spring配置類別中的方法前，例如宣告一個 AppConfig.java，若有超過一個以上的bean，使用 @Qualifier給予名稱 AppConfig.java1234567891011121314151617@Configurationpublic class AppConfig &#123; @Bean(name=\"add\") Calculator addCalculator() &#123; return new AddCalculator(); &#125; @Bean(name=\"sub\") Calculator subCalculator() &#123; return new SubCalculator(); &#125; @Bean(name=\"mul\") Calculator mulCalculator() &#123; return new MulCalculator(); &#125;&#125; 定義Calculator的介面 Calculator.interface123public interface Calculator &#123; int calc(int a, int b);&#125; 定義一個實作Calculator的類別 CalculatorImpl.java1234567891011121314151617181920212223package com.will.advanced.demo.bean;class AddCalculator implements Calculator &#123; @Override public int calc(int a, int b) &#123; return a + b ; &#125;&#125;class SubCalculator implements Calculator &#123; @Override public int calc(int a, int b) &#123; return a - b; &#125;&#125;class MulCalculator implements Calculator &#123; @Override public int calc(int a, int b) &#123; return a * b; &#125;&#125; 取得註冊的bean的方式1. 使用@Autowire 與 @Qualifier然後在 CommandLineRunner中使用 @AutoWire使用@Bean，然而若要Autowired的類別對象是介面的話，且介面有很多的實作子類別(AddCalculator, SubCalculator, MulCalculator) 那得透過 @Qualifier來指名是哪一個子類別 CommandLineAppStartupRunner.java123456789101112131415161718192021@SpringBootApplicationpublic class CommandLineAppStartupRunner implements CommandLineRunner &#123; @Autowired private ApplicationContext context; @Autowired @Qualifier(\"add\") Calculator addCalculator; @Autowired @Qualifier(\"sub\") Calculator subCalculator; @Autowired @Qualifier(\"mul\") Calculator mulCaculator; @Override public void run(String...args) throws Exception &#123; System.out.println(addCalculator.calc(1,3)); System.out.println(subCalculator.calc(3,2)); System.out.println(mulCaculator.calc(2,6)); &#125;&#125; 2. 使用getBean()CommandLineAppStartupRunner.java1234567891011121314151617181920@SpringBootApplicationpublic class CommandLineAppStartupRunner implements CommandLineRunner &#123; @Autowired private ApplicationContext context; @Override public void run(String...args) throws Exception &#123; // 取得所有已經註冊的bean System.out.println(Arrays.asList(context.getBeanDefinitionNames())); // 取得名稱為add的bean Calculator addCalculator = context.getBean(\"add\", Calculator.class); Calculator subCalculator = context.getBean(\"sub\", Calculator.class); Calculator mulCalculator = context.getBean(\"mul\", Calculator.class); System.out.println(addCalculator.calc(1,3)); System.out.println(subCalculator.calc(3,2)); System.out.println(mulCalculator.calc(2,3)); &#125;&#125; 補充: 使用CommandlineRunner讓Spring設置可以先被載入，然後可透過run()定義自訂義執行的內容https://dzone.com/articles/spring-boot-applicationrunner-and-commandlinerunne 3. xml檔案配置上面的寫法等同在 appConfig.xml 宣告:123&lt;beans&gt; &lt;bean name=&quot;addCalculator&quot; class=&quot;com.will.advanced.TransferServiceImpl&quot;/&gt;&lt;/beans&gt; @ComponentScan: 掃描指定package中掛有@Component的類別，自動註冊包含的bean不過一般在沒有特殊需求的情況下都會使用@ComponentScan掃描指定package中掛有@Component的類別來自動註冊為bean。 而會使用@Bean的時機為，當要被註冊為bean的類別建構步驟或邏輯比較複雜，此時就需要@Bean讓你可以在構造bean的方法內撰寫構造的詳細邏輯，而@ComponentScan就無法滿足比較細微的配置。 例如在 service層中新增一個 TestService class透過@Component將TestService註冊成Bean123456@Componentpublic class TestService &#123; public String test() &#123; return &quot;testing&quot;; &#125;&#125; 透過@ComponentScan可使用@Component註冊的bean， 12345678910@ComponentScanpublic class CommandLineAppStartupRunner implements CommandLineRunner &#123; @Autowired TestService testService; @Override public void run(String...args) throws Exception &#123; System.out.println(testService.test()); &#125;&#125; 參考資料Spring: A Head Start 🔥 — Beans Configuration (Part 2)https://medium.com/omarelgabrys-blog/spring-a-head-start-beans-configuration-part-2-4a8c239b070a @Scope: 定義Bean被引用時要怎樣被使用 singleton：在Spring IoC Container，該bean只會有單一實例(a single instance)，此為Spring預設值 prototype：在Spring IoC Container中，該bean可以有多個實例(any number of object instances) request： 在每一次的HTTP Request，spring container會根據loginAction bean的定義來建立一個全新的instance，而且僅在目前的request中有效，所以可以放心的去更改instance的內部狀態，請求結束，request scope的bean instance會被destroy session：針對某個HTTP Session，spring container會根據userPreference bean的定義來建立一個全新的instance，同樣的，和request scope一樣，可以放心的去更改instance內部狀態。 global-session：僅在portlet為基礎的Web應用下有作用。Porlet的規範中定義了global session的概念。 參考資料:Spring Bean Scope 學習https://kevingo75.blogspot.com/2012/03/spring-bean-scope.html 補充: 什麼是Spring IoC (Inversion of Control) container. Inversion of Control, or IoC for short, is a process in which an object defines its dependencies without creating them. This object delegates the job of constructing such dependencies to an IoC container. 用一柱話描述IoC： class不用自己主動new欲依賴class的instance，而是透過外部 (main()方法) 以建構子、setter或是介面注入來產生依賴class的instance :::success需要的 遊戲，不用自己 下載，而是 網咖提供 給你。———————-||——————— 需要的 物件，不用自己 取得，而是 服務容器 提供 給你。———————-||———————需要的 依賴實例，不用 主動 (Active) 建立，而是 被動 (Passive) 接收。::: 參考資料：控制反轉 (IoC) 與 依賴注入 (DI)https://notfalse.net/3/ioc-di @Repository简化 Spring 的开发。@Repository注解便属于最先引入的一批，它用于将数据访问层 (DAO 层 ) 的类标识为 Spring Bean。具体只需将该注解标注在 DAO类上即可。 @Service、@Controller 和 @Component 將class標示为Bean @Component 是一个泛化的概念，仅仅表示一个组件 (Bean) ，可以作用在任何层次。 @Service 通常作用在業務邏輯層，但是目前该功能与 @Component 相同。 @Controller 通常作用在控制層(Controller)，但是目前该功能與@Component 相同。 @PostConstruct被@PostConstruct修飾的方法會在服務器加載Servlet的時候運行，並且只會被服務器執行一次。 @Transactional假若你在class中設定了@Transactional, 該class所有的method有使用到JPA的都會被spring的transaction所管理。 舉例：當有個Transaction有三個動作：entity1.save, entity2.save, entity3.save. 若entity3.save失敗，那Spring就會將entity1.save與entity2.save的執行結果給rollback，還原其動作。 參考資料https://stackoverflow.com/questions/1099025/spring-transactional-what-happens-in-background AOP相關的Annotaion@Aspect@Aspect:定義AOP，作用在class AOP為 Aspect Oritented ProgrammingAOP通過給程序定義一個切入點，然後在其前後切入不同的執行內容AOP不會破壞原來的程序邏輯AOP使用場景： 紀錄日誌 事務管理 安全檢查 資源控制 @Pointcut, @Before, @After範例1234567891011121314151617181920212223@Aspect@Componentpublic class LogAspect &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); // 切入package為com.william.demo.api的LogTestApi類別的log函式 @Pointcut(\"execution(* com.william.demo.api.LogTestApi.log(..))\") public void log() &#123; &#125; // 希望在切入點 log()函式前執行某些內容 // 或是用直接用 @Before(\"execution(* com.william.demo.api.LogTestApi.log(..))\"); @Before(\"log()\") public void doBefore() &#123; logger.info(\"----------do before---------\"); &#125; @After(\"log()\") public void doAfter() &#123; logger.info(\"----------do after----------\"); &#125;&#125; 其他Annotation@Cache定義cache策略與範圍，可以定義以下參數： usage: 當前緩存策略(NONE, READ_ONLY, NONSTRICT_READ_WRITE, TRANSACTIONAL) read-only: 只讀緩存 如果你的應用程序只需讀取一個持久化類的實例，而無需對其修改， 那麼就可以對其進行只讀緩存 read-write: 讀寫緩存 如果應用程序需要更新數據，那麼使用讀/寫緩存比較合適。如果應用程序要求“序列化事務”的隔離級別（serializable transaction isolation level），那麼就決不能使用這種緩存策略 nonstrict-read-write: 不嚴格讀寫緩存 如果應用程序只偶爾需要更新數據（也就是說，兩個事務同時更新同一記錄的情況很不常見），也不需要十分嚴格的事務隔離，那麼比較適合使用非嚴格讀/寫緩存策略。 transactional :事務性緩存 Hibernate 的事務緩存策略提供了全事務的緩存支持，例如對 JBoss TreeCache 的支持。這樣的緩存只能用於 JTA 環境中，你必須指定為其hibernate.transaction.manager_lookup_class屬性。 region: 可選參數，指定二級緩存的去域名，默認為類或者集合的名字。 include: 可選參數(all, non-lazy)。 all包含所有屬性，non-lazy僅包含非延遲加載的屬性。 範例12345@Table(name = &quot;PROVICE&quot;)@Cache(usage =CacheConcurrencyStrategy.READ_ONLY)public class Province() &#123;...&#125; 1234567@Table(name = &quot;PROVICE&quot;)@Cache(usage =CacheConcurrencyStrategy.READ_ONLY)public class Province() &#123; @OneToMany(fetch = FetchType.LAZY) @JoinColumn(name = &quot;cityId&quot;) @Cache(usage = CacheConcrrencyStrategy.READ_ONLY) private Set&lt;City&gt; cities; 參考資料Hibernate @Cache注解-天才小小布https://blog.csdn.net/w410589502/article/details/54603265 @Configuration@Configuration的作用同以前的xml配置檔（例如Spring的applicationContext.xml或dispatcher-servlet.xml），用來設定Spring環境配置，例如宣告及註冊bean至Spring容器中，注入properties參數等。 範例例如我們有一個FooService類別，若此類別要成為Spring容器管理的bean，有兩種方法： 一般在該類別上宣告@Component並搭配@ComponentScan掃描的方式註冊為bean 透過在@Configuration類別中搭配@Bean的方式註冊。 例如建立一個AppConfig並在類別名稱前掛上@Configuration，則此類別及成為Spring的配置類。在配置類的方法前掛上@Bean則方法回傳的物件就會被註冊為Spring容器管理的bean fooService()方法便會將FooService註冊為bean。 1234567891011121314package com.will.advanced.demo.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.will.advanced.demo.service.FooService;@Configurationpublic class AppConfig &#123; @Bean public FooService fooService() &#123; return new FooService(); &#125;&#125; 為了程式管理及維護上的方便，通常我們會把某些相關的配置寫在另外的配置檔，而不是全部塞在同一個類別，此時就可以利用@Configuration另外定義一個配置檔，例如上面的AppConfig。 @SpringBootApplication: 本身也包含@Configuration而在Spring Boot中，@SpringBootApplication類本身即包含了@Configuration，所以可以直接在裡面進行如上Bean的配置，例如 123456789101112131415161718192021package com.will.advanced.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import com.will.advanced.demo.FooService;@SpringBootApplicationpublic class SpringBootBeanDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootBeanDemoApplication.class, args); &#125; @Bean public FooService fooService() &#123; return new FooService(); &#125;&#125; 參考資料Spring @Configuration作用https://matthung0807.blogspot.com/2019/04/spring-configuration_28.html @SpringBootApplication定義 @SpringBootApplication的預設掃瞄bean的範圍 Spring Boot的@SpringBootApplication預設只會掃描所屬package下的類，因此若@Configuration類別定義在@SpringBootApplication類以外的package，則要用scanBasePackages屬性來設定要額外掃描的package，例如@SpringBootApplication(scanBasePackages=”com.will.advanced.demo.config”) （@Configuration包含了@Component）， 12345678910111213package com.will.advanced.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;// 注意在scanBasePackages的package名稱@SpringBootApplication(scanBasePackages=\"com.will.advanced.demo.config\") public class SpringBootBeanDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootBeanDemoApplication.class, args); &#125;&#125; @Import或是透過@Import來引入 ，例如12345678910111213141516package com.will.advanced.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Import;@SpringBootApplication// 注意pacakge名稱@Import(value = &#123; com.will.advanced.demo.config.AnotherAppConfig.class &#125;)public class SpringBootBeanDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootBeanDemoApplication.class, args); &#125;&#125; :::warning注意使用@Import會忽略@Configuration設定::: @Autowired依賴注入物件 Spring的@Autowired用來依賴注入物件，典型的用法就是掛在類別成員變數上。@Autowired預設會依注入對象的類別型態來選擇容器(透過@Configuration定義的class會成為容器)中相符的物件(設置成bean)來注入。 12@Autowiredprivate Car car; Spring會自動去容器中找到 有容器定義CarBeans的bean 123456import ....xxx.Car;@Configuationpublic class CarBeans &#123; @Bean public Car car() &#123; return new Car() &#125;&#125; @Autowire為Spring IoC的實現，不用自己去new一個car出來，而是透過容器(會做constructor or setter or interface injection)，來去實現外部注入，降低模組(class)之間的耦合性 @EnableScheduling若開發者在AppConfig類中使用了@EnableScheduling，並在某個task class中使用了@Schedule註解，那麼被@Schedule標註的方法既可以在指定時間內自動執行 注意：@EnableScheduling要與@Schedule搭配使用才有效果 @ConfigurationProperties若想要把配置文件的信息，讀取好並自動封裝(getter讀取private的config值)成實體類，如此一來我們在代碼裡面使用就輕鬆許多，這時就可以使用@ConfiguationProperties，把同類的配置訊息自動封裝成實體類。 假設有設定文件在 application.properties之下：123connection.username=adminconnection.password=kyjufskifas2jsfsconnection.remoteAddress=192.168.1.1 我們可以定義一個實體類在裝載配置文件信息 12345678910111213141516171819202122232425262728@Component@ConfigurationProperties(prefix=\"connection\")public class ConnectionSettings &#123; private String username; private String remoteAddress; private String password ; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getRemoteAddress() &#123; return remoteAddress; &#125; public void setRemoteAddress(String remoteAddress) &#123; this.remoteAddress = remoteAddress; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 亦可以把 @ConfigurationProperties 定義在@Bean之下，說明@Bean是參考到有用configuationProperties設定的class 12345678910111213141516@SpringBootApplicationpublic class DemoApplication&#123; //... @Bean @ConfigurationProperties(prefix = \"connection\") public ConnectionSettings connectionSettings()&#123; return new ConnectionSettings(); &#125; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 需要使用時直接用@Autowire注入 12345678910111213@RestController@RequestMapping(\"/task\")public class TaskController &#123; // 在這裡注入 config！ @Autowired ConnectionSettings conn; @RequestMapping(value = &#123;\"/\",\"\"&#125;) public String hellTask()&#123; String userName = conn.getUsername(); return \"hello task !!\"; &#125;&#125; 參考資料：spring boot 使用@ConfigurationPropertieshttps://blog.csdn.net/yingxiake/article/details/51263071 @ConditionalOnClass是Springboot实现自动配置的重要支撑之一。其用途是判断当前classpath下是否存在指定类，若是则将当前的配置装载入spring容器。 參考資料：@ConditionalOnClass的使用探索 新日暮里格斗大会https://blog.csdn.net/lucyTheSlayer/article/details/80430912 @ConditionalOnMissingBean结合使用注解@ConditionalOnMissingBean和@Bean,可以做到只有特定名称或者类型的Bean不存在于BeanFactory中时才创建某个Bean 12345678910111213141516171819202122232425@Configurationpublic class ConditionalOnMissingBeanConfig &#123; // 無條件定義一個bean @Bean public A beanA ()&#123; return new A(); // &#125; @Bean @ConditionalOnMissingBean(name=\"beanA\") public B beanB()&#123; // 如果 beanFactory 中存在一个名称为 beanA 的 bean，才定义bean ： beanB； // 因为上面的方法已经定义了一个 beanA，所以这里 beanB定义并不会发生。 return new B(); &#125; @Bean @ConditionalOnMissingBean(name=\"beanD\") public C beanC()&#123; // 如果 beanFactory 中存在一个名称为 beanD的 bean，才定义bean ： beanC； return new C(); &#125;&#125; 參考資料：Spring Boot基于特定条件创建Bean例子 : ConditionalOnMissingBeanhttps://blog.csdn.net/andy_zhang2007/article/details/81285130","categories":[{"name":"Spring","slug":"Spring","permalink":"http://a10000005588.github.io/categories/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://a10000005588.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://a10000005588.github.io/tags/Spring/"}]},{"title":"2020年的想法與自修規劃","slug":"2020年的想法與自修規劃","date":"2020-01-01T13:30:48.000Z","updated":"2021-01-28T12:14:59.145Z","comments":true,"path":"2020/01/01/2020年的想法與自修規劃/","link":"","permalink":"http://a10000005588.github.io/2020/01/01/2020年的想法與自修規劃/","excerpt":"回顧了一下2019年對自己的期許，自己與期許的似乎還有所差距，就再接再厲。","text":"回顧了一下2019年對自己的期許，自己與期許的似乎還有所差距，就再接再厲。 希望今年強化自身的網站開發的實力(以後端為主)接下來2020年想要趁下班閒暇時間時來做： 刷刷leetcode 找一個side project來經營 (預計用Java Spring Boot後端, Angular前端) 複習資料結構，資料庫SQL語法等 以上繼續精進，自我勉勵","categories":[{"name":"Life","slug":"Life","permalink":"http://a10000005588.github.io/categories/Life/"}],"tags":[{"name":"Mindsets","slug":"Mindsets","permalink":"http://a10000005588.github.io/tags/Mindsets/"}]},{"title":"如何查看透過智能合約存在以太坊上的資料？","slug":"checksmartcontractdata","date":"2019-02-10T15:25:43.000Z","updated":"2019-02-10T15:36:44.807Z","comments":true,"path":"2019/02/10/checksmartcontractdata/","link":"","permalink":"http://a10000005588.github.io/2019/02/10/checksmartcontractdata/","excerpt":"在看這篇文章之前必須要知道一件事，那就是透過智能合約存在區塊鏈上的資訊都是公開的。","text":"在看這篇文章之前必須要知道一件事，那就是透過智能合約存在區塊鏈上的資訊都是公開的。 不管你是否有在智能合約上面有用requre(), revert(), assert()等等來限制某地址的人來存取智能合約上的變數，但這些變數都會存以太坊EVM的Storage上面，每個節點都可以透過以下方式來對EVM的Storage內的編碼進行解析，並還原當初透過合約所儲存的變數資料！！！ 以下透過一個範例來瞭解如何透過web3.js library中的eth.getStorage()方法來解析Storage內儲存的資訊。 智能合約範例：123456789101112131415161718192021222324252627282930313233343536373839404142434445prama solidity ^0.4.0;contract testStorage &#123; uint storeduint1 = 15; uint constant constuint = 16; uint128 investmentsLimit = 17055; uint32 investmentsDeadlinedTimeStamp = uint32(now); bytes16 string1 = 'test1'; bytes32 string2 = 'test1236'; string string3 = 'lets string something'; mapping (address =&gt; uint) uints1; mapping (address =&gt; DeviceData) structs1; uint[] uintarray; DeviceData[] deviceDataArray; struct DeviceData &#123; string deviceBrand; string deviceYear; string batteryWearLevel; &#125; function testStorage() &#123; address address1 = 0xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6 address address2 = 0xaee905fdd3ed851e48d22059575b9f4245a82b04; uints1[address1] = 88; uints1[address2] = 99; var dev1 = DeviceData('deviceBrand', 'deviceYear', 'wearLevel'); var dev2 = DeviceData('deviceBrand2', 'deviceYear2', 'wearLevel2'); structs1[addresss1] = dev1; structs1[addresss2] = dev2; uintarray.push(8000); uintarray.push(9000); deviceDataArray.push(dev1); deviceDataArray.push(dev2); &#125;&#125; 假設我們合約的地址是在：0xf1f5896ace3a78c347eb7eab503450bc93bd0c3b 所有儲存在storage內的參數都可以用index來索引，index的格式為256 bytes以及對應64碼。在以上的範例中我們有 10個參數，所以可以透過index來一一遍歷他們： 12345678910111213141516let contractAddress = &apos;0xf1f5896ace3a78c347eb7eab503450bc93bd0c3b&apos;for (index = 0; index &lt; 10; index++)&#123; console.log(`[$&#123;index&#125;]` + web3.eth.getStorageAt(contractAddress, index))&#125;result:[0] 0x000000000000000000000000000000000000000000000000000000000000000f[1] 0x00000000000000000000000059b92d9a0000000000000000000000000000429f[2] 0x0000000000000000000000000000000074657374310000000000000000000000[3] 0x7465737431323336000000000000000000000000000000000000000000000000[4] 0x6c65747320737472696e6720736f6d657468696e67000000000000000000002a[5] 0x0000000000000000000000000000000000000000000000000000000000000000[6] 0x0000000000000000000000000000000000000000000000000000000000000000[7] 0x0000000000000000000000000000000000000000000000000000000000000002[8] 0x0000000000000000000000000000000000000000000000000000000000000002[9] 0x0000000000000000000000000000000000000000000000000000000000000000 開始針對合約內的10個變數一一做遍歷和解析 index 0 - storeduint11234567let contractAddress = &apos;0xf1f5896ace3a78c347eb7eab503450bc93bd0c3b&apos;let index = 0console.log(web3.eth.getStorageAt(contractAddress, index))console.log(&apos;DEC:&apos; + web3.toDecimal(web3.eth.getStorageAt(contractAddress, index)))result:0x000000000000000000000000000000000000000000000000000000000000000fDEC:15 constuintConstants(常數) 不會被存在storage內，只能夠透過code來存取 index 1 - investmentsLimit, investmentsDeadlineTimeStamp12345let index = 1console.log(web3.eth.getStorageAt(contractAddress, index))result: 0x00000000000000000000000059b92d9a0000000000000000000000000000429fDEC: 1505308058 and 17055 在index 1中，會將2個變數(investmentsLimit, investmentsDeadlineTimeStamp)做合併來最佳化storage的存放 index 2 - string11234567index = 2console.log(web3.eth.getStorageAt(contractAddress, index))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result: 0x0000000000000000000000000000000074657374310000000000000000000000ASCII: test1 index 3 - string21234567index = 3console.log(web3.eth.getStorageAt(contractAddress, index))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result:0x7465737431323336000000000000000000000000000000000000000000000000ASCII: test1236 index 4 - string31234567index = 4console.log(web3.eth.getStorageAt(contractAddress, index))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result:0x6c65747320737472696e6720736f6d657468696e67000000000000000000002aASCII: lets string something * (42) 在result最後有 2a(dec42)為 string儲存的長度可參閱solidity官方文件描述變數在storage中呈現的格式：https://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage index 5 — uints112345index = 5console.log(web3.eth.getStorageAt(contractAddress, index))result:0x0000000000000000000000000000000000000000000000000000000000000000PROBLEM!!!! 若遇到 mapping struct宣告的變數，無法直接透過一般的index來取得struct內所儲存的值，必須得曉得對應value中的 key值，否則是不可能取得的。 1234/* 要取回在 uints1 struct所儲存在addresss1的值 :88// uints1[address1] = 88; address1 = 0xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6 1234567891011index = &apos;0000000000000000000000000000000000000000000000000000000000000005&apos;// convert address1 to the 256 bytes...key = &apos;00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6&apos;let newKey = web3.sha3(key + index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;)console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;DEC: &apos; + web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000000058DEC: 88 index6 - structs1123456789index = &quot;0000000000000000000000000000000000000000000000000000000000000006&quot;key = &quot;00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6&quot;let newKey = web3.sha3(key + index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;)console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963654272616e64000000000000000000000000000000000000000016ASCII: deviceBrand 若要讀取下一個struct的值，只需要將newKey的值+1即可取到。 12345678910111213141516function increaseHexByOne(hex) &#123; let x = new BigNumber(hex) let sum = x.add(1) let result = &apos;0x&apos; + sum.toString(16) return result&#125;index = &quot;0000000000000000000000000000000000000000000000000000000000000006&quot;key = &quot;00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6&quot;let newKey = increaseHexByOne( web3.sha3(key + index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;))console.log(web3.eth.getStorageAt(contractAddress,newKey))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963655965617200000000000000000000000000000000000000000014ASCII: deviceYear 若還需要第三個之後的值，繼續將newKey遞增，就能夠取到。 index 7 - uintarray12345index = &quot;7&quot;console.log(web3.eth.getStorageAt(contractAddress, index))result: 0x0000000000000000000000000000000000000000000000000000000000000002 以上的result表示 array目前有2個值 (8000, 9000) 123456789101112131415161718index = &quot;0000000000000000000000000000000000000000000000000000000000000007&quot;let newKey = web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;)console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;DEC: &apos; + web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000001f40DEC: 8000---newKey = increaseHexByOne(web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;))console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;DEC: &apos; + web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000002328DEC: 9000 index 8 - deviceDataArray1234567891011121314151617181920index = &quot;0000000000000000000000000000000000000000000000000000000000000008&quot;let newKey = web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;)console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963654272616e64000000000000000000000000000000000000000016ASCII: deviceBrand---index = &quot;0000000000000000000000000000000000000000000000000000000000000008&quot;let newKey = increaseHexByOne(web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;))console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;ASCII: &apos; +web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963655965617200000000000000000000000000000000000000000014ASCII: deviceYear 繼續增加index的值(+1), result: 12345678index = &quot;0000000000000000000000000000000000000000000000000000000000000008&quot;let newKey = increaseHexByTwo(web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;))console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;ASCII: &apos; +web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x776561724c6576656c0000000000000000000000000000000000000000000012ASCII: wearLevel 若加3之後，result會顯示第二組(dev2) 存進array的值 1234result:0x6465766963654272616e64320000000000000000000000000000000000000018ASCII: deviceBrand2 ReferenceHow to read Ethereum contract storage - Darius https://medium.com/aigang-network/how-to-read-ethereum-contract-storage-44252c8af925","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/tags/Solidity/"},{"name":"Smart Contract","slug":"Smart-Contract","permalink":"http://a10000005588.github.io/tags/Smart-Contract/"}]},{"title":"2019年的想法與規劃","slug":"2019年的想法與規劃","date":"2019-02-05T13:24:10.000Z","updated":"2021-01-28T12:15:13.966Z","comments":true,"path":"2019/02/05/2019年的想法與規劃/","link":"","permalink":"http://a10000005588.github.io/2019/02/05/2019年的想法與規劃/","excerpt":"剛好在農曆新年第一天，為自己的Blog換的新的Skin，同時也想勉勵自己重拾寫部落格的手感。","text":"剛好在農曆新年第一天，為自己的Blog換的新的Skin，同時也想勉勵自己重拾寫部落格的手感。 由於自己想往區塊鏈或是雲端後端工程師發展，所以在2019年希望自己能夠再次複習網路以及作業系統等知識， 以上，希望2019年能夠順利完成論文，且能夠找到一份好工作，並且持續精進自己的技術。","categories":[{"name":"Life","slug":"Life","permalink":"http://a10000005588.github.io/categories/Life/"}],"tags":[{"name":"Mindsets","slug":"Mindsets","permalink":"http://a10000005588.github.io/tags/Mindsets/"}]},{"title":"Go Interface介紹","slug":"go-interface","date":"2018-07-05T15:51:38.000Z","updated":"2020-08-17T13:55:20.039Z","comments":true,"path":"2018/07/05/go-interface/","link":"","permalink":"http://a10000005588.github.io/2018/07/05/go-interface/","excerpt":"用生活化的例子來舉例： Water-pipeline就像是個interface 你就只能灌液體進去，不能塞非液體的東西到 water-pipeline","text":"用生活化的例子來舉例： Water-pipeline就像是個interface 你就只能灌液體進去，不能塞非液體的東西到 water-pipeline再用火車鐵軌為例：Railroads 是train 的 interfaces 不管train上面載的什麼物體，看是passengers 還是cargos 但train的寬度 (width of the train) 都必須要符合鐵軌寬度。 \b故 railroads 的 interfaces會有以下的組成要素： 123type RailRoadWidthChecker interface &#123; CheckRailsWidth() int&#125; RailRoadWidthChecker 規範了 train必須要實作檢查火車自身的width，確保train的width是剛好符合 railroad 的寬度 123type RailRoad struct &#123; Width int&#125; // 只有宣告為type RailRoad才能呼叫 IsCorrectSizeTrain1234567891011121314151617func (railroad *RailRoad) IsCorrectSizeTrain (trainInstance RailRoadWidthChecker) bool &#123; return trainInstance.CheckRailsWidth() == railroad.Width&#125;``` || 疑問：為何不是在input中type為Train ???|| Answer: 因為由struct type為 Train實作了 struct type: RailRoadWidthCheck的CheckRailWidth()的方法IsCorrectSizeTrain 會接受了一個有實作 interface instance的火車，並且回傳該火車寬度是否與鐵軌相同```gotype Train struct &#123; TrainWidth int&#125;// 宣告為Train的struct instance 實作 checkRailsWidth()函式 並回傳 int型態func (p Train) CheckRailsWidth() int &#123; Return p.TrainWidth&#125; 接下來用 兩台train 一個有符合railroad寬度 一個則沒符合寬度 來作為範例 123456789101112func main() &#123; railroad := RailRoad&#123;Width: 10&#125; passengerTrain := Train &#123; TrainWidth: 10 &#125; cargoTrain := Train &#123; TrainWidth: 15 &#125; // interface要求type為Train必須要實作 CheckRailsWidth\b canPassengerTrainPass := railroad.IsCorrectSizeTrain(passengerTrain) canCargoTrainPass := railroad.IsCorrectSizeTrain(cargoTrain) fmt.Printf(“Can passengerTrain pass? :%t \\n”, canPassengerTrainPass) fmt.Printf(“Can cargoTrain pass? :%t \\n”, canCargoTrainPass)&#125; 輸出：12Can passengerTrain pass? :trueCan cargoTrain pass? :false","categories":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/tags/Golang/"}]},{"title":"以太坊測試網連接：Connect to the Rospen Network","slug":"rospen","date":"2018-05-13T08:22:06.000Z","updated":"2020-07-26T09:17:43.173Z","comments":true,"path":"2018/05/13/rospen/","link":"","permalink":"http://a10000005588.github.io/2018/05/13/rospen/","excerpt":"Enviroment: MacOS Assume reader has basic understanding of geth and ethereum.","text":"Enviroment: MacOS Assume reader has basic understanding of geth and ethereum. Create a Ethereum WalletWe can via myetherwallet to create a wallet.https://www.myetherwallet.com/#generate-wallet Record your privakey, pubkey:12private key: a406da76baa7c741ad28bfe87cef2133950d6bb6bcaaf0b1742d93c3bea56babpublic key: 0x2C58e0338435FE91FD2209105EcADebE8aaFCebB Because we are going to connect the testnet Rospen, we should do some stuff… Get a ether from faucet: For simplicity, we just ask someone to send some ether on testnet to us. Please attach your account address to get some ether. https://l.facebook.com/l.php?u=http%3A%2F%2Ffaucet.ropsten.be%3A3001%2F&amp;h=ATPjPzMFxxXmP_Egwq9V35ye_LjGOM4A_vzMkbQOdLCN8FYVRgfurVVTwrcuUzqNCMUiXF2C8sUqt241q8nmTJO6hCnY7WhpkV6iUVWxsIqjlALAeEVFv_kH5Q Check Tx from Rospen networkhttps://ropsten.etherscan.io/address/0x6508a973F080A9042a29d13925d9DB006f8c2989 In serch bar, enter your account address to see whether if the ether is sending to your account or not. Start to build a node and synchronize the Rospen network. Notice that your geth version should be the latest so that you can sucessfully sync the network. Current version : Version: 1.8.7-stable Before sync the node , Put your keystore file in the testnet document.When you download your keystore file.For example, the filename will be:UTC--2018-05-13T04-05-37.569Z--2c58e0338435fe91fd2209105ecadebe8aafcebbCopy this file into your testnet key store:/User/Library/Ethereum/testnet/keystore Sync to the Rospen networkhttps://github.com/ethereum/ropsten 1geth --unlock &lt;account&gt; --testnet --syncmode &quot;full&quot; &quot;enode://20c9ad97c081d63397d7b685a412227a40e23c8bdc6688c6f37e97cfbc22d2b4d1db1510d8f61e6a8866ad7f0e17c02b14182d37ea7c3c8b9c2683aeb6b733a1@52.169.14.227:30303,enode://6ce05930c72abc632c58e2e4324f7c7ea478cec0ed4fa2528982cf34483094e9cbc9216e7aa349691242576d552a2a56aaeae426c5303ded677ce455ba1acd9d@13.84.180.240:30303&quot; Threre are some flags: –unlock : use password to unlock the account. –testnet: connect to the rospen network. –syncmode “full”: in order to get our balances, we should synchronize whole blocks. 1geth --testnet --fast --bootnodes &quot;enode://20c9ad97c081d63397d7b685a412227a40e23c8bdc6688c6f37e97cfbc22d2b4d1db1510d8f61e6a8866ad7f0e17c02b14182d37ea7c3c8b9c2683aeb6b733a1@52.169.14.227:30303,enode://6ce05930c72abc632c58e2e4324f7c7ea478cec0ed4fa2528982cf34483094e9cbc9216e7aa349691242576d552a2a56aaeae426c5303ded677ce455ba1acd9d@13.84.180.240:30303&quot; If we already sync the entire network, we can just use--fast --bootnodes to connect testnet… Attach your gethOn MacOS (for testnet): geth attach ipc:/Users/&lt;username&gt;/Library/Ethereum/testnet/geth.ipc Then, in the console do eth.syncing you will see those stuff: 12345678&gt; eth.syncing&#123; currentBlock: 542220, highestBlock: 3224277, knownStates: 0, pulledStates: 0, startingBlock: 31397&#125; That means you are sucessfully connecting the testnet.After finish syncing process, you can see there is some ether in your accounts Problem for connecting the ropsten networkhttps://stackoverflow.com/questions/49195614/connection-failed-to-ethereum-ropsten-testnet-network Deploy to rospen network toturial:https://michalzalecki.com/deploying-smart-contracts-with-truffle/","categories":[{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/categories/Ethereum/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://a10000005588.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"}]},{"title":"Go的錯誤處理機制介紹 Defer, Panic與Recover","slug":"go-defer","date":"2018-05-13T08:20:55.000Z","updated":"2020-08-17T13:56:01.618Z","comments":true,"path":"2018/05/13/go-defer/","link":"","permalink":"http://a10000005588.github.io/2018/05/13/go-defer/","excerpt":"Defer, Paic, Recover是Golang 用來做錯誤處理的常用函式","text":"Defer, Paic, Recover是Golang 用來做錯誤處理的常用函式 介紹Panic用來發出錯誤訊息，並中斷以下執行流程 Defer可將某訊息或某執行方法推延後至程式結束，在執行。 Recover只能在Defer中使用，用來接收panic傳入的參數，並做打印或其他執行。 範例用以下例子來看 Panic、Recover與Defer的用法： 1234567891011121314151617181920212223242526272829303132package mainimport \"fmt\"func main() &#123; f() fmt.Println(\"Returned normally from f.\")&#125;func f() &#123;// 被推延至結束才執行，並且recover() 會接受panic所傳遞的參數 defer func() &#123; if r := recover(); r != nil &#123; fmt.Println(\"Recovered in f\", r) &#125; &#125;() fmt.Println(\"Calling g.\") g(0) fmt.Println(\"Returned normally from g.\")&#125;func g(i int) &#123; if i &gt; 3 &#123; fmt.Println(\"Panicking!\") panic(fmt.Sprintf(\"%v\", i)) &#125; // 將 印出“Defer in g\"這段訊息 延後印出，直到panic觸發或是程式結束才會被印出來 // 先被defer的會最晚被印出來，為Last in first out ! defer fmt.Println(\"Defer in g\", i) fmt.Println(\"Printing in g\", i) g(i + 1)&#125; 123456789101112Calling g.Printing in g 0Printing in g 1Printing in g 2Printing in g 3Panicking!Defer in g 3Defer in g 2Defer in g 1Defer in g 0Recovered in f 4Returned normally from f. 補充通常 defer 也會被用在 要關閉一個DB的instance 例如以下以mongoDB為例： 12345678910111213141516171819202122232425func someFunction() &#123; var err error mongo, err := getMongoSession() // 回傳一個mongo的instance mongo.SetSocketTimeout(1 * time.Hour) //session.SetSocketTimeout(1 * time.Hour) if err != nil &#123; errors := common.Error&#123; ErrorType: 1, ErrorDescription: err.Error(), &#125; logger.Console().Panic(errors) logger.File().Error(err) &#125; // 將關閉mongo的動作推延至 該function執行玩return後執行 defer mongo.Close() collection := mongo.DB(dbName).C(collectionName.BsBlocks) result := []blockStrcut.BlockWithOnlyTxHashesIntNum&#123;&#125; err = collection.Find(conditions).All(&amp;result) return result, err&#125; 參考The Go Blog：Defer, Panic, and Recoverhttps://blog.golang.org/defer-panic-and-recover","categories":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/tags/Golang/"}]},{"title":"Golang的特色介紹","slug":"go-features","date":"2018-05-13T08:19:10.000Z","updated":"2020-08-17T13:55:32.689Z","comments":true,"path":"2018/05/13/go-features/","link":"","permalink":"http://a10000005588.github.io/2018/05/13/go-features/","excerpt":"The benefit of Golang is as follows:","text":"The benefit of Golang is as follows: 1. Quick compile time than the C , C++ Golang provides lightning-quick compiler by using a smart compiler and simplified dependency resolution algorithm. When build the golang program, the compiler only looks at the libraries that you directly include. (C,C++,JAVA. those programming language will traverse entire dependency chain…) 2. Concurrencygo-routineGolang can create go-routine, which is like thread but use far less memory and require less code to use. Golang can create many go-routine on a single thread. 12345func log(msg string)&#123; ... some logging code here&#125;// Elsewhere in our code after we've discovered an error.go log(\"something dire happened\") channelchannel are data structure that let you send typed messages between goroutines with sychronization built in. Channel can also avoid the share memory problem in concurrency modification problem. Warning: channel isn’t provide data access protection. 3. Go type system.Golang provides flexible hierachy-free type free system that enables code reuse with minimal refactoring overhead. In tradictional OOD, like JAVA, need to implenment all the method declared in interface.1234interface User &#123; public void login(); public void logout();&#125; But in golang type system, you only implement the method you would use.123type Reader interface &#123; Read(p []byte) (n int, err error)&#125; 4. Memory managementGolang has modern garbage collector that does hard work for you.","categories":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/tags/Golang/"}]},{"title":"ERC Token介紹：ERC20 & ERC721","slug":"erctoken","date":"2018-03-25T11:54:59.000Z","updated":"2020-07-26T09:16:56.792Z","comments":true,"path":"2018/03/25/erctoken/","link":"","permalink":"http://a10000005588.github.io/2018/03/25/erctoken/","excerpt":"即利用當今火紅的以太坊上的智能合約，實作出代幣功能。可擁有與虛擬貨幣作為價值傳遞功能。","text":"即利用當今火紅的以太坊上的智能合約，實作出代幣功能。可擁有與虛擬貨幣作為價值傳遞功能。 好處 不用自己架設公有鏈，就可以擁有自己發行的代幣 以既定匯率，可以直接與以太幣進行交換。 為何需要ERC標準合約？由於代幣是建立在以太坊上的智能合約，故其代幣也只是存在智能合約上的某筆紀錄。故透過一些狀態改變和轉移，故ERC合約可以明確定義某個以太坊地址上的某個代幣餘額，並可以對其進行操作，而操作的規範就定義在ERC上。 故一個代幣要擁有合理的發行機制，就得符合現在所擁有的ERC20以及ERC721之類的標準。 ERC代幣有自己的錢包嗎？？由於是透過以太坊智能合約控制的，故只要透過以太坊錢包(地址)就可以了。 ERC20 介紹記載ERC20規則 官方文件https://theethereum.wiki/w/index.php/ERC20_Token_Standard ERC20 Token Standard Interface12345678910interface ERC20 &#123; function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); | function allowance(address tokenOwner, address spender) public constant returns (uint remaining); | function transfer(address to, uint tokens) public returns (bool success); | function approve(address spender, uint tokens) public returns (bool success); | function transferFrom(address from, address to, uint tokens) public returns (bool success); | event Transfer(address indexed from, address indexed to, uint tokens); | event Approval(address indexed tokenOwner, address indexed spender, uint tokens); &#125; 以上的Interface定義了六個Function，有Input及Output格式。以及兩個Event，僅有Input。 其中Function為可以操縱智能合約狀態的動作，會需要消耗Gas，而可以看到有些Function後面有 constant關鍵字，表示僅做唯獨，不會更改到智能合約上的State，主要是回傳的State資訊，不會消耗到Gas。 而Event為紀錄重大事件的發生，例如在鏈上進行Token的轉移。 設定ERC Token資訊123string public constant name = \"Token Name\"; string public constant symbol = \"TKN\"; uint8 public constant decimals = 18; // 18 is the most common number of decimal places ERC20 需要設定此 Token 的三個資訊: name、symbol、decimals name 是 Token 的名字。 symbol 則是此 Token 會使用的代稱，像是 Binance Token 的 symbol 就是 BNB，而此 symbol 也會出現在 Etherscan上面 decimals 是用來設定此 Token 最小會有幾個位數，通常會設定成 18，意即最多到達小數點後 18 位數，這樣的設定跟 Ether 本身的設定也是一樣的(1 ether: 10 ^ 18 wei)。 補充說明：在 Solidity 中並沒有浮點數的存在，所有的運算都是整數，因此平常我們所說的 1 Ether，事實上在 Solidity 程式中是以wei的單位(1 ether = 10¹⁸)來撰寫。 ERC20 詳述12345678910111213141516171819202122232425262728293031323334353637383940414243contract TokenContractFragment &#123; // Balances for each account mapping(address =&gt; uint256) balances; // Owner of account approves the transfer of an amount to another account mapping(address =&gt; mapping (address =&gt; uint256)) allowed; // Get the token balance for account \\`tokenOwner\\` function balanceOf(address tokenOwner) public constant returns (uint balance) &#123; return balances\\[tokenOwner\\]; &#125; // Transfer the balance from owner's account to another account function transfer(address to, uint tokens) public returns (bool success) &#123; balances\\[msg.sender\\] = balances\\[msg.sender\\].sub(tokens); balances\\[to\\] = balances\\[to\\].add(tokens); Transfer(msg.sender, to, tokens); return true; &#125; // Send \\`tokens\\` amount of tokens from address \\`from\\` to address \\`to\\` // The transferFrom method is used for a withdraw workflow, allowing contracts to send // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge // fees in sub-currencies; the command should fail unless the _from account has // deliberately authorized the sender of the message via some mechanism; we propose // these standardized APIs for approval: function transferFrom(address from, address to, uint tokens) public returns (bool success) &#123; balances\\[from\\] = balances\\[from\\].sub(tokens); allowed\\[from\\]\\[msg.sender\\] = allowed\\[from\\]\\[msg.sender\\].sub(tokens); balances\\[to\\] = balances\\[to\\].add(tokens); Transfer(from, to, tokens); return true; &#125; // Allow \\`spender\\` to withdraw from your account, multiple times, up to the \\`tokens\\` amount. // If this function is called again it overwrites the current allowance with _value. function approve(address spender, uint tokens) public returns (bool success) &#123; allowed\\[msg.sender\\]\\[spender\\] = tokens; Approval(msg.sender, spender, tokens); return true; &#125;&#125; 使用例子Token Balance我們假設這個智能合約目前有兩個地址擁有該Tokenbalances[‘0x123456’] = 100balances[‘0x654321’] = 200 則 Function balanceOf 則會回傳以下資訊:tokenContract.balanceOf(‘0x123456’) will return 100tokenContract.balanceOf(‘0x654321’) will return 200 Transfer Token Balance如果 0x123456想要轉移 10 tokens 給 0x654321，則呼叫tokenContract.transfer(‘0x654321’, 10) 將得到下列結果balances[‘0x123456’] = 90balances[‘0x654321’] = 210 Approve And TransferFrom Token Balance如果 0x123456 允許 0x654321 擁有轉移 30 tokens 的權利，則呼叫tokenContract.approve(‘0x654321’, 30) 將得到下列結果tokenContract.allowed[‘0x123456’][‘0x654321’] = 30 如果此時’0x654321’ 想要轉移 ‘0x123456’ 的 20 tokens 給自己，則呼叫‘tokenContract.transferFrom(‘0x123456’, ‘0x654321’, 20) 將得到下列結果tokenContract.balances[‘0x123456’] = 70tokenContract.balances[‘0x654321’] = 230tokenContract.allowed[‘0x123456’][‘0x654321’] = 10 ERC721 介紹ERC-721 是用来定義 Non-fungible token (不可替代的代幣)。每個代幣是唯一的(unique)，具不可分割性，不像ERC20 每個token都相同。 具體應用: 以太貓(cryptokitties)每個以太貓，都是一個ERC721代幣。 1234567891011interface ERC721 &#123; function supportsInterface(bytes4 _interfaceID) external pure returns (bool); function ownerOf(uint256 \\_deedId) external view returns (address \\_owner); function countOfDeeds() external view returns (uint256 _count); function countOfDeedsByOwner(address \\_owner) external view returns (uint256 \\_count); function deedOfOwnerByIndex(address \\_owner, uint256 \\_index) external view returns (uint256 _deedId); event Transfer(address indexed from, address indexed to, uint256 indexed deedId); event Approval(address indexed owner, address indexed approved, uint256 indexed deedId); function approve(address \\_to, uint256 \\_deedId) external payable; function takeOwnership(uint256 _deedId) external payable;&#125; 參考資料 ERC20 Token Standardhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard 请问以太坊里的ERC-721和ERC-20是什么？http://www.blockchainbrother.com/question/510 What has ERC-721 better than ERC-20?https://medium.com/@PatrickGohBS/ethereum-erc-721-vs-erc-20-4bff8c147fdf","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"}]},{"title":"Go使用Array、Slice與Map的介紹","slug":"go-array-slice-map","date":"2018-03-18T12:41:51.000Z","updated":"2021-01-27T23:37:13.086Z","comments":true,"path":"2018/03/18/go-array-slice-map/","link":"","permalink":"http://a10000005588.github.io/2018/03/18/go-array-slice-map/","excerpt":"這篇主要介紹如何在Golang底下使用Array, Slice, Map等操作技巧","text":"這篇主要介紹如何在Golang底下使用Array, Slice, Map等操作技巧 array用法宣告12var arr [5]intfmt.Println(\"array arr:\", a) 或是用 make1arr := make([]int64,5) 動態分配陣列1234arr=make([][]int64,10) //外層有10格for i:=0;i&lt;10;i++&#123; arr[i]=make([]int64,i) //動態分裡面&#125; 遍歷array1234567for i := 0; i &lt;len(a); i++ &#123; fmt.Println(\"arr[\", i, \"] =\", a[i])&#125;// 用range, 第一個值 key為索引，value為索引的值for key, value := range arr &#123; fmt.Println(\"arr[\", i, \"] =\", value)&#125; slice用法透過array創造12var myArray [10]int = [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;var mySlice []int = myArray[:5] 或是利用 make12345// make([]T, length, capacity)// 創建長度為5，容量為10的切片slice1 := make([]int, 5, 10)// 創建長度為5，並初始化該切片slice2 := []int&#123;1, 2, 3, 4, 5&#125; 註： make的capacity若沒有設置會預設跟length一樣，為slice最大長度之上限。 切片長度可透過append來增加1234// 在slice2 增加6slice2 = append(slice2, 6)fmt.Println(\"slice:\", slice2)// slice: 1 2 3 4 5 6 Array 和 Slice差異 array slice 長度宣告後不可以變動 長度可以透過append()或slice[:]做變動 X slice為array的指標，若更動slice，也會更動到原本array的內容 如何避免Slice更動到原本Array?Method1 - make and Copy先開一個新的空間，用make開好，用copy拷貝過去123arr:=[]int&#123;1,2,3,4&#125;newSlice := make([]int, len(arr))copy(newSlice, arr) Method2 - Append12arr:=[]int&#123;1,2,3,4&#125;newSlice = append([]int64(nil), arr[1:3]...) //一定要「…」 Map用法建立一個 map 兩種方式: 123m := make(map[string]int)// m[\"age\"] = 16m := map[string]int&#123;&#125; 回傳值, 和 map 是否存在如果是不存在的 key , value = 0 , ok = false1value , ok := m[\"age\"] 利用 range 取得 map 中所有的 key 和 value, 並列印123for key, value := range m &#123; fmt.Println(\"Key:\", key, \"Value:\", value)&#125; 一次宣告多值12345person := map[string]int&#123; \"age\" : 16, \"height\" : 180, \"weight\" : 6,&#125; ReferenceGolang 兩三事http://daniel0076.logdown.com/posts/280719-golang-slice-notesGolang slice trickhttps://github.com/golang/go/wiki/SliceTricks","categories":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/tags/Golang/"}]},{"title":"分散式系統共識算法筆記：Paxos和Raft","slug":"consensusAlgo","date":"2018-03-10T16:00:00.000Z","updated":"2019-02-05T13:06:27.330Z","comments":true,"path":"2018/03/11/consensusAlgo/","link":"","permalink":"http://a10000005588.github.io/2018/03/11/consensusAlgo/","excerpt":"Paxos介紹分布式系統中，只有出現故障節點(fault node),但不存在惡意節點(corrupt node)下達成共識的問題。","text":"Paxos介紹分布式系統中，只有出現故障節點(fault node),但不存在惡意節點(corrupt node)下達成共識的問題。 問題起源故事背景為古希臘的Paxon島上有諸位法官要對某一件法案進行裁決並如何達成共識的結果。 過程中法官會透過傳訊關傳遞訊息，但法官可能中途離席，而服務員可能偷懶睡覺。 故Paxos算法基於“兩階段提交”來確保法官們可以得到共識結果的一致性。 Paxos特性Paxos將參與節點中分為三類： Proposer(客戶端): 提出一個案子，等待大家批准並得到答案。 Acceptor(服務端): 接受提案，並進行投票。 Learner(客戶端or服務端): 被告知提案結果，並將自己的狀態與結果更新。 過程中必須滿足分散式系統共識所必須的兩特性： Safty：保證決議結果是對的，無異議，並不會出現錯誤情況。 Liveness：保證在”有限”時間內完成共識結果。 Paxos過程 由Proposer提出提案，爭取Acceptors的支持。 超過一半的Acceptors支持，則發送該提案結果給所有人進行確認。 兩階段提繳Step 1: Prepare階段 Proposer發送自己的計畫給多個Acceptors. Acceptor根據該計畫的編號，若是最新的編號則保留，反之則退回。 Step 2: Commit階段 Proposer收到Accpetor的確認回覆。若收到的回覆中不帶有新的提案請求，表示鎖定成功。 若沒有收到超過1/2個Accpetor的回覆。 特殊情況 若Proposer在提案過程中發生故障，可以透過超時機制票選下一位Proposer。 Paxos算法保證在正常節點有 1/2個以上時，可滿足共識的Safety和Liveness. Raft介紹為Paxos的簡化版本。 參與者包括三種角色： 1.Leader 2.Candidate 3.Follower 共識流程 Leader選舉：每個Candidate在一定時間內會提出選舉方案，而選舉結果的那位成為Leader. 同步每個Replication的Log: Leader會找到系統中的Log檔案上最新的紀錄，並要求所有Follower根據該最新紀錄同步到他們自己的Log檔案上。 log檔可能為系統上發生的動作紀錄。 小結Paxos和Raft為目前分散式系統的帶來不錯的共識結果，其他共識演算法像是PBFT (practical byzantine fault tolerant protocal)以及目前由Amis團隊所於etherum上所實現的BFT算法- Istanbul BFT，都算是本次筆記提到的再進階的共識算法，有興趣的讀者可以在到以下連結去深入瞭解。 Istanbul BFT - AMIS PBFT Introduction","categories":[{"name":"Consensus","slug":"Consensus","permalink":"http://a10000005588.github.io/categories/Consensus/"}],"tags":[{"name":"Consensus","slug":"Consensus","permalink":"http://a10000005588.github.io/tags/Consensus/"},{"name":"Blockchain","slug":"Blockchain","permalink":"http://a10000005588.github.io/tags/Blockchain/"}]},{"title":"Javascript筆記:Closure(閉包)概念","slug":"javascript-closure","date":"2017-09-13T04:43:04.000Z","updated":"2020-07-26T09:17:28.824Z","comments":true,"path":"2017/09/13/javascript-closure/","link":"","permalink":"http://a10000005588.github.io/2017/09/13/javascript-closure/","excerpt":"閉包（closure): 為一個function包在某一個函式內，用return來取得內部function的回傳值 Closure are commonly used to give objects data privacy.","text":"閉包（closure): 為一個function包在某一個函式內，用return來取得內部function的回傳值 Closure are commonly used to give objects data privacy. 為什麼要有閉包？？因為有以下問題ㄧ、Counter dilemma123456789101112var counter = 0;function add() &#123; counter += 1;&#125;add();add();add();// the counter is now equal to 3 counter被改變成3、不過也可以不用透過add()直接更改counter的值。那這樣會造成變數污染衝突。 12345678function add() &#123; var counter = 0; counter += 1;&#125;add();add();add(); counter被宣告在add()內，為local variable，不會被其他function或global改寫。但會有重複呼叫add()後無法使counter值做累加的動作。(因為var counter使變數重複被定義)。 二、解決方法 1234567function add() &#123; var counter = 0; function plus() &#123;counter += 1;&#125; plus(); return counter; &#125; 透過內部plus函式才能更改counter值、解決counter dilemma問題，不過還會遇到var counter重複宣告的問題，這時候就得用閉包的技巧！如下： 1234567891011var add = (function () &#123; var counter = 0; return function () &#123;return counter += 1;&#125;&#125;)();add();add();add();// the counter is now 3 將add變數宣告成 self-invoking function(僅執行內部一次 var counter不會在add()第二次被呼叫時再次被宣告)，然後回傳function expression，如此一來add變數就變成 add() function了！ 12var counter = 0;return function () ***&#123;return counter += 1;***&#125; 就被包在add()函式內，直接呼叫add() 就只會跑上面*的部分。 以上做法即為closure閉包，使得變數不會被污染和衝突。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://a10000005588.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://a10000005588.github.io/tags/Javascript/"}]},{"title":"Javascript筆記:使用prototype chain(原型鍊)來達成繼承效果","slug":"javascript-prototypechain","date":"2017-09-13T04:39:37.000Z","updated":"2020-07-26T09:17:34.981Z","comments":true,"path":"2017/09/13/javascript-prototypechain/","link":"","permalink":"http://a10000005588.github.io/2017/09/13/javascript-prototypechain/","excerpt":"先知道個keyword： __proto__： javascript自己定義的變數，用來實現inheritance效果，有點類似像link list node的概念，連結其他的 prototype","text":"先知道個keyword： __proto__： javascript自己定義的變數，用來實現inheritance效果，有點類似像link list node的概念，連結其他的 prototype javascript記憶體管理的配置： class儲存在 global底下 class的prototype放置在heap （即class底下的各種variable和function) instance（ex var b = new B()) 的b儲存在 callstack(記憶體RAM裡面) slogan:在自己的scope裡面找不到要的函式或變數就跟自己的__proto__要！ 繼承範例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var Car = function()&#123; //constructor this.brand = \"default\"; var _wheels // private method var initialWheels = function () &#123; _wheels = 4 &#125; this.getNumberofWheel = function()&#123; return this.brand; &#125;&#125;var Benz = function(brandName) &#123; //constructor Car.apply(this, argument) //等於呼叫 super(args); //argument為 var Benz = function(args...); 的 args們 = [brandName, wheel] // 這一行就是把 Benz.prototype.__proto__ = Car.prototype接起來; // 即Benz class inheritance Car // 疑問：上面敘述需和Ben確認一下 那這樣為什麼下面又得自己做Benz.prototype = Object.create(Car.prototype) ?? // 解答：若沒有做Car.apply (即super()) 動作，這樣子類別會無法將接受的arguments傳遞給從parent複製過來的函式 this.brand = brandName; //初始化車品牌的名稱 &#125;// javascript ES5得自己綁定繼承關係，用__proto__這個keyword// 建立父類別實體 設定繼承關係:Benz.prototype = Object.create(Car.prototype) //上面即是做了Benz.prototype.__proto__ = Car.prototype//使Benz class繼承Car class(Benz extends Car)Benz.prototype.constructor = Benz//Benz的constructor指向Benz class//將Benz的constructor綁定到自己身上，//才能在Benz new出一個物件時作初始化動作（即呼叫Benz =function函式&#123;&#125;) //var benz = new Benz(\"Benz\") 初始化該車子名稱：\"Benz\"; var benz = new Benz() // benz.__proto__ = Benz.prototype// 宣告一個物件叫 benzconsole.log(benz.numberOfWheels()) // 會先搜尋benz.prototype有沒有numberOfWheels()方法// 沒有==&gt;那就找benz.__proto__ = Benz.prototype;// Benz.prototype就會找到 numberOfWheels()的方法！ benz.numberOfWheels() 有此方法 每次呼叫Car.apply(this, arguments)時”複製”到子類別的物件上初始化物件時較慢，在run time想要動態改變numberOfWheels()的實作時 無法影響已經創建的子類別或父類別instances. 以下為初始化較有效率的寫法：1234567891011121314151617181920212223242526var Car = function () &#123; // constructor // public property this.wheels = 4 // pulic property this.brand = 'default'&#125;// 這種寫法不支援存取private property// 因為每個物件都可以直接存取掛在parent.prototype上的property// 但可以在run time修改此Car.prototype.numberOfWheels()的實作// 就可以透過prototype chain更改所有相關的instance功能 因為instance共用prototype chain上的方法Car.prototype.numberOfWheels = function () &#123; return this.wheels&#125;var Benz = function (brandName) &#123; Car.apply(this, arguments) // 複製繼承父類別public property this.brand = 'brandName'; this.getBrand = function () &#123; return this.brand &#125;&#125;... numberOfWheels該方法已經被掛在 Car.prototype上，所以並不像Car.apply上直接複製一份給子class們，而是子class去共用Car.prototype.numberOfWheels 這個方法。 優點：節省初始化的時間和提升效率 缺點：這種寫法不支援存取private property javascript 類別、prototype以及reference中的proto所指向的關係示意圖：圖片作者： Ben大大 假設 B class extend A;let b = new B(); // b.__proto__ = B.prototypelet a = new A(); // a.__proto__ = A.prototypelet o = new Object(); o.__proto__ = Object.prototype//對應到圖片左邊的b、a、o. (先從圖片最左上角開始看那 var b = new B();b想要使用繼承A的 getValue() 函式，那麼就得先找自己的 b.prototype 沒有的話 找 b.__proto__ = B.prototype 若b.__proto__也沒有的話(即B.prototype)也沒有，那麼找 B.prototype.__proto__ == A.prototype在A.prototype就會找到getValue()的函式！ 如果又沒找到，那就最後找A.prototype.__proto__ == Object.prototype若沒有那就找 Object.prototype.__proto__ == null 即找無該函式，compile告知發生錯誤); Prototype inheritance 的好處 Suitable in loosely typed environments, no need to define explicit types. Makes it incredibly easy to implement singleton pattern (compare JavaScript and Java in this regard, and you’ll know what I am talking about). (why? 因為prototype inheritance提供???? 請看補充二） Provides ways of applying a method of an object in the context of a different object, adding and replacing methods dynamically from an object etc. (things which are not possible in a strongly typed languages). Prototype inheritance的壞處 No easy way of implementing private variables. Its possible to implement private vars using Crockford’s wizardry using closures, but its definitely not as trivial as using private variables in say Java or C#.(因為__prpto__會指向prototype的所有成員！故無法像class inheritance那樣避免繼承到有private關鍵字的變數，故得用closure手法來避免繼承到_private變數) Reference:prototype based vs. class based inheritance 補充ㄧ：Function.prototype.applyfun.apply(thisArg, [argsArray])// 將一連串參數用array包起來：[argsArray]，丟給fun函式處理 範例：1234567891011121314function theFunction(name, profession) &#123; console.log(&quot;My name is &quot; + name + &quot; and I am a &quot; + profession + &quot;.&quot;);&#125;// call functionfunction callFn(name, profession) &#123; theFunction.apply(this, [name, profession]);&#125;theFunction(&apos;小will&apos;, &apos;工程師&apos;);callFn(&apos;大Will&apos;, &apos;小廢廢&apos;);// 輸出:// My name is 小will and I am a 工程師.// My name is 大Will and I am a 小廢廢. 補充二：用Closure實作Singleton模式閉包觀念連結：==&gt; 閉包是什麼？？ 先看範例程式碼1234567891011121314151617181920var UniverseN;(function()&#123; var instance; UniverseN = function UniverseN()&#123; if(instance)&#123; return instance; &#125; instance = this; this.start_time = 0; this.bang = 'Big'; &#125;;&#125;());var uni9 = new UniverseN();var uni10 = new UniverseN();console.log(uni9 === uni10); //trueUniverseN.prototype.inEverything = true; 可以看出若利用了Prototype inheritance的特性，，將IIFE函式掛在UniverseN.prototype.IIFE上，使得之後宣告的物件不會在複製一份IIFE出來出來，讓IIFE只跑一次！這樣就可以達成一個class (UniverseN) 只能宣告一次的物件 (uni9)。 如果在宣告出 uni10，他們都還是指向同一樣的instance(uni9.__proto__ == uni10__proto__) Reference:JavaScript Design Pattern - Singleton 單體模式","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://a10000005588.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://a10000005588.github.io/tags/Javascript/"}]},{"title":"使用OpenZeppelin搭配Truffle來打造智能合約","slug":"openzepplin","date":"2017-09-13T02:43:31.000Z","updated":"2020-07-26T09:17:39.142Z","comments":true,"path":"2017/09/13/openzepplin/","link":"","permalink":"http://a10000005588.github.io/2017/09/13/openzepplin/","excerpt":"本篇是參考truffle官網所做的筆記：ROBUST SMART CONTRACTS WITH OPENZEPPELIN","text":"本篇是參考truffle官網所做的筆記：ROBUST SMART CONTRACTS WITH OPENZEPPELIN OpenZeppelin介紹可以把OpenZeppelin當成強化Solidity資訊安全的Framework，為智能合約附上Ethereum所認可的ERC-20標準，畢竟合約要處理的可是真正的錢！ ERC-20標準介紹：What is ERC-20 and What Does it Mean for Ethereum? 簡單來說ERC-20標準允許錢包、交易所和其他智能合約以一種常見的方式對接各種代幣。 使用OpenZeppelin預備知識建議先瞭解ethereum以及Smart Contract語言Solidity以及開發Smart Contract的框架 Truffle 可以參考官網或是我之前所做的筆記 Ethereum官方網站： 菜鳥William的Solidity學習紀錄 使用Truffle來練習撰寫認養寵物的智能合約 環境設定創立一個資料夾 open_z使用truffle unbox把練習專案給下載到本機上12cd open_ztruffle ubbox tutorialtoken 安裝 zeppelin-solidity 1npm install zeppelin-solidity 為tutorialtoken專案撰寫 TutorialToken合約在 /contracts 目錄底下創建 TutorialToken.sol TutorialToken.sol12345678910111213141516171819pragma solidity ^0.4.4;// 引入zepplin-solidity的StandardToken.sol 合約import 'zeppelin-solidity/contracts/token/StandardToken.sol';// 使用is 來繼承StandardToken合約contract TutorialToken is StandardToken &#123; string public name = 'TutorialToken'; // token name string public symbol = 'TT'; uint public decimals = 2; // 合約被創建時所產生的金額總數 uint public INITIAL_SUPPLY = 12000; function TutorialToken() &#123; totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; &#125;&#125; 透過以上簡短的程式碼就已經創造出符合Ethereum的 ERC-20標準的Token囉！ 編譯(Compile)以及部署(Deploy)在/migrations內，創建2_deploy_contracts.js檔案 2_deploy_contracts.js12345var TutorialToken = artifacts.require(\"./TutorialToken.sol\");module.exports = function(deployer) &#123; deployer.deploy(TutorialToken);&#125;; 在terminal，先用testrpc啟好自己的測試鍊 1testrpc then 執行12truffle comiletruffle migrate 和TutorialToken Dapp互動我們使用metamask和我們的Dapp互動 並且該專案已經內建 lite-server可運行Dapp 執行1npm run dev 看到以下畫面則表示成功運行！(別忘了要先登入metamask，以便前端能夠擷取到testrpc所開啟的錢包資訊) 以及可以看到在metamask上錢包的資訊 總結: Truffle+OpenZeppelin = A Superb Development Experience透過： Truffle：開發智能合約的框架 OpenZeppelin：可為智能合約提供ERC-20標準的工具 就可以打造出可上市的智能合約的開發環境！ 對OpenZeppelin內的合約架構有興趣的朋友可以觀看我這篇筆記： OpenZeppelin合約架構透析","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/tags/Solidity/"},{"name":"Truffle","slug":"Truffle","permalink":"http://a10000005588.github.io/tags/Truffle/"}]},{"title":"Solidity學習紀錄","slug":"solidity","date":"2017-09-12T13:34:23.000Z","updated":"2020-07-26T09:17:50.095Z","comments":true,"path":"2017/09/12/solidity/","link":"","permalink":"http://a10000005588.github.io/2017/09/12/solidity/","excerpt":"這篇主要記錄著我對Solidity官網文檔的學習紀錄","text":"這篇主要記錄著我對Solidity官網文檔的學習紀錄 簡單的合約開始介紹起1234567891011121314pragma solidity ^0.4.0; // 告訴compiler要如何對待這份codecontract SimpleStorage &#123; uint storedData; // 宣告uint型態的變數 uint為 256 bits. // 以下控制stored variable. function set(uint x) &#123; storedData = x; &#125; function get() constant returns (uint) &#123; return storedData; &#125;&#125; 另外一個比較複雜的合約 123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.0;contract Coin &#123; // The keyword \"public\" makes those variables // readable from outside. address public minter; mapping (address =&gt; uint) public balances; // 可把mapping 當成是hash tables // 將address當參數 映射到balances中會得到uint型態的回傳值 // Events allow light clients to react on // changes efficiently. event Sent(address from, address to, uint amount); // 和contract同名的函式名稱即為constructor，在合約被創造出來時呼叫 function Coin() &#123; minter = msg.sender; &#125; function mint(address receiver, uint amount) &#123; if (msg.sender != minter) return; balances[receiver] += amount; &#125; function send(address receiver, uint amount) &#123; if (balances[msg.sender] &lt; amount) return; balances[msg.sender] -= amount; balances[receiver] += amount; Sent(msg.sender, receiver, amount); // msg.sender 合約的持有者 &#125;&#125; address：160-bit value that does not allow any arithmetic operations. public：使其他合約可以存取自己的scope function,variable. address public minter 可看成如下： 1function minter() returns (address) &#123; return minter; &#125; mapping (address =&gt; uint) public balances;可看成如下 123function balances(address _account) returns (uint) &#123; return balances[_account];&#125; event Sent(address from, address to, uint amount); 透過該Sent function方便追蹤錢的流出和流入地址是哪 Coin()：為建構子，合約創造出來就會呼叫且建構子會儲存： msg：儲存創造合約的人的address以及其他properties (tx,block…)，擁有直接和blockchain溝通的權利 msg.sender：呼叫合約的人，若contract A呼叫contract B，那msg.sender在contract A B都是相同的。 Ethereum Virtual MachineThe Ethereum Virtual Machine or EVM is the runtime environment for smart contracts in Ethereum. Features: OverviewThe Ethereum Virtual Machine or EVM is the runtime environment for smart contracts in Ethereum AccountsExternal accounts that are controlled by public-private key pairs (i.e. humans)Contract accounts which are controlled by the code stored together with the account.—-Every account has a persistent key-value store mapping 256-bit words to 256-bit words called storage. Transactions GasThe gas price is a value set by the creator of the transaction合約的手續費，用來執行合約的燃料，避免Contract有bug會把錢一直轉走 Storage, Memory and the Stack Storage:每個Contract都會持有自己的storage,storage為一個key-value store that maps 256-bit words to 256-bit words. Memory：of which a contract obtains a freshly cleared instance for each message call Delegatecall / Callcode and Libraries Solidity ExamplesSolidity Example 1：Voting Contract.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138pragma solidity ^0.4.11;/// @title Voting with delegation.contract Ballot &#123; // This declares a new complex type which will // be used for variables later. // It will represent a single voter. struct Voter &#123; uint weight; // weight is accumulated by delegation bool voted; // if true, that person already voted address delegate; // person delegated to uint vote; // index of the voted proposal &#125; // This is a type for a single proposal. struct Proposal &#123; bytes32 name; // short name (up to 32 bytes) uint voteCount; // number of accumulated votes &#125; address public chairperson; // This declares a state variable that // stores a `Voter` struct for each possible address. // 將每一個地址映射到對應的 Voter struct. mapping(address =&gt; Voter) public voters; // A dynamically-sized array of `Proposal` structs. Proposal[] public proposals; /// Create a new ballot to choose one of `proposalNames`. function Ballot(bytes32[] proposalNames) &#123; chairperson = msg.sender; voters[chairperson].weight = 1; // For each of the provided proposal names, // create a new proposal object and add it // to the end of the array. for (uint i = 0; i &lt; proposalNames.length; i++) &#123; // `Proposal(&#123;...&#125;)` creates a temporary // Proposal object and `proposals.push(...)` // appends it to the end of `proposals`. proposals.push(Proposal(&#123; name: proposalNames[i], voteCount: 0 &#125;)); &#125; &#125; // Give `voter` the right to vote on this ballot. // May only be called by `chairperson`. function giveRightToVote(address voter) &#123; // If the argument of `require` evaluates to `false`, // it terminates and reverts all changes to // the state and to Ether balances. It is often // a good idea to use this if functions are // called incorrectly. But watch out, this // will currently also consume all provided gas // (this is planned to change in the future). require((msg.sender == chairperson) &amp;&amp; !voters[voter].voted &amp;&amp; (voters[voter].weight == 0)); voters[voter].weight = 1; &#125; /// Delegate your vote to the voter `to`. function delegate(address to) &#123; // assigns reference Voter storage sender = voters[msg.sender]; require(!sender.voted); // Self-delegation is not allowed. require(to != msg.sender); // Forward the delegation as long as // `to` also delegated. // In general, such loops are very dangerous, // because if they run too long, they might // need more gas than is available in a block. // In this case, the delegation will not be executed, // but in other situations, such loops might // cause a contract to get \"stuck\" completely. while (voters[to].delegate != address(0)) &#123; to = voters[to].delegate; // We found a loop in the delegation, not allowed. require(to != msg.sender); &#125; // Since `sender` is a reference, this // modifies `voters[msg.sender].voted` sender.voted = true; sender.delegate = to; Voter delegate = voters[to]; if (delegate.voted) &#123; // If the delegate already voted, // directly add to the number of votes proposals[delegate.vote].voteCount += sender.weight; &#125; else &#123; // If the delegate did not vote yet, // add to her weight. delegate.weight += sender.weight; &#125; &#125; /// Give your vote (including votes delegated to you) /// to proposal `proposals[proposal].name`. function vote(uint proposal) &#123; Voter storage sender = voters[msg.sender]; require(!sender.voted); sender.voted = true; sender.vote = proposal; // If `proposal` is out of the range of the array, // this will throw automatically and revert all // changes. proposals[proposal].voteCount += sender.weight; &#125; /// @dev Computes the winning proposal taking all /// previous votes into account. function winningProposal() constant returns (uint winningProposal) &#123; uint winningVoteCount = 0; for (uint p = 0; p &lt; proposals.length; p++) &#123; if (proposals[p].voteCount &gt; winningVoteCount) &#123; winningVoteCount = proposals[p].voteCount; winningProposal = p; &#125; &#125; &#125; // Calls winningProposal() function to get the index // of the winner contained in the proposals array and then // returns the name of the winner function winnerName() constant returns (bytes32 winnerName) &#123; winnerName = proposals[winningProposal()].name; &#125;&#125; Solidity Example 2：Simple Open Auction123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119pragma solidity ^0.4.11;contract SimpleAuction &#123; // Parameters of the auction. Times are either // absolute unix timestamps (seconds since 1970-01-01) // or time periods in seconds. address public beneficiary; uint public auctionStart; uint public biddingTime; // Current state of the auction. address public highestBidder; uint public highestBid; // Allowed withdrawals of previous bids mapping(address =&gt; uint) pendingReturns; // Set to true at the end, disallows any change bool ended; // Events that will be fired on changes. event HighestBidIncreased(address bidder, uint amount); event AuctionEnded(address winner, uint amount); // The following is a so-called natspec comment, // recognizable by the three slashes. // It will be shown when the user is asked to // confirm a transaction. /// Create a simple auction with `_biddingTime` /// seconds bidding time on behalf of the /// beneficiary address `_beneficiary`. function SimpleAuction( uint _biddingTime, address _beneficiary ) &#123; beneficiary = _beneficiary; auctionStart = now; biddingTime = _biddingTime; &#125; /// Bid on the auction with the value sent /// together with this transaction. /// The value will only be refunded if the /// auction is not won. function bid() payable &#123; // No arguments are necessary, all // information is already part of // the transaction. The keyword payable // is required for the function to // be able to receive Ether. // Revert the call if the bidding // period is over. require(now &lt;= (auctionStart + biddingTime)); // If the bid is not higher, send the // money back. require(msg.value &gt; highestBid); if (highestBidder != 0) &#123; // Sending back the money by simply using // highestBidder.send(highestBid) is a security risk // because it could execute an untrusted contract. // It is always safer to let the recipients // withdraw their money themselves. pendingReturns[highestBidder] += highestBid; &#125; highestBidder = msg.sender; highestBid = msg.value; HighestBidIncreased(msg.sender, msg.value); &#125; /// Withdraw a bid that was overbid. function withdraw() returns (bool) &#123; uint amount = pendingReturns[msg.sender]; if (amount &gt; 0) &#123; // It is important to set this to zero because the recipient // can call this function again as part of the receiving call // before `send` returns. pendingReturns[msg.sender] = 0; if (!msg.sender.send(amount)) &#123; // No need to call throw here, just reset the amount owing pendingReturns[msg.sender] = amount; return false; &#125; &#125; return true; &#125; /// End the auction and send the highest bid /// to the beneficiary. function auctionEnd() &#123; // It is a good guideline to structure functions that interact // with other contracts (i.e. they call functions or send Ether) // into three phases: // 1. checking conditions // 2. performing actions (potentially changing conditions) // 3. interacting with other contracts // If these phases are mixed up, the other contract could call // back into the current contract and modify the state or cause // effects (ether payout) to be performed multiple times. // If functions called internally include interaction with external // contracts, they also have to be considered interaction with // external contracts. // 1. Conditions require(now &gt;= (auctionStart + biddingTime)); // auction did not yet end require(!ended); // this function has already been called // 2. Effects ended = true; AuctionEnded(highestBidder, highestBid); // 3. Interaction beneficiary.transfer(highestBid); &#125;&#125; Solidity Example 3：Blink Auction123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144pragma solidity ^0.4.11;contract BlindAuction &#123; struct Bid &#123; bytes32 blindedBid; uint deposit; &#125; address public beneficiary; uint public auctionStart; uint public biddingEnd; uint public revealEnd; bool public ended; mapping(address =&gt; Bid[]) public bids; address public highestBidder; uint public highestBid; // Allowed withdrawals of previous bids mapping(address =&gt; uint) pendingReturns; event AuctionEnded(address winner, uint highestBid); /// Modifiers are a convenient way to validate inputs to /// functions. `onlyBefore` is applied to `bid` below: /// The new function body is the modifier's body where /// `_` is replaced by the old function body. modifier onlyBefore(uint _time) &#123; require(now &lt; _time); _; &#125; modifier onlyAfter(uint _time) &#123; require(now &gt; _time); _; &#125; function BlindAuction( uint _biddingTime, uint _revealTime, address _beneficiary ) &#123; beneficiary = _beneficiary; auctionStart = now; biddingEnd = now + _biddingTime; revealEnd = biddingEnd + _revealTime; &#125; /// Place a blinded bid with `_blindedBid` = keccak256(value, /// fake, secret). /// The sent ether is only refunded if the bid is correctly /// revealed in the revealing phase. The bid is valid if the /// ether sent together with the bid is at least \"value\" and /// \"fake\" is not true. Setting \"fake\" to true and sending /// not the exact amount are ways to hide the real bid but /// still make the required deposit. The same address can /// place multiple bids. function bid(bytes32 _blindedBid) payable onlyBefore(biddingEnd) &#123; bids[msg.sender].push(Bid(&#123; blindedBid: _blindedBid, deposit: msg.value &#125;)); &#125; /// Reveal your blinded bids. You will get a refund for all /// correctly blinded invalid bids and for all bids except for /// the totally highest. function reveal( uint[] _values, bool[] _fake, bytes32[] _secret ) onlyAfter(biddingEnd) onlyBefore(revealEnd) &#123; uint length = bids[msg.sender].length; require(_values.length == length); require(_fake.length == length); require(_secret.length == length); uint refund; for (uint i = 0; i &lt; length; i++) &#123; var bid = bids[msg.sender][i]; var (value, fake, secret) = (_values[i], _fake[i], _secret[i]); if (bid.blindedBid != keccak256(value, fake, secret)) &#123; // Bid was not actually revealed. // Do not refund deposit. continue; &#125; refund += bid.deposit; if (!fake &amp;&amp; bid.deposit &gt;= value) &#123; if (placeBid(msg.sender, value)) refund -= value; &#125; // Make it impossible for the sender to re-claim // the same deposit. bid.blindedBid = 0; &#125; msg.sender.transfer(refund); &#125; // This is an \"internal\" function which means that it // can only be called from the contract itself (or from // derived contracts). function placeBid(address bidder, uint value) internal returns (bool success) &#123; if (value &lt;= highestBid) &#123; return false; &#125; if (highestBidder != 0) &#123; // Refund the previously highest bidder. pendingReturns[highestBidder] += highestBid; &#125; highestBid = value; highestBidder = bidder; return true; &#125; /// Withdraw a bid that was overbid. function withdraw() &#123; uint amount = pendingReturns[msg.sender]; if (amount &gt; 0) &#123; // It is important to set this to zero because the recipient // can call this function again as part of the receiving call // before `send` returns (see the remark above about // conditions -&gt; effects -&gt; interaction). pendingReturns[msg.sender] = 0; msg.sender.transfer(amount); &#125; &#125; /// End the auction and send the highest bid /// to the beneficiary. function auctionEnd() onlyAfter(revealEnd) &#123; require(!ended); AuctionEnded(highestBidder, highestBid); ended = true; // We send all the money we have, because some // of the refunds might have failed. beneficiary.transfer(this.balance); &#125;&#125; Solidity Example 4： Remote Purchase123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384pragma solidity ^0.4.11;contract Purchase &#123; uint public value; address public seller; address public buyer; enum State &#123; Created, Locked, Inactive &#125; State public state; function Purchase() payable &#123; seller = msg.sender; value = msg.value / 2; require((2 * value) == msg.value); &#125; modifier condition(bool _condition) &#123; require(_condition); _; &#125; modifier onlyBuyer() &#123; require(msg.sender == buyer); _; &#125; modifier onlySeller() &#123; require(msg.sender == seller); _; &#125; modifier inState(State _state) &#123; require(state == _state); _; &#125; event Aborted(); event PurchaseConfirmed(); event ItemReceived(); /// Abort the purchase and reclaim the ether. /// Can only be called by the seller before /// the contract is locked. function abort() onlySeller inState(State.Created) &#123; Aborted(); state = State.Inactive; seller.transfer(this.balance); &#125; /// Confirm the purchase as buyer. /// Transaction has to include `2 * value` ether. /// The ether will be locked until confirmReceived /// is called. function confirmPurchase() inState(State.Created) condition(msg.value == (2 * value)) payable &#123; PurchaseConfirmed(); buyer = msg.sender; state = State.Locked; &#125; /// Confirm that you (the buyer) received the item. /// This will release the locked ether. function confirmReceived() onlyBuyer inState(State.Locked) &#123; ItemReceived(); // It is important to change the state first because // otherwise, the contracts called using `send` below // can call in again here. state = State.Inactive; // NOTE: This actually allows both the buyer and the seller to // block the refund - the withdraw pattern should be used. buyer.transfer(value); seller.transfer(this.balance); &#125;&#125; Solidity 語法AddressHolds a 20 byte value (size of an Ethereum address) Members of Addressesaddress包含著有以下的properties： balance：地址的餘額 transfer：轉錢到該地址 若有錯誤會發送exception 1234address x = 0x123;address myAddress = this;if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10); // 送給x這個地址 10塊ether send ：也是轉錢到該地址 若有錯誤只會return false，使用要比較小心 call ：傳送參數（.value()）或函式回傳值給合約， delegatecall 1234address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;nameReg.call(&quot;register&quot;, &quot;MyName&quot;);nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a);nameReg.call.value(10); Enums：類似實作interfaceEnums needs at least one member. 123456789101112131415161718192021222324pragma solidity ^0.4.0;contract test &#123; enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125; ActionChoices choice; ActionChoices constant defaultChoice = ActionChoices.GoStraight; function setGoStraight() &#123; choice = ActionChoices.GoStraight; &#125; // Since enum types are not part of the ABI, the signature of \"getChoice\" // will automatically be changed to \"getChoice() returns (uint8)\" // for all matters external to Solidity. The integer type used is just // large enough to hold all enum values, i.e. if you have more values, // `uint16` will be used and so on. function getChoice() returns (ActionChoices) &#123; return choice; &#125; function getDefaultChoice() returns (uint) &#123; return uint(defaultChoice); &#125;&#125; Functional的種類以及參數(constnat,payble) Internal function： can only be called inside the current contract. External function： consist of an address and a function signature and they can be passed via and returned from external function calls. function宣告的格式：123456789function (&lt;parameter types&gt;) &#123;internal|external&#125; [constant] [payable] [returns (&lt;return types&gt;)]parameter types：參數的形式constant：標註該function為read-only，不會改變contract的state.payable： 設定會需要收ether的函式都要加一個payable屬性，如果沒加而有人呼叫該函式順便帶ether的話就會造成errorex:function (address chairman) &#123;&#125; constant payble returns (uint) &#123;&#125;; 兩種方法存取該function: f： will result in an internal function, this.f： an external function. Internal Example: 類似OOD的Protected、不能被其他合約呼叫12345678910111213141516171819202122232425262728293031323334353637383940414243444546pragma solidity ^0.4.5;library ArrayUtils &#123; // internal functions can be used in internal library functions because // they will be part of the same code context function map(uint[] memory self, function (uint) returns (uint) f) internal returns (uint[] memory r) &#123; r = new uint[](self.length); for (uint i = 0; i &lt; self.length; i++) &#123; r[i] = f(self[i]); &#125; &#125; function reduce( uint[] memory self, function (uint, uint) returns (uint) f ) internal returns (uint r) &#123; r = self[0]; for (uint i = 1; i &lt; self.length; i++) &#123; r = f(r, self[i]); &#125; &#125; function range(uint length) internal returns (uint[] memory r) &#123; r = new uint[](length); for (uint i = 0; i &lt; r.length; i++) &#123; r[i] = i; &#125; &#125;&#125;contract Pyramid &#123; using ArrayUtils for *; function pyramid(uint l) returns (uint) &#123; return ArrayUtils.range(l).map(square).reduce(sum); &#125; function square(uint x) internal returns (uint) &#123; return x * x; &#125; function sum(uint x, uint y) internal returns (uint) &#123; return x + y; &#125;&#125; External： 其他合約可以呼叫該合約的function1234567891011121314151617181920212223242526272829pragma solidity ^0.4.11;contract Oracle &#123; struct Request &#123; bytes data; function(bytes memory) external callback; &#125; Request[] requests; event NewRequest(uint); function query(bytes data, function(bytes memory) external callback) &#123; requests.push(Request(data, callback)); NewRequest(requests.length - 1); &#125; function reply(uint requestID, bytes response) &#123; // Here goes the check that the reply comes from a trusted source requests[requestID].callback(response); &#125;&#125;contract OracleUser &#123; Oracle constant oracle = Oracle(0x1234567); // known contract function buySomething() &#123; oracle.query(\"USD\", this.oracleResponse); &#125; function oracleResponse(bytes response) &#123; require(msg.sender == address(oracle)); // Use the data &#125;&#125; 宣告Arrayex:1uint[] memory a = new uint[](7); 宣告 Struct： 類似宣告一個物件模板 1234struct Funder &#123; address addr; uint amount;&#125; Mappings宣告成： mapping(_KeyType =&gt; _ValueType) 的形式，可以看成是hash table的形式， 123456789101112131415161718pragma solidity ^0.4.0;contract MappingExample &#123; mapping(address =&gt; uint) public balances; //設定balances的index為addreess形態的，映射出後會得到uint型態的回傳值。 function update(uint newBalance) &#123; balances[msg.sender] = newBalance; &#125;&#125;contract MappingUser &#123; function f() returns (uint) &#123; MappingExample m = new MappingExample(); m.update(100); return m.balances(this); &#125;&#125; 其他 Operators Involving LValues（可被assign的value)delete a： 把a初始化成 0（也可以用在array 都設成0, struct 都設成初始值) Ether單位Ether Uint：1 ether =1000000000000000000 wei, (10^18)1000 finney, (10^3)1000000 szabo (10^6) 全域可用變數及函式Special Variables and Functions suicide.(A合約): 將目前合約的所有ether都轉入到指定的Ａ合約(contract) delete：回收宣告的成員，並且返回一些gas當作回收的獎勵。 回收各型態的參考資料：http://me.tryblockchain.org/solidity-delete.html Block and Transaction Properties block.blockhash(uint blockNumber) returns (bytes32): hash of the given block - only works for 256 most recent blocks excluding current block.coinbase (address): current block miner’s address block.difficulty (uint): current block difficulty block.gaslimit (uint): current block gaslimit block.number (uint): current block number block.timestamp (uint): current block timestamp as seconds since unix epoch msg.data (bytes): complete calldata msg.gas (uint): remaining gas msg.sender (address): sender of the message (current call) msg.sig (bytes4): first four bytes of the calldata (i.e. function identifier) msg.value (uint): number of wei sent with the message now (uint): current block timestamp (alias for block.timestamp) tx.gasprice (uint): gas price of the transaction tx.origin (address): sender of the transaction (full call chain)(不建議用) Error Handling assert(bool condition):throws if the condition is not met - to be used for internal errors. require(bool condition):throws if the condition is not met - to be used for errors in inputs or external components. revert():abort execution and revert state changes Mathematical and Cryptographic Functions addmod(uint x, uint y, uint k) returns (uint):compute (x + y) % k where the addition is performed with arbitrary precision and does not wrap around at 2**256. mulmod(uint x, uint y, uint k) returns (uint):compute (x * y) % k where the multiplication is performed with arbitrary precision and does not wrap around at 2**256. keccak256(…) returns (bytes32):compute the Ethereum-SHA-3 (Keccak-256) hash of the (tightly packed) arguments sha256(…) returns (bytes32):compute the SHA-256 hash of the (tightly packed) argumentssha3(…) returns (bytes32):alias to keccak256 ripemd160(…) returns (bytes20):compute RIPEMD-160 hash of the (tightly packed) arguments ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):recover the address associated with the public key from elliptic curve signature or return zero on error (example usage) Solidity的表達和控制的結構（Expressions and Control Structures）Input Parameters and Output Parameters 接收參數和回傳的形式12345678910pragma solidity ^0.4.0;contract Simple &#123; // 接收 uint _a , uint _b變數 // 回傳uint -_sum uint o_product function arithmetics(uint _a, uint _b) returns (uint o_sum, uint o_product) &#123; o_sum = _a + _b; o_product = _a * _b; &#125;&#125; External Function Calls如果要得知呼叫某合約的function會有多少Wei和花費多少gas，可用.value() .gas() 範例中的function info() 如果沒有加上 payable這個keyword，就無法使用 .value() 123456789101112pragma solidity ^0.4.0;contract InfoFeed &#123; // function info() payable returns (uint ret) &#123; return 42; &#125;&#125;contract Consumer &#123; InfoFeed feed; function setFeed(address addr) &#123; feed = InfoFeed(addr); &#125; function callFeed() &#123; feed.info.value(10).gas(800)(); &#125;&#125; Creating Contracts via new123456789101112131415161718192021pragma solidity ^0.4.0;contract D &#123; uint x; function D(uint a) payable &#123; x = a; &#125;&#125;contract C &#123; D d = new D(4); // will be executed as part of C's constructor function createD(uint arg) &#123; D newD = new D(arg); &#125; function createAndEndowD(uint arg, uint amount) &#123; // Send ether along with the creation D newD = (new D).value(amount)(arg); &#125;&#125; Error handling: Assert, Require, Revertand Exceptions require can be used to easily check conditions on inputs. assert can be used for internal error checking. 1234567891011121314pragma solidity ^0.4.0;contract Sharer &#123; function sendHalf(address addr) payable returns (uint balance) &#123; require(msg.value % 2 == 0); // Only allow even numbers uint balanceBeforeTransfer = this.balance; addr.transfer(msg.value / 2); // Since transfer throws an exception on failure and // cannot call back here, there should be no way for us to // still have half of the money. assert(this.balance == balanceBeforeTransfer - msg.value / 2); return this.balance; &#125;&#125; assert 發生的狀況： If you access an array at a too large or negative index (i.e. x[i] where i &gt;= x.length or i &lt; 0). If you access a fixed-length bytesN at a too large or negative index. If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0). If you shift by a negative amount. If you convert a value too big or negative into an enum type. If you call a zero-initialized variable of internal function type. If you call assert with an argument that evaluates to false. require 發生的狀況： Calling throw. Calling require with an argument that evaluates to false. If you call a function via a message call but it does not finish properly (i.e. it runs out of gas, has no matching function, or throws an exception itself), except when a low level operation call, send, delegatecall or callcode is used. The low level operations never throw exceptions but indicate failures by returning false. If you create a contract using the new keyword but the contract creation does not finish properly (see above for the definition of “not finish properly”). If you perform an external function call targeting a contract that contains no code. If your contract receives Ether via a public function without payable modifier (including the constructor and the fallback function). If your contract receives Ether via a public getter function. If a .transfer() fails. Solidity Contract(即Class)創建contract的時候，constructor只會被呼叫一次 合約的Visibility and GettersVisibility： external:External functions are part of the contract interface, which means they can be called from other contracts and via transactions. An external function f cannot be called internally (i.e. f() does not work, but this.f() works). External functions are sometimes more efficient when they receive large arrays of data. public:Public functions are part of the contract interface and can be either called internally or via messages. For public state variables, an automatic getter function (see below) is generated. internal:Those functions and state variables can only be accessed internally (i.e. from within the current contract or contracts deriving from it), without using this. private:Private functions and state variables are only visible for the contract they are defined in and not in derived contracts. Getter Functions123456789pragma solidity ^0.4.0;contract C &#123; uint public data; function x() &#123; data = 3; // internal access 當成state變數 uint val = this.data(); // external access 當成是function &#125;&#125; Function Modifier (類似：函式插槽)Modifier可用用來擴充其他function的內容，需要被inherit才能使用。通常modifier用來設定一些條件，幫助函式被執行時能夠先滿足該條件再被執行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172pragma solidity ^0.4.11;contract owned &#123; function owned() &#123; owner = msg.sender; &#125; address owner; // 該owned合約只有宣告一個modifier onlyOwner，並且沒有使用它 // 該modifier只會被其他有繼承owned contract的合約所使用 // // \"_;\" 要繼承onlyOwner 函式的內容 modifier onlyOwner &#123; require(msg.sender == owner); _; &#125;&#125;contract mortal is owned &#123; // 繼承 owned合約 // close函式 使用modifier \"onlyOwner\" // 且close的內容會插入在 modifier中的 \"_;\"中 // 可以把modifier想像成 slot（插槽) function close() onlyOwner &#123; selfdestruct(owner); &#125;&#125;contract priced &#123; // Modifier 也可以接收參數 modifier costs(uint price) &#123; // 若滿足msg.value &gt;= price 那就執行 使用該modifier函式的內容 if (msg.value &gt;= price) &#123; _; &#125; &#125;&#125;contract Register is priced, owned &#123; mapping (address =&gt; bool) registeredAddresses; uint price; function Register(uint initialPrice) &#123; price = initialPrice; &#125; // 需要提供 payable，register才會接受ether // 使用 costs 的modifier . function register() payable costs(price) &#123; registeredAddresses[msg.sender] = true; &#125; function changePrice(uint _price) onlyOwner &#123; price = _price; &#125;&#125;contract Mutex &#123; bool locked; modifier noReentrancy() &#123; require(!locked); locked = true; _; locked = false; &#125; // noReentrancy 被一個mutex所保護，必須要判斷locked是否是false才能執行 noReentrancy才能執行 // reentrant calls from within // msg.sender.call cannot call f again.因爲lock住了 // 使用 noReentrancy(modifier), function f() noReentrancy returns (uint) &#123; require(msg.sender.call()); return 7; &#125;&#125; Constant State Variables目前僅支援 uint, string使用 宣告一次後就不能再被改變 Constant Functions不會改變contract state的值 1234567pragma solidity ^0.4.0;contract C &#123; function f(uint a, uint b) constant returns (uint) &#123; return a * (b + 42); &#125;&#125; Fallback Function沒有名稱的function,並且沒有接收參數以及不會傳任何值。當呼叫某合約的方法時，沒有辦法成功 如果有合約直接收到ether的話（亦即不是透過send() or transfer() 那就得定義一個fallback function，不然會throw an exception. 1234567891011121314151617181920212223242526pragma solidity ^0.4.0;contract Test &#123; function() &#123; x = 1; &#125; uint x;&#125;// This contract keeps all Ether sent to it with no way// to get it back.contract Sink &#123; function() payable &#123; &#125;&#125;contract Caller &#123; function callTest(Test test) &#123; test.call(0xabcdef01); // hash: 0xabcdef01 不存在 // 故 test.x的結果會變成 test.x = 1 // The following will not compile, but even // if someone sends ether to that contract, // the transaction will fail and reject the // Ether. //test.send(2 ether); &#125;&#125; EventsEvent所寫入的資料會被記錄在一個Receipt（transaction logs)資料裡，並等待被打包進區塊鏈。 白話一點就是：通知全網有一件事情發生。 12345678910111213141516pragma solidity ^0.4.0;contract ClientReceipt &#123; event Deposit( address indexed _from, bytes32 indexed _id, uint _value ); function deposit(bytes32 _id) payable &#123; // Any call to this function (even deeply nested) can // be detected from the JavaScript API by filtering // for `Deposit` to be called. Deposit(msg.sender, _id, msg.value); &#125;&#125; 在javascript API的使用方式如下：1234567891011121314151617181920var abi = /* abi as generated by the compiler */;var ClientReceipt = web3.eth.contract(abi);var clientReceipt = ClientReceipt.at(0x123 /* address */);var event = clientReceipt.Deposit();// watch for changesevent.watch(function(error, result)&#123; // result will contain various information // including the argumets given to the Deposit // call. if (!error) console.log(result);&#125;);// Or pass a callback to start watching immediatelyvar event = clientReceipt.Deposit(function(error, result) &#123; if (!error) console.log(result);&#125;); Inheritance使用 is 來繼承其他contract. 提供多重繼承同時也包含多型當一個合約R繼承其他A,B,C的合約時，只有R的合約被打包進去blockchain，其他ABC不會。（因為是將A,B,C的內容複製到R的合約內) 像是Python的繼承特性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556pragma solidity ^0.4.0;contract owned &#123; function owned() &#123; owner = msg.sender; &#125; address owner;&#125;// 使用 \"is\" 來繼承，可以存取繼承合約的 non-private members (包含 internal function and state variables)，無法透過 this 來做externally access.contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125;&#125;// 當成是 interface，等待被繼承實作contract Config &#123; function lookup(uint id) returns (address adr);&#125;contract NameReg &#123; function register(bytes32 name); function unregister();&#125;// 可以實現多重繼承// 注意的是\"owned\" 一樣也被mortal繼承，故只有一個\"owned\"的instance (和C++的vritual inheritance一樣)contract named is owned, mortal &#123; function named(bytes32 name) &#123; Config config = Config(0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970); NameReg(config.lookup(1)).register(name); &#125;// 可以override 繼承的function.注意要與原本的型態要一致 function kill() &#123; if (msg.sender == owner) &#123; Config config = Config(0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970); NameReg(config.lookup(1)).unregister(); // 依然可以呼叫繼承合約內的函式 mortal.kill(); &#125; &#125;&#125;// 如果繼承的contract中有的人的contractor需要parameter,// 那就得在 is 後面的地方輸入參數，// 如下 \"named(\"GoldFeed\");contract PriceFeed is owned, mortal, named(\"GoldFeed\") &#123; function updateInfo(uint newInfo) &#123; if (msg.sender == owner) info = newInfo; &#125; function get() constant returns(uint r) &#123; return info; &#125; uint info;&#125; 多重繼承要注意的點：12345678910111213141516171819202122232425pragma solidity ^0.4.0;contract owned &#123; function owned() &#123; owner = msg.sender; &#125; address owner;&#125;contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125;&#125;contract Base1 is mortal &#123; function kill() &#123; /* do cleanup 1 */ mortal.kill(); &#125;&#125;contract Base2 is mortal &#123; function kill() &#123; /* do cleanup 2 */ mortal.kill(); &#125;&#125;contract Final is Base1, Base2 &#123;&#125; 呼叫 Final.kill 僅會呼叫到 Base2的 kill function.而忽略掉 Base1 的. Abstract Contracts不實作合約內的function內容，被繼承時在實作。但可以定義變數，建構子等等。 例子：12345pragma solidity ^0.4.0;contract Feline &#123; function utterance() returns (bytes32);&#125; Interfaces和Abstract很像，不過不能有任何的function被實作以下為限制條件 Cannot inherit other contracts or interfaces. Cannot define constructor. Cannot define variables. Cannot define structs. Cannot define enums. 12345pragma solidity ^0.4.11;interface Token &#123; function transfer(address recipient, uint amount);&#125; Libraries和contract(class)很像，不過僅會在特地的address部署一次而已。 因為佈一個contract需要gas，不過如果要重複使用Set的話，又不想重複宣告contract，那就可以用Libraries來實作出一個Set，並且佈出去就會產生一個地址 (linker)，其他合約就可以透過linker來使用Set. 直接看例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950pragma solidity ^0.4.11;library Set &#123; // We define a new struct datatype that will be used to // hold its data in the calling contract. struct Data &#123; mapping(uint =&gt; bool) flags; &#125; // Note that the first parameter is of type \"storage // reference\" and thus only its storage address and not // its contents is passed as part of the call. This is a // special feature of library functions. It is idiomatic // to call the first parameter 'self', if the function can // be seen as a method of that object. function insert(Data storage self, uint value) returns (bool) &#123; if (self.flags[value]) return false; // already there self.flags[value] = true; return true; &#125; function remove(Data storage self, uint value) returns (bool) &#123; if (!self.flags[value]) return false; // not there self.flags[value] = false; return true; &#125; function contains(Data storage self, uint value) returns (bool) &#123; return self.flags[value]; &#125;&#125;contract C &#123; Set.Data knownValues; function register(uint value) &#123; // The library functions can be called without a // specific instance of the library, since the // \"instance\" will be the current contract. require(Set.insert(knownValues, value)); &#125; // In this contract, we can also directly access knownValues.flags, if we want.&#125; Style Guide （套用eslint for solidity) Indentation: 4 spaces (avoid using tabs.) Order of Functions: (function的寫法的優先順序) constructor fallback function (if exists) external public internal private Web3.js 學習目標瞭解：1.如何把key pair抓出來2.如何簽驗章3.如何進行加解密4.如何發events 環簽章 同態加密Confidential transaction（https://www.elementsproject.org/elements/confidential-transactions/ ZKsnark(包含零知識證明)參考：（應用例子：不公開UTXO，也能讓礦工驗證，不過礦工不能解密，不然會失去confidential的特性，不讓receiver知道UTXO）https://z.cash/technology/zksnarks.html","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://a10000005588.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/tags/Solidity/"}]},{"title":"使用truffle來練習撰寫認養寵物的智能合約","slug":"truffle-petshop","date":"2017-09-07T14:02:57.000Z","updated":"2020-07-26T09:17:54.837Z","comments":true,"path":"2017/09/07/truffle-petshop/","link":"","permalink":"http://a10000005588.github.io/2017/09/07/truffle-petshop/","excerpt":"本篇是翻譯自Truffle官方所釋出的Dapp教學文檔Pet-Shophttp://truffleframework.com/tutorials/pet-shop 執行環境開發前準備首先要安裝testrpc、truffle :12345npm install -g ethereumjs-testrpc// 安裝測試用ethereum私有鍊npm install -g truffle// 開發智能合約的一套框架","text":"本篇是翻譯自Truffle官方所釋出的Dapp教學文檔Pet-Shophttp://truffleframework.com/tutorials/pet-shop 執行環境開發前準備首先要安裝testrpc、truffle :12345npm install -g ethereumjs-testrpc// 安裝測試用ethereum私有鍊npm install -g truffle// 開發智能合約的一套框架 安裝truffle上已經預先包好的練習專案(Truffle box: ETHEREUM PET SHOP)：12345678mkdir pet-shop-tutorial // 創建一個目錄cd pet-shop-tutorial // 切換到該目錄truffle unbox pet-shop// 安裝truffle打包好的pet-shop練習專案檔 目錄架構 /contracts: 存放合約的地方，檔名為.sol，而Migrate.sol是負責紀錄其他合約如何deploy到區塊鏈，不能刪除！ /migrations: 負責將合約掛到區塊鏈上，並且追蹤合約的更動狀況。 /test: 包含Javascript and solidity檔案，負責測試合約內容。 truffle.js : truffle的設定檔 合約內容在/contract 建立 Adoption.sol宣告一個contract:12345678910111213141516171819202122232425262728pragma solidity ^0.4.4;// 告訴compiler 現在要用哪個版本編譯contract Adoption &#123; //宣告一個 contract的class 叫 Adoption // 存放領養飼主的地址（預設是有16隻狗等待被認養） address[16] public adopters; // 有人要認養某隻寵物(petId)，判斷是否可以認養， // 回傳該認養的寵物ID以證明該寵物成功被某用戶認養 function adopt(uint petId) public returns (uint) &#123; require(petId &gt;= 0 &amp;&amp; petId &lt;= 15); // 判斷petId，若不符合結束該函式，不再往下執行 adopters[petId] = msg.sender; // 透過msg.sender取得呼叫該函式的使用者 // 也就是認養該寵物的用戶ID return petId; &#125; // 回傳所有的認養者，回傳值的型態為address[16] function getAdopters() public returns (address[16]) &#123; return adopters; &#125; &#125; 編譯(Compiling)和部署(Migrating)合約寫好合約後，需要將.sol檔進行編譯成.bytecode，才能在EVM (ethereum virtual machine上執行). 然後在terminal上執行 testrpc 啟動 啟動後會出現： 數組帳戶的address以及私鑰 HD wallet的資訊（稍後會提到metatask，會使用到Mnemonic section的資訊) Mnemonic為數個變數的資訊，如下Mnemonic: spider level team helmet shaft clarify abuse recipe stem ankle angry fee 執行 truffle compile 會看到 .sol檔被編譯 Migrationmigrate.sol描述如何將合約的內容部署到鏈上，並且處理合約上state的更動。 在 /migration 檔案內： 1_initial_migration.js： 123456// 引入編譯合約的內容var Migrations = artifacts.require(\"./Migrations.sol\");module.exports = function(deployer) &#123; deployer.deploy(Migrations);&#125;; 透過該檔案可以追蹤後續contract的變化，已部署過的合約且沒有被修改就不用再被部署（不然又會消耗gas). 2_deploy_contracts.js注意，這邊的命名開頭要編號，因為truffle進行migrate時會依據該編號而進行。 12345var Adoption = artifacts.require(\"./Adoption.sol\");module.exports = function(deployer) &#123; deployer.deploy(Adoption);&#125;; 在terminal執行 truffle migrate 會看到如下結果123456789101112Using network &apos;development&apos;.Running migration: 1_initial_migration.js Deploying Migrations... Migrations: 0x75175eb116b36ff5fef15ebd15cbab01b50b50d1Saving successful migration to network...Saving artifacts...Running migration: 2_deploy_contracts.js Deploying Adoption... Adoption: 0xb9f485451a945e65e48d9dd7fc5d759af0a89e21Saving successful migration to network...Saving artifacts... 若看到上述表面表示我們寫的第一隻 Adoption.sol的合約已經成功被部署到鏈上！ 為Smart Contract寫測試我們可以用javascript或solidity寫測試，不過本範例用solidity來寫。 在 /test 目錄下創建 TestAdoption.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748pragma solidity ^0.4.11;// 引用truffle內建的檔案 // Assert.sol用來做Unit test (判斷function input ?= output)import \"truffle/Assert.sol\";// 當測試執行，truffle會在testrpc中測試該合約，// 該DeployedAddresses用來取得被部署合約的addressimport \"truffle/DeployedAddresses.sol\";// 要被測試的合約import \"../contracts/Adoption.sol\";contract TestAdoption &#123; Adoption adoption = Adoption(DeployedAddresses.Adoption()); // Testing The adopt() Function function testUserCanAdoptPet() &#123; // 呼叫Adoption中的adopt方法 uint returnedId = adoption.adopt(8); uint expected = 8; // 判斷returnID 是否等於 expected的值 Assert.equal(returnedId, expected, \"Adoption of pet ID 8 should be recorded.\"); &#125; // Testing Retrieval of a Single Pet's Owner function testGetAdopterAddressByPetId() &#123; // 透過this取得目前合約的地址 address expected = this; address adopter = adoption.adopters(8); Assert.equal(adopter, expected, \"Owner of pet ID 8 should be recorded.\"); &#125; // Testing Retrieval of All Pet Owners function testGetAdopterAddressByPetIdInArray() &#123; address expected = this; address[16] memory adopters = adoption.getAdopters(); Assert.equal(adopters[8], expected, \"Owner of pet ID 8 should be recorded.\"); &#125; &#125; 執行 truffle test 若看到以下畫面表示test通過123456789101112131415Using network &apos;development&apos;.Compiling ./contracts/Adoption.sol...Compiling ./test/TestAdoption.sol...Compiling truffle/Assert.sol...Compiling truffle/DeployedAddresses.sol... TestAdoption ✓ testUserCanAdoptPet (91ms) ✓ testGetAdopterAddressByPetId (70ms) ✓ testGetAdopterAddressByPetIdInArray (89ms) 3 passing (670ms) 使用UI和Smart Contract互動當解開truffle box的pet-shop，可以看到在 /src目錄底下會有已經預設好的UI檔供練習用。 使用Web3.js初始化前端環境Web3.js為用來和ethereum溝通的javascript library.（而練習專案前端是使用jQuery) 在 /src/js/app.js檔案的內容改為以下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131App = &#123; web3Provider: null, contracts: &#123;&#125;, init: function() &#123; // 載入寵物的資料 $.getJSON('../pets.json', function(data) &#123; var petsRow = $('#petsRow'); var petTemplate = $('#petTemplate'); for (i = 0; i &lt; data.length; i ++) &#123; petTemplate.find('.panel-title').text(data[i].name); petTemplate.find('img').attr('src', data[i].picture); petTemplate.find('.pet-breed').text(data[i].breed); petTemplate.find('.pet-age').text(data[i].age); petTemplate.find('.pet-location').text(data[i].location); petTemplate.find('.btn-adopt').attr('data-id', data[i].id); petsRow.append(petTemplate.html()); &#125; &#125;); return App.initWeb3(); &#125;, initWeb3: function() &#123; // 初始化web3.js並且設置provider連接testrpc // 如果偵測到有metamask注入在瀏覽器的web3 instance if (typeof web3 !== 'undefined') &#123; App.web3Provider = web3.currentProvider; // 將currentProvider = metamask // web3 = new Web3(web3.currentProvider); &#125; else &#123; // 若沒有metamask or mist等等之類的， // 那就用自己開啟testrpc當成是provider App.web3Provider = new web3.providers.HttpProvider('http://localhost:8545'); web3 = new Web3(App.web3Provider); &#125; return App.initContract(); &#125;, initContract: function() &#123; $.getJSON('Adoption.json', function(data) &#123; // 取得contract的artifact(Adoption.json) // 例如contract address, ABI (Application Binary Interface)： // 即如何使用contract的變數、函式等等 var AdoptionArtifact = data; // truffle提供`truffle-contract`來幫助我們監聽已經被migrate的contract // 並把contract的artifact傳給truffle-contract'，好讓我們可以跟合約溝通 App.contracts.Adoption = TruffleContract(AdoptionArtifact); // 為contract設置Provider(我們是用metamask) App.contracts.Adoption.setProvider(App.web3Provider); // 從Adpotion.json的合約資料中，判斷寵物的是否已被認養並做標示 return App.markAdopted(); &#125;); return App.bindEvents(); &#125;, bindEvents: function() &#123; $(document).on('click', '.btn-adopt', App.handleAdopt); &#125;, handleAdopt: function() &#123; event.preventDefault(); var petId = parseInt($(event.target).data('id')); var adoptionInstance; // 使用web3來取得user's accounts // 這時metamask會跳出交易訊息出來 web3.eth.getAccounts(function(error, accounts) &#123; if (error) &#123; console.log(error); &#125; // 選擇第一個accounts作為我們的用戶 var account = accounts[0]; App.contracts.Adoption.deployed().then(function(instance) &#123; adoptionInstance = instance; // 在這裡要執行會花費gas的transaction // 取得認養用戶的account，以及點選欲認養的petId return adoptionInstance.adopt(petId, &#123;from: account&#125;); &#125;).then(function(result) &#123; // 若回傳結果正常執行markAdopted刷新UI上寵物認養中的狀態 return App.markAdopted(); &#125;).catch(function(err) &#123; console.log(err.message); &#125;); &#125;); &#125;, markAdopted: function(adopters, account) &#123; var adoptionInstance; App.contracts.Adoption.deployed().then(function(instance) &#123; // 取得Adpotion合約的內容 adoptionInstance = instance; // 呼叫合約中的getAdopters方法 // 利用`call`可以直接讀取Blockchain上的資料，不用花費ether(gas) return adoptionInstance.getAdopters.call(); &#125;).then(function(adopters) &#123; for (i = 0; i &lt; adopters.length; i++) &#123; if (adopters[i] !== '0x0000000000000000000000000000000000000000') &#123; $('.panel-pet').eq(i).find('button').text('Pending...').attr('disabled', true); &#125; &#125; &#125;).catch(function(err) &#123; console.log(err.message); &#125;); &#125;&#125;;$(function() &#123; $(window).load(function() &#123; App.init(); &#125;);&#125;); 在Chrome上和Dapp互動安裝 metamask的擴充套件 長這樣： 由於我們要測試自己的Dapp，點選該圖左上角切換到自己開啟testrpc:8545的私有鏈 因為是初次登入，點選I forgot my password 將一開始開啟testrpc 產生的 Mnemonic（數組變數名稱）貼到wallet seed.Mnemonic:1spider level team helmet shaft clarify abuse recipe stem ankle angry fee (Warning：你的testrpc產生的Mnemonic變數組會跟上面的不一樣) 設置自己的新密碼，確認後點選OK 進入後就會看到自己的第一筆account資訊了 若有顯示帳戶表示成功與testrpc連接(原本testrpc是預設100 ether，顯示出來不是100 ether的原因是因為部署合約到自己的private blockchain也需要費用) 安裝和設置lite-server啟動Dapplite-server已經包含在pet-shop的box內 在 bs-config.json檔案中 12345&#123; &quot;server&quot;: &#123; &quot;baseDir&quot;: [&quot;./src&quot;, &quot;./build/contracts&quot;] &#125;&#125; 該設置告訴server要執行的基底目錄在哪。 ./src：前端的內容./build/contracts：放置合約的內容 在script檔中 1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;lite-server&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;&#125;, 設置 &quot;dev&quot; : lite-server&quot;方便我們可以直接在terminal下執行 npm run dev 來運行Dapp 運行成功後的樣子 若要進行認養：點選 Adopt按鈕 點選Sumit後即完成認養的動作，並且把該認養的資訊透過合約掛到testrpc的鏈上，並在該寵物上狀態改成 Pending... （已認養） 延伸 將前端改成用Vue.js可以考慮用以下package： Vue-Truffle-Webpackhttps://github.com/wilfreddenton/vue-truffle-webpack 顯示該隻狗被哪位用戶認養走 改成要付足夠的錢才能認養該隻狗","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/tags/Solidity/"},{"name":"Truffle","slug":"Truffle","permalink":"http://a10000005588.github.io/tags/Truffle/"}]},{"title":"利用Hexo來記錄自己的學習並使用Material-flow主題","slug":"How_To_Use_Hexo","date":"2017-09-05T14:58:47.000Z","updated":"2021-01-28T12:26:55.742Z","comments":true,"path":"2017/09/05/How_To_Use_Hexo/","link":"","permalink":"http://a10000005588.github.io/2017/09/05/How_To_Use_Hexo/","excerpt":"如果要打造自己風格的Blog，那就不能錯過HexoHexo是一套開源的架個人部落格的框架，","text":"如果要打造自己風格的Blog，那就不能錯過HexoHexo是一套開源的架個人部落格的框架， 其優點如下： 文章以markdown格式為主。 並且能一鍵部署在Github，公開給大家看。 有很多第三方的template theme來裝飾自己的Blog 我目前這個Blog的主題是使用NextT囉 以下會詳細介紹怎麼用Hexo快速架站 Hexo架設流程安裝Hexo1npm install hexo-cli -g 初始化一個Hexo專案，並且運行之1234567hexo init blogcd blognpm installhexo server// 也可以用 hexo s -p 8080 // 指定欲開啟的port number為多少 可以看到新建立好的Blog長這樣 (X) 新增一篇文章1hexo new [layout] &lt;title&gt; [layout]有以下幾種(default為 post)： post：就po一篇文章，文章都放置在 source/_posts中 page：建立獨立的頁面，例如建立about頁面 draft：發佈一篇草稿，如果要公開則下 hexo publish [layout] &lt;title&gt;，將草稿移動到 source/_posts 佈署到自己的github安裝 hexo-deployer-git1npm install hexo-deployer-git --save 修改 _config.yml12345deploy: type: git repo: &lt;repository url&gt; // 儲存庫（Repository）網址 branch: [branch] // 分支名稱 message: [message] // 自定提交訊息 新增好文章後需要產生部署用靜態檔案執行：hexo generate 會產生public目錄 執行 hexo deploy 即可一鍵部署public目錄內容到github.io網站上 注意：github上的repo命名要與你的帳號一樣，否則還得處理路徑問題 若要直接新增好文章後部署：hexo generate --deploy 之後若要重新執行hexo deploy，請先用 hexo clean清除靜態頁面，然後在執行deploy. 使用Material-flow 來改造自己的Blog詳情請看Material-flow 的Github上文件 https://github.com/stkevintan/hexo-theme-material-flow 修改自己的Description在大頭貼下方的描述，若要修改的話得到： ./theme/material-flow/layout/_widget/about.ejs中修改！ 延伸若要對自己Blog做擴充都可以再參考Hexo以及NextT的官方文檔 Hexo官方連結：https://hexo.io/zh-tw/ 如果對其他theme有興趣也可以參考這網站 Hexo官方主題：https://hexo.io/zh-tw/docs/writing.htmlHexo主題排名：https://www.zhihu.com/question/24422335","categories":[{"name":"Note","slug":"Note","permalink":"http://a10000005588.github.io/categories/Note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"http://a10000005588.github.io/tags/Note/"}]}]}
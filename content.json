{"meta":{"title":"William's 隨手札記","subtitle":"Blog of William","description":"Just record it.","author":"William L.K.","url":"http://a10000005588.github.io"},"pages":[],"posts":[{"title":"下班自修的經驗分享","slug":"下班自修的經驗分享","date":"2020-05-16T12:47:39.000Z","updated":"2020-05-16T14:48:46.294Z","comments":true,"path":"2020/05/16/下班自修的經驗分享/","link":"","permalink":"http://a10000005588.github.io/2020/05/16/下班自修的經驗分享/","excerpt":"最近剛好在Backend版上看到有人Po文問說: “下班後要如何精進自修”, 意外看到許多大大們在下面留言, 正好最近我也在思考要如何精進自己, 所以趁這機會來統整一下大大們提出來的想法並且與自己目前的進修方式做結合, 主要會以Full-Stack engineer的精進方式來做個紀錄分享.","text":"最近剛好在Backend版上看到有人Po文問說: “下班後要如何精進自修”, 意外看到許多大大們在下面留言, 正好最近我也在思考要如何精進自己, 所以趁這機會來統整一下大大們提出來的想法並且與自己目前的進修方式做結合, 主要會以Full-Stack engineer的精進方式來做個紀錄分享. 如果對某程式語言&amp;框架掌握度還不夠, 請先熟悉之！如果上班接觸到某種自己不熟悉的語言或框架, 像我就是畢業後被公司指派要寫Java &amp; Spring, 與Angular &amp; Typescript. 所以我會偏好先到線上程式語言線上平台進修之, 因為這些學習平台能夠提供完整的學習輪廓, 能夠讓我快速掌握該程式語言&amp;框架所需具備的硬知識為何. 說到線上程式學習平台, 我蠻推薦 Pluralsight, 因為該平台提供了該程式語言或框架推薦學習的影片, 並且透過測驗推估你對該技術的知識程度為何. 有興趣可以到該平台試試看, 不過每個月會收取29美元的花費, 不過這花費當作投資是蠻值得的. 若已經對程式語言&amp;框架有經驗, 可以嘗試看看Side Project為什麼會特地提到Side Project?? 那是因為在公司其實很難自己能夠負責專案的所有全貌, 例如可能只是負責寫API, 也可能只負責前端頁面的刻畫. 所以透過Side Project, 便能夠有機會嘗試所有技術的機會, 並且從中去體會到自己最想要加強的領域是哪邊, 例如後端效能? 前端渲染速度? Container, CI/CD的運作? 諸如此類, 從而培養一個Full-Stack的經驗. 所以下班後自己跑一個Side Project是個不錯的精進方式. 但要怎麼樣想出一個Side Project?我覺得學習最快的方式就是模仿, 可以到Github上搜尋有興趣的專案, 並且試著用自己的程式語言與框架自己做出一套是最快的方式. 像我因為很喜歡用Markdown方式來做筆記, 目前打算自己做個小型的線上筆記編輯系統, 並看到Github上有提供CodiMD 的開源專案可參考, 來試著自己建造出一個看看. 之後會再分享到自己的部落格上怎麼一步一步進行的. 嘗試撰寫線上筆記或部落格吧我認為現在技術真的太多太多了, 如果沒有將自己看過的技術文章或學習影片給消化和記錄起來, 很快就又會忘記. 所以最好的方式是有個做筆記的習慣! 做筆記的話我都是用Hackmd先記錄起來, 之後等有空的時間會再消化審視自己寫過的內容, 並發佈到自己的Bloger上, 這樣有助於將學習過的知識給內化到自己的腦海中. 其他更進階的進修方法根據技能樹(RoadMap)來補充自己最常用,有興趣但所缺乏的觀念與技術這網站Roadmap提供了各開發者(Frontend, Backend, DevOps)所需要具備的技能樹為何, 若想要往後端精進, 可以看到下面這張圖會碰到哪些所需具備的能力. 看完之後會發覺有太多東西需要Cover了, 學海無涯 (茶). 經營 Stackoverflow這點是我看到大大們提出來可以嘗試的方式, 不過我目前也只有在Stackoverflow上面問幾個小問題, 對這方面還沒有涉略, 可參考下面大大所寫的Stackoverflow的介紹, 未來我會想在這邊嘗試看看能不能也試著回答別人遇到的問題. 工程師鍛鍊接軌世界的能力從stackoverflow 開始 - 阿貝好威的實驗室 小結下班後要再自修真的需要有興趣使然以及強大的毅力, 否則很容易就會半途而廢. 所以最重要的還是要讓自己有個規劃, 並且從實踐規劃中內化成自己的日常習慣, 久而久之就會讓自己變得更強的！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://a10000005588.github.io/tags/Life/"}]},{"title":"2020年的想法","slug":"2020年的想法與自修規劃","date":"2020-01-01T13:30:48.000Z","updated":"2020-01-01T14:22:47.890Z","comments":true,"path":"2020/01/01/2020年的想法與自修規劃/","link":"","permalink":"http://a10000005588.github.io/2020/01/01/2020年的想法與自修規劃/","excerpt":"回顧了一下2019年對自己的期許，自己與期許的似乎還有所差距，就再接再厲。","text":"回顧了一下2019年對自己的期許，自己與期許的似乎還有所差距，就再接再厲。 希望今年強化自身的網站開發的實力(以後端為主)接下來2020年想要趁下班閒暇時間時來做： 刷刷leetcode 找一個side project來經營 (預計用Java Spring Boot後端, Angular前端) 複習資料結構，資料庫SQL語法等 以上繼續精進，自我勉勵","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://a10000005588.github.io/tags/Life/"}]},{"title":"如何查看透過智能合約存在以太坊上的資料？","slug":"checksmartcontractdata","date":"2019-02-10T15:25:43.000Z","updated":"2019-02-10T15:36:44.807Z","comments":true,"path":"2019/02/10/checksmartcontractdata/","link":"","permalink":"http://a10000005588.github.io/2019/02/10/checksmartcontractdata/","excerpt":"在看這篇文章之前必須要知道一件事，那就是透過智能合約存在區塊鏈上的資訊都是公開的。","text":"在看這篇文章之前必須要知道一件事，那就是透過智能合約存在區塊鏈上的資訊都是公開的。 不管你是否有在智能合約上面有用requre(), revert(), assert()等等來限制某地址的人來存取智能合約上的變數，但這些變數都會存以太坊EVM的Storage上面，每個節點都可以透過以下方式來對EVM的Storage內的編碼進行解析，並還原當初透過合約所儲存的變數資料！！！ 以下透過一個範例來瞭解如何透過web3.js library中的eth.getStorage()方法來解析Storage內儲存的資訊。 智能合約範例：123456789101112131415161718192021222324252627282930313233343536373839404142434445prama solidity ^0.4.0;contract testStorage &#123; uint storeduint1 = 15; uint constant constuint = 16; uint128 investmentsLimit = 17055; uint32 investmentsDeadlinedTimeStamp = uint32(now); bytes16 string1 = 'test1'; bytes32 string2 = 'test1236'; string string3 = 'lets string something'; mapping (address =&gt; uint) uints1; mapping (address =&gt; DeviceData) structs1; uint[] uintarray; DeviceData[] deviceDataArray; struct DeviceData &#123; string deviceBrand; string deviceYear; string batteryWearLevel; &#125; function testStorage() &#123; address address1 = 0xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6 address address2 = 0xaee905fdd3ed851e48d22059575b9f4245a82b04; uints1[address1] = 88; uints1[address2] = 99; var dev1 = DeviceData('deviceBrand', 'deviceYear', 'wearLevel'); var dev2 = DeviceData('deviceBrand2', 'deviceYear2', 'wearLevel2'); structs1[addresss1] = dev1; structs1[addresss2] = dev2; uintarray.push(8000); uintarray.push(9000); deviceDataArray.push(dev1); deviceDataArray.push(dev2); &#125;&#125; 假設我們合約的地址是在：0xf1f5896ace3a78c347eb7eab503450bc93bd0c3b 所有儲存在storage內的參數都可以用index來索引，index的格式為256 bytes以及對應64碼。在以上的範例中我們有 10個參數，所以可以透過index來一一遍歷他們： 12345678910111213141516let contractAddress = &apos;0xf1f5896ace3a78c347eb7eab503450bc93bd0c3b&apos;for (index = 0; index &lt; 10; index++)&#123; console.log(`[$&#123;index&#125;]` + web3.eth.getStorageAt(contractAddress, index))&#125;result:[0] 0x000000000000000000000000000000000000000000000000000000000000000f[1] 0x00000000000000000000000059b92d9a0000000000000000000000000000429f[2] 0x0000000000000000000000000000000074657374310000000000000000000000[3] 0x7465737431323336000000000000000000000000000000000000000000000000[4] 0x6c65747320737472696e6720736f6d657468696e67000000000000000000002a[5] 0x0000000000000000000000000000000000000000000000000000000000000000[6] 0x0000000000000000000000000000000000000000000000000000000000000000[7] 0x0000000000000000000000000000000000000000000000000000000000000002[8] 0x0000000000000000000000000000000000000000000000000000000000000002[9] 0x0000000000000000000000000000000000000000000000000000000000000000 開始針對合約內的10個變數一一做遍歷和解析 index 0 - storeduint11234567let contractAddress = &apos;0xf1f5896ace3a78c347eb7eab503450bc93bd0c3b&apos;let index = 0console.log(web3.eth.getStorageAt(contractAddress, index))console.log(&apos;DEC:&apos; + web3.toDecimal(web3.eth.getStorageAt(contractAddress, index)))result:0x000000000000000000000000000000000000000000000000000000000000000fDEC:15 constuintConstants(常數) 不會被存在storage內，只能夠透過code來存取 index 1 - investmentsLimit, investmentsDeadlineTimeStamp12345let index = 1console.log(web3.eth.getStorageAt(contractAddress, index))result: 0x00000000000000000000000059b92d9a0000000000000000000000000000429fDEC: 1505308058 and 17055 在index 1中，會將2個變數(investmentsLimit, investmentsDeadlineTimeStamp)做合併來最佳化storage的存放 index 2 - string11234567index = 2console.log(web3.eth.getStorageAt(contractAddress, index))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result: 0x0000000000000000000000000000000074657374310000000000000000000000ASCII: test1 index 3 - string21234567index = 3console.log(web3.eth.getStorageAt(contractAddress, index))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result:0x7465737431323336000000000000000000000000000000000000000000000000ASCII: test1236 index 4 - string31234567index = 4console.log(web3.eth.getStorageAt(contractAddress, index))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result:0x6c65747320737472696e6720736f6d657468696e67000000000000000000002aASCII: lets string something * (42) 在result最後有 2a(dec42)為 string儲存的長度可參閱solidity官方文件描述變數在storage中呈現的格式：https://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage index 5 — uints112345index = 5console.log(web3.eth.getStorageAt(contractAddress, index))result:0x0000000000000000000000000000000000000000000000000000000000000000PROBLEM!!!! 若遇到 mapping struct宣告的變數，無法直接透過一般的index來取得struct內所儲存的值，必須得曉得對應value中的 key值，否則是不可能取得的。 1234/* 要取回在 uints1 struct所儲存在addresss1的值 :88// uints1[address1] = 88; address1 = 0xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6 1234567891011index = &apos;0000000000000000000000000000000000000000000000000000000000000005&apos;// convert address1 to the 256 bytes...key = &apos;00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6&apos;let newKey = web3.sha3(key + index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;)console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;DEC: &apos; + web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000000058DEC: 88 index6 - structs1123456789index = &quot;0000000000000000000000000000000000000000000000000000000000000006&quot;key = &quot;00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6&quot;let newKey = web3.sha3(key + index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;)console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963654272616e64000000000000000000000000000000000000000016ASCII: deviceBrand 若要讀取下一個struct的值，只需要將newKey的值+1即可取到。 12345678910111213141516function increaseHexByOne(hex) &#123; let x = new BigNumber(hex) let sum = x.add(1) let result = &apos;0x&apos; + sum.toString(16) return result&#125;index = &quot;0000000000000000000000000000000000000000000000000000000000000006&quot;key = &quot;00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6&quot;let newKey = increaseHexByOne( web3.sha3(key + index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;))console.log(web3.eth.getStorageAt(contractAddress,newKey))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963655965617200000000000000000000000000000000000000000014ASCII: deviceYear 若還需要第三個之後的值，繼續將newKey遞增，就能夠取到。 index 7 - uintarray12345index = &quot;7&quot;console.log(web3.eth.getStorageAt(contractAddress, index))result: 0x0000000000000000000000000000000000000000000000000000000000000002 以上的result表示 array目前有2個值 (8000, 9000) 123456789101112131415161718index = &quot;0000000000000000000000000000000000000000000000000000000000000007&quot;let newKey = web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;)console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;DEC: &apos; + web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000001f40DEC: 8000---newKey = increaseHexByOne(web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;))console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;DEC: &apos; + web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000002328DEC: 9000 index 8 - deviceDataArray1234567891011121314151617181920index = &quot;0000000000000000000000000000000000000000000000000000000000000008&quot;let newKey = web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;)console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;ASCII: &apos; + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963654272616e64000000000000000000000000000000000000000016ASCII: deviceBrand---index = &quot;0000000000000000000000000000000000000000000000000000000000000008&quot;let newKey = increaseHexByOne(web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;))console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;ASCII: &apos; +web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963655965617200000000000000000000000000000000000000000014ASCII: deviceYear 繼續增加index的值(+1), result: 12345678index = &quot;0000000000000000000000000000000000000000000000000000000000000008&quot;let newKey = increaseHexByTwo(web3.sha3(index, &#123;&quot;encoding&quot;:&quot;hex&quot;&#125;))console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log(&apos;ASCII: &apos; +web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x776561724c6576656c0000000000000000000000000000000000000000000012ASCII: wearLevel 若加3之後，result會顯示第二組(dev2) 存進array的值 1234result:0x6465766963654272616e64320000000000000000000000000000000000000018ASCII: deviceBrand2 ReferenceHow to read Ethereum contract storage - Darius https://medium.com/aigang-network/how-to-read-ethereum-contract-storage-44252c8af925","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/tags/Solidity/"},{"name":"Smart Contract","slug":"Smart-Contract","permalink":"http://a10000005588.github.io/tags/Smart-Contract/"}]},{"title":"2019年的想法與規劃","slug":"2019年的想法與規劃","date":"2019-02-05T13:24:10.000Z","updated":"2020-01-01T13:14:35.237Z","comments":true,"path":"2019/02/05/2019年的想法與規劃/","link":"","permalink":"http://a10000005588.github.io/2019/02/05/2019年的想法與規劃/","excerpt":"剛好在農曆新年第一天，為自己的Blog換的新的Skin，同時也想勉勵自己重拾寫部落格的手感。","text":"剛好在農曆新年第一天，為自己的Blog換的新的Skin，同時也想勉勵自己重拾寫部落格的手感。 由於自己想往區塊鏈或是雲端後端工程師發展，所以在2019年希望自己能夠再次複習網路以及作業系統等知識， 以上，希望2019年能夠順利完成論文，且能夠找到一份好工作，並且持續精進自己的技術。","categories":[{"name":"Life","slug":"Life","permalink":"http://a10000005588.github.io/categories/Life/"}],"tags":[]},{"title":"Go筆記:Interface","slug":"go-interface","date":"2018-07-05T15:51:38.000Z","updated":"2019-02-05T13:07:44.483Z","comments":true,"path":"2018/07/05/go-interface/","link":"","permalink":"http://a10000005588.github.io/2018/07/05/go-interface/","excerpt":"Go Interface：程式碼的規範介面用生活化的例子來舉例： Water-pipeline就像是個interface 你就只能灌液體進去，不能塞非液體的東西到 water-pipeline","text":"Go Interface：程式碼的規範介面用生活化的例子來舉例： Water-pipeline就像是個interface 你就只能灌液體進去，不能塞非液體的東西到 water-pipeline再用火車鐵軌為例：Railroads 是train 的 interfaces 不管train上面載的什麼物體，看是passengers 還是cargos 但train的寬度 (width of the train) 都必須要符合鐵軌寬度。 \b故 railroads 的 interfaces會有以下的組成要素： 123type RailRoadWidthChecker interface &#123; CheckRailsWidth() int&#125; RailRoadWidthChecker 規範了 train必須要實作檢查火車自身的width，確保train的width是剛好符合 railroad 的寬度 123type RailRoad struct &#123; Width int&#125; // 只有宣告為type RailRoad才能呼叫 IsCorrectSizeTrain1234567891011121314151617func (railroad *RailRoad) IsCorrectSizeTrain (trainInstance RailRoadWidthChecker) bool &#123; return trainInstance.CheckRailsWidth() == railroad.Width&#125;``` || 疑問：為何不是在input中type為Train ???|| Answer: 因為由struct type為 Train實作了 struct type: RailRoadWidthCheck的CheckRailWidth()的方法IsCorrectSizeTrain 會接受了一個有實作 interface instance的火車，並且回傳該火車寬度是否與鐵軌相同```gotype Train struct &#123; TrainWidth int&#125;// 宣告為Train的struct instance 實作 checkRailsWidth()函式 並回傳 int型態func (p Train) CheckRailsWidth() int &#123; Return p.TrainWidth&#125; 接下來用 兩台train 一個有符合railroad寬度 一個則沒符合寬度 來作為範例 123456789101112func main() &#123; railroad := RailRoad&#123;Width: 10&#125; passengerTrain := Train &#123; TrainWidth: 10 &#125; cargoTrain := Train &#123; TrainWidth: 15 &#125; // interface要求type為Train必須要實作 CheckRailsWidth\b canPassengerTrainPass := railroad.IsCorrectSizeTrain(passengerTrain) canCargoTrainPass := railroad.IsCorrectSizeTrain(cargoTrain) fmt.Printf(“Can passengerTrain pass? :%t \\n”, canPassengerTrainPass) fmt.Printf(“Can cargoTrain pass? :%t \\n”, canCargoTrainPass)&#125; 輸出：12Can passengerTrain pass? :trueCan cargoTrain pass? :false","categories":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/tags/Golang/"}]},{"title":"Connect to the Rospen Network","slug":"rospen","date":"2018-05-13T08:22:06.000Z","updated":"2019-02-05T13:07:25.975Z","comments":true,"path":"2018/05/13/rospen/","link":"","permalink":"http://a10000005588.github.io/2018/05/13/rospen/","excerpt":"Enviroment: MacOS Assume reader has basic understanding of geth and ethereum.","text":"Enviroment: MacOS Assume reader has basic understanding of geth and ethereum. Create a Ethereum WalletWe can via myetherwallet to create a wallet.https://www.myetherwallet.com/#generate-wallet Record your privakey, pubkey:12private key: a406da76baa7c741ad28bfe87cef2133950d6bb6bcaaf0b1742d93c3bea56babpublic key: 0x2C58e0338435FE91FD2209105EcADebE8aaFCebB Because we are going to connect the testnet Rospen, we should do some stuff… Get a ether from faucet: For simplicity, we just ask someone to send some ether on testnet to us. Please attach your account address to get some ether. https://l.facebook.com/l.php?u=http%3A%2F%2Ffaucet.ropsten.be%3A3001%2F&amp;h=ATPjPzMFxxXmP_Egwq9V35ye_LjGOM4A_vzMkbQOdLCN8FYVRgfurVVTwrcuUzqNCMUiXF2C8sUqt241q8nmTJO6hCnY7WhpkV6iUVWxsIqjlALAeEVFv_kH5Q Check Tx from Rospen networkhttps://ropsten.etherscan.io/address/0x6508a973F080A9042a29d13925d9DB006f8c2989 In serch bar, enter your account address to see whether if the ether is sending to your account or not. Start to build a node and synchronize the Rospen network. Notice that your geth version should be the latest so that you can sucessfully sync the network. Current version : Version: 1.8.7-stable Before sync the node , Put your keystore file in the testnet document.When you download your keystore file.For example, the filename will be:UTC--2018-05-13T04-05-37.569Z--2c58e0338435fe91fd2209105ecadebe8aafcebbCopy this file into your testnet key store:/User/Library/Ethereum/testnet/keystore Sync to the Rospen networkhttps://github.com/ethereum/ropsten 1geth --unlock &lt;account&gt; --testnet --syncmode &quot;full&quot; &quot;enode://20c9ad97c081d63397d7b685a412227a40e23c8bdc6688c6f37e97cfbc22d2b4d1db1510d8f61e6a8866ad7f0e17c02b14182d37ea7c3c8b9c2683aeb6b733a1@52.169.14.227:30303,enode://6ce05930c72abc632c58e2e4324f7c7ea478cec0ed4fa2528982cf34483094e9cbc9216e7aa349691242576d552a2a56aaeae426c5303ded677ce455ba1acd9d@13.84.180.240:30303&quot; Threre are some flags: –unlock : use password to unlock the account. –testnet: connect to the rospen network. –syncmode “full”: in order to get our balances, we should synchronize whole blocks. 1geth --testnet --fast --bootnodes &quot;enode://20c9ad97c081d63397d7b685a412227a40e23c8bdc6688c6f37e97cfbc22d2b4d1db1510d8f61e6a8866ad7f0e17c02b14182d37ea7c3c8b9c2683aeb6b733a1@52.169.14.227:30303,enode://6ce05930c72abc632c58e2e4324f7c7ea478cec0ed4fa2528982cf34483094e9cbc9216e7aa349691242576d552a2a56aaeae426c5303ded677ce455ba1acd9d@13.84.180.240:30303&quot; If we already sync the entire network, we can just use--fast --bootnodes to connect testnet… Attach your gethOn MacOS (for testnet): geth attach ipc:/Users/&lt;username&gt;/Library/Ethereum/testnet/geth.ipc Then, in the console do eth.syncing you will see those stuff: 12345678&gt; eth.syncing&#123; currentBlock: 542220, highestBlock: 3224277, knownStates: 0, pulledStates: 0, startingBlock: 31397&#125; That means you are sucessfully connecting the testnet.After finish syncing process, you can see there is some ether in your accounts Problem for connecting the ropsten networkhttps://stackoverflow.com/questions/49195614/connection-failed-to-ethereum-ropsten-testnet-network Deploy to rospen network toturial:https://michalzalecki.com/deploying-smart-contracts-with-truffle/","categories":[{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/categories/Ethereum/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://a10000005588.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"}]},{"title":"Go筆記:Defer, Panic, Recover","slug":"go-defer","date":"2018-05-13T08:20:55.000Z","updated":"2019-03-22T16:09:50.959Z","comments":true,"path":"2018/05/13/go-defer/","link":"","permalink":"http://a10000005588.github.io/2018/05/13/go-defer/","excerpt":"Defer, Paic, Recover 是Golang 用來做錯誤處理的常用函式","text":"Defer, Paic, Recover 是Golang 用來做錯誤處理的常用函式 Golang- Panic, Defer, Recover介紹Panic用來發出錯誤訊息，並中斷以下執行流程 Defer可將某訊息或某執行方法推延後至程式結束，在執行。 Recover只能在Defer中使用，用來接收panic傳入的參數，並做打印或其他執行。 範例用以下例子來看 Panic、Recover與Defer的用法： 1234567891011121314151617181920212223242526272829303132package mainimport \"fmt\"func main() &#123; f() fmt.Println(\"Returned normally from f.\")&#125;func f() &#123;// 被推延至結束才執行，並且recover() 會接受panic所傳遞的參數 defer func() &#123; if r := recover(); r != nil &#123; fmt.Println(\"Recovered in f\", r) &#125; &#125;() fmt.Println(\"Calling g.\") g(0) fmt.Println(\"Returned normally from g.\")&#125;func g(i int) &#123; if i &gt; 3 &#123; fmt.Println(\"Panicking!\") panic(fmt.Sprintf(\"%v\", i)) &#125; // 將 印出“Defer in g\"這段訊息 延後印出，直到panic觸發或是程式結束才會被印出來 // 先被defer的會最晚被印出來，為Last in first out ! defer fmt.Println(\"Defer in g\", i) fmt.Println(\"Printing in g\", i) g(i + 1)&#125; 123456789101112Calling g.Printing in g 0Printing in g 1Printing in g 2Printing in g 3Panicking!Defer in g 3Defer in g 2Defer in g 1Defer in g 0Recovered in f 4Returned normally from f. 補充通常 defer 也會被用在 要關閉一個DB的instance 例如以下以mongoDB為例： 12345678910111213141516171819202122232425func someFunction() &#123; var err error mongo, err := getMongoSession() // 回傳一個mongo的instance mongo.SetSocketTimeout(1 * time.Hour) //session.SetSocketTimeout(1 * time.Hour) if err != nil &#123; errors := common.Error&#123; ErrorType: 1, ErrorDescription: err.Error(), &#125; logger.Console().Panic(errors) logger.File().Error(err) &#125; // 將關閉mongo的動作推延至 該function執行玩return後執行 defer mongo.Close() collection := mongo.DB(dbName).C(collectionName.BsBlocks) result := []blockStrcut.BlockWithOnlyTxHashesIntNum&#123;&#125; err = collection.Find(conditions).All(&amp;result) return result, err&#125; 參考The Go Blog：Defer, Panic, and Recoverhttps://blog.golang.org/defer-panic-and-recover","categories":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/tags/Golang/"}]},{"title":"Go筆記:Features","slug":"go-features","date":"2018-05-13T08:19:10.000Z","updated":"2019-02-11T02:31:34.788Z","comments":true,"path":"2018/05/13/go-features/","link":"","permalink":"http://a10000005588.github.io/2018/05/13/go-features/","excerpt":"The benefit of Golang is as follows:","text":"The benefit of Golang is as follows: 1. Quick compile time than the C , C++ Golang provides lightning-quick compiler by using a smart compiler and simplified dependency resolution algorithm. When build the golang program, the compiler only looks at the libraries that you directly include. (C,C++,JAVA. those programming language will traverse entire dependency chain…) 2. Concurrencygo-routineGolang can create go-routine, which is like thread but use far less memory and require less code to use. Golang can create many go-routine on a single thread. 12345func log(msg string)&#123; ... some logging code here&#125;// Elsewhere in our code after we've discovered an error.go log(\"something dire happened\") channelchannel are data structure that let you send typed messages between goroutines with sychronization built in. Channel can also avoid the share memory problem in concurrency modification problem. Warning: channel isn’t provide data access protection. 3. Go type system.Golang provides flexible hierachy-free type free system that enables code reuse with minimal refactoring overhead. In tradictional OOD, like JAVA, need to implenment all the method declared in interface.1234interface User &#123; public void login(); public void logout();&#125; But in golang type system, you only implement the method you would use.123type Reader interface &#123; Read(p []byte) (n int, err error)&#125; 4. Memory managementGolang has modern garbage collector that does hard work for you.","categories":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/tags/Golang/"}]},{"title":"ERC Token介紹：ERC20 & ERC721","slug":"erctoken","date":"2018-03-25T11:54:59.000Z","updated":"2019-02-05T13:08:23.012Z","comments":true,"path":"2018/03/25/erctoken/","link":"","permalink":"http://a10000005588.github.io/2018/03/25/erctoken/","excerpt":"ERC Token 介紹即利用當今火紅的以太坊上的智能合約，實作出代幣功能。可擁有與虛擬貨幣作為價值傳遞功能。","text":"ERC Token 介紹即利用當今火紅的以太坊上的智能合約，實作出代幣功能。可擁有與虛擬貨幣作為價值傳遞功能。 好處 不用自己架設公有鏈，就可以擁有自己發行的代幣 以既定匯率，可以直接與以太幣進行交換。 為何需要ERC標準合約？由於代幣是建立在以太坊上的智能合約，故其代幣也只是存在智能合約上的某筆紀錄。故透過一些狀態改變和轉移，故ERC合約可以明確定義某個以太坊地址上的某個代幣餘額，並可以對其進行操作，而操作的規範就定義在ERC上。 故一個代幣要擁有合理的發行機制，就得符合現在所擁有的ERC20以及ERC721之類的標準。 ERC代幣有自己的錢包嗎？？由於是透過以太坊智能合約控制的，故只要透過以太坊錢包(地址)就可以了。 ERC20 介紹記載ERC20規則 官方文件https://theethereum.wiki/w/index.php/ERC20_Token_Standard ERC20 Token Standard Interface12345678910interface ERC20 &#123; function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); | function allowance(address tokenOwner, address spender) public constant returns (uint remaining); | function transfer(address to, uint tokens) public returns (bool success); | function approve(address spender, uint tokens) public returns (bool success); | function transferFrom(address from, address to, uint tokens) public returns (bool success); | event Transfer(address indexed from, address indexed to, uint tokens); | event Approval(address indexed tokenOwner, address indexed spender, uint tokens); &#125; 以上的Interface定義了六個Function，有Input及Output格式。以及兩個Event，僅有Input。 其中Function為可以操縱智能合約狀態的動作，會需要消耗Gas，而可以看到有些Function後面有 constant關鍵字，表示僅做唯獨，不會更改到智能合約上的State，主要是回傳的State資訊，不會消耗到Gas。 而Event為紀錄重大事件的發生，例如在鏈上進行Token的轉移。 設定ERC Token資訊123string public constant name = \"Token Name\"; string public constant symbol = \"TKN\"; uint8 public constant decimals = 18; // 18 is the most common number of decimal places ERC20 需要設定此 Token 的三個資訊: name、symbol、decimals name 是 Token 的名字。 symbol 則是此 Token 會使用的代稱，像是 Binance Token 的 symbol 就是 BNB，而此 symbol 也會出現在 Etherscan上面 decimals 是用來設定此 Token 最小會有幾個位數，通常會設定成 18，意即最多到達小數點後 18 位數，這樣的設定跟 Ether 本身的設定也是一樣的(1 ether: 10 ^ 18 wei)。 補充說明：在 Solidity 中並沒有浮點數的存在，所有的運算都是整數，因此平常我們所說的 1 Ether，事實上在 Solidity 程式中是以wei的單位(1 ether = 10¹⁸)來撰寫。 ERC20 詳述12345678910111213141516171819202122232425262728293031323334353637383940414243contract TokenContractFragment &#123; // Balances for each account mapping(address =&gt; uint256) balances; // Owner of account approves the transfer of an amount to another account mapping(address =&gt; mapping (address =&gt; uint256)) allowed; // Get the token balance for account \\`tokenOwner\\` function balanceOf(address tokenOwner) public constant returns (uint balance) &#123; return balances\\[tokenOwner\\]; &#125; // Transfer the balance from owner's account to another account function transfer(address to, uint tokens) public returns (bool success) &#123; balances\\[msg.sender\\] = balances\\[msg.sender\\].sub(tokens); balances\\[to\\] = balances\\[to\\].add(tokens); Transfer(msg.sender, to, tokens); return true; &#125; // Send \\`tokens\\` amount of tokens from address \\`from\\` to address \\`to\\` // The transferFrom method is used for a withdraw workflow, allowing contracts to send // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge // fees in sub-currencies; the command should fail unless the _from account has // deliberately authorized the sender of the message via some mechanism; we propose // these standardized APIs for approval: function transferFrom(address from, address to, uint tokens) public returns (bool success) &#123; balances\\[from\\] = balances\\[from\\].sub(tokens); allowed\\[from\\]\\[msg.sender\\] = allowed\\[from\\]\\[msg.sender\\].sub(tokens); balances\\[to\\] = balances\\[to\\].add(tokens); Transfer(from, to, tokens); return true; &#125; // Allow \\`spender\\` to withdraw from your account, multiple times, up to the \\`tokens\\` amount. // If this function is called again it overwrites the current allowance with _value. function approve(address spender, uint tokens) public returns (bool success) &#123; allowed\\[msg.sender\\]\\[spender\\] = tokens; Approval(msg.sender, spender, tokens); return true; &#125;&#125; 使用例子Token Balance我們假設這個智能合約目前有兩個地址擁有該Tokenbalances[‘0x123456’] = 100balances[‘0x654321’] = 200 則 Function balanceOf 則會回傳以下資訊:tokenContract.balanceOf(‘0x123456’) will return 100tokenContract.balanceOf(‘0x654321’) will return 200 Transfer Token Balance如果 0x123456想要轉移 10 tokens 給 0x654321，則呼叫tokenContract.transfer(‘0x654321’, 10) 將得到下列結果balances[‘0x123456’] = 90balances[‘0x654321’] = 210 Approve And TransferFrom Token Balance如果 0x123456 允許 0x654321 擁有轉移 30 tokens 的權利，則呼叫tokenContract.approve(‘0x654321’, 30) 將得到下列結果tokenContract.allowed[‘0x123456’][‘0x654321’] = 30 如果此時’0x654321’ 想要轉移 ‘0x123456’ 的 20 tokens 給自己，則呼叫‘tokenContract.transferFrom(‘0x123456’, ‘0x654321’, 20) 將得到下列結果tokenContract.balances[‘0x123456’] = 70tokenContract.balances[‘0x654321’] = 230tokenContract.allowed[‘0x123456’][‘0x654321’] = 10 ERC721 介紹ERC-721 是用来定義 Non-fungible token (不可替代的代幣)。每個代幣是唯一的(unique)，具不可分割性，不像ERC20 每個token都相同。 具體應用: 以太貓(cryptokitties)每個以太貓，都是一個ERC721代幣。 1234567891011interface ERC721 &#123; function supportsInterface(bytes4 _interfaceID) external pure returns (bool); function ownerOf(uint256 \\_deedId) external view returns (address \\_owner); function countOfDeeds() external view returns (uint256 _count); function countOfDeedsByOwner(address \\_owner) external view returns (uint256 \\_count); function deedOfOwnerByIndex(address \\_owner, uint256 \\_index) external view returns (uint256 _deedId); event Transfer(address indexed from, address indexed to, uint256 indexed deedId); event Approval(address indexed owner, address indexed approved, uint256 indexed deedId); function approve(address \\_to, uint256 \\_deedId) external payable; function takeOwnership(uint256 _deedId) external payable;&#125; 參考資料 ERC20 Token Standardhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard 请问以太坊里的ERC-721和ERC-20是什么？http://www.blockchainbrother.com/question/510 What has ERC-721 better than ERC-20?https://medium.com/@PatrickGohBS/ethereum-erc-721-vs-erc-20-4bff8c147fdf","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"}]},{"title":"Go筆記:Array,Slice,Map","slug":"go-array-slice-map","date":"2018-03-18T12:41:51.000Z","updated":"2019-02-05T13:07:55.590Z","comments":true,"path":"2018/03/18/go-array-slice-map/","link":"","permalink":"http://a10000005588.github.io/2018/03/18/go-array-slice-map/","excerpt":"Golang -Array,Slice,Maparray用法","text":"Golang -Array,Slice,Maparray用法 宣告12var arr [5]intfmt.Println(\"array arr:\", a) 或是用 make1arr := make([]int64,5) 動態分配陣列1234arr=make([][]int64,10) //外層有10格for i:=0;i&lt;10;i++&#123; arr[i]=make([]int64,i) //動態分裡面&#125; 遍歷array1234567for i := 0; i &lt;len(a); i++ &#123; fmt.Println(\"arr[\", i, \"] =\", a[i])&#125;// 用range, 第一個值 key為索引，value為索引的值for key, value := range arr &#123; fmt.Println(\"arr[\", i, \"] =\", value)&#125; slice用法透過array創造12var myArray [10]int = [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;var mySlice []int = myArray[:5] 或是利用 make12345// make([]T, length, capacity)// 創建長度為5，容量為10的切片slice1 := make([]int, 5, 10)// 創建長度為5，並初始化該切片slice2 := []int&#123;1, 2, 3, 4, 5&#125; 註： make的capacity若沒有設置會預設跟length一樣，為slice最大長度之上限。 切片長度可透過append來增加1234// 在slice2 增加6slice2 = append(slice2, 6)fmt.Println(\"slice:\", slice2)// slice: 1 2 3 4 5 6 Array 和 Slice差異 array slice 1.長度宣告後不可以變動 1.長度可以透過append()或slice[:]做變動 2.slice為array的指標，若更動slice，也會更動到原本array的內容 如何避免Slice更動到原本Array?Method1 - make and Copy先開一個新的空間，用make開好，用copy拷貝過去123arr:=[]int&#123;1,2,3,4&#125;newSlice := make([]int, len(arr))copy(newSlice, arr) Method2 - Append12arr:=[]int&#123;1,2,3,4&#125;newSlice = append([]int64(nil), arr[1:3]...) //一定要「…」 Map用法建立一個 map 兩種方式: 123m := make(map[string]int)// m[\"age\"] = 16m := map[string]int&#123;&#125; 回傳值, 和 map 是否存在如果是不存在的 key , value = 0 , ok = false1value , ok := m[\"age\"] 利用 range 取得 map 中所有的 key 和 value, 並列印123for key, value := range m &#123; fmt.Println(\"Key:\", key, \"Value:\", value)&#125; 一次宣告多值12345person := map[string]int&#123; \"age\" : 16, \"height\" : 180, \"weight\" : 6,&#125; ReferenceGolang 兩三事http://daniel0076.logdown.com/posts/280719-golang-slice-notesGolang slice trickhttps://github.com/golang/go/wiki/SliceTricks","categories":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://a10000005588.github.io/tags/Golang/"}]},{"title":"分散式系統共識算法筆記：Paxos和Raft","slug":"consensusAlgo","date":"2018-03-10T16:00:00.000Z","updated":"2019-02-05T13:06:27.330Z","comments":true,"path":"2018/03/11/consensusAlgo/","link":"","permalink":"http://a10000005588.github.io/2018/03/11/consensusAlgo/","excerpt":"Paxos介紹分布式系統中，只有出現故障節點(fault node),但不存在惡意節點(corrupt node)下達成共識的問題。","text":"Paxos介紹分布式系統中，只有出現故障節點(fault node),但不存在惡意節點(corrupt node)下達成共識的問題。 問題起源故事背景為古希臘的Paxon島上有諸位法官要對某一件法案進行裁決並如何達成共識的結果。 過程中法官會透過傳訊關傳遞訊息，但法官可能中途離席，而服務員可能偷懶睡覺。 故Paxos算法基於“兩階段提交”來確保法官們可以得到共識結果的一致性。 Paxos特性Paxos將參與節點中分為三類： Proposer(客戶端): 提出一個案子，等待大家批准並得到答案。 Acceptor(服務端): 接受提案，並進行投票。 Learner(客戶端or服務端): 被告知提案結果，並將自己的狀態與結果更新。 過程中必須滿足分散式系統共識所必須的兩特性： Safty：保證決議結果是對的，無異議，並不會出現錯誤情況。 Liveness：保證在”有限”時間內完成共識結果。 Paxos過程 由Proposer提出提案，爭取Acceptors的支持。 超過一半的Acceptors支持，則發送該提案結果給所有人進行確認。 兩階段提繳Step 1: Prepare階段 Proposer發送自己的計畫給多個Acceptors. Acceptor根據該計畫的編號，若是最新的編號則保留，反之則退回。 Step 2: Commit階段 Proposer收到Accpetor的確認回覆。若收到的回覆中不帶有新的提案請求，表示鎖定成功。 若沒有收到超過1/2個Accpetor的回覆。 特殊情況 若Proposer在提案過程中發生故障，可以透過超時機制票選下一位Proposer。 Paxos算法保證在正常節點有 1/2個以上時，可滿足共識的Safety和Liveness. Raft介紹為Paxos的簡化版本。 參與者包括三種角色： 1.Leader 2.Candidate 3.Follower 共識流程 Leader選舉：每個Candidate在一定時間內會提出選舉方案，而選舉結果的那位成為Leader. 同步每個Replication的Log: Leader會找到系統中的Log檔案上最新的紀錄，並要求所有Follower根據該最新紀錄同步到他們自己的Log檔案上。 log檔可能為系統上發生的動作紀錄。 小結Paxos和Raft為目前分散式系統的帶來不錯的共識結果，其他共識演算法像是PBFT (practical byzantine fault tolerant protocal)以及目前由Amis團隊所於etherum上所實現的BFT算法- Istanbul BFT，都算是本次筆記提到的再進階的共識算法，有興趣的讀者可以在到以下連結去深入瞭解。 Istanbul BFT - AMIS PBFT Introduction","categories":[{"name":"Consensus","slug":"Consensus","permalink":"http://a10000005588.github.io/categories/Consensus/"}],"tags":[{"name":"Consensus","slug":"Consensus","permalink":"http://a10000005588.github.io/tags/Consensus/"},{"name":"Blockchain","slug":"Blockchain","permalink":"http://a10000005588.github.io/tags/Blockchain/"}]},{"title":"Javascript筆記:Closure(閉包)概念","slug":"javascript-closure","date":"2017-09-13T04:43:04.000Z","updated":"2019-02-05T14:25:21.655Z","comments":true,"path":"2017/09/13/javascript-closure/","link":"","permalink":"http://a10000005588.github.io/2017/09/13/javascript-closure/","excerpt":"閉包（closure): 為一個function包在某一個函式內，用return來取得內部function的回傳值 Closure are commonly used to give objects data privacy.","text":"閉包（closure): 為一個function包在某一個函式內，用return來取得內部function的回傳值 Closure are commonly used to give objects data privacy. 為什麼要有閉包？？因為有以下問題ㄧ、Counter dilemma123456789101112var counter = 0;function add() &#123; counter += 1;&#125;add();add();add();// the counter is now equal to 3 counter被改變成3、不過也可以不用透過add()直接更改counter的值。那這樣會造成變數污染衝突。 12345678function add() &#123; var counter = 0; counter += 1;&#125;add();add();add(); counter被宣告在add()內，為local variable，不會被其他function或global改寫。但會有重複呼叫add()後無法使counter值做累加的動作。(因為var counter使變數重複被定義)。 二、解決方法 1234567function add() &#123; var counter = 0; function plus() &#123;counter += 1;&#125; plus(); return counter; &#125; 透過內部plus函式才能更改counter值、解決counter dilemma問題，不過還會遇到var counter重複宣告的問題，這時候就得用閉包的技巧！如下： 1234567891011var add = (function () &#123; var counter = 0; return function () &#123;return counter += 1;&#125;&#125;)();add();add();add();// the counter is now 3 將add變數宣告成 self-invoking function(僅執行內部一次 var counter不會在add()第二次被呼叫時再次被宣告)，然後回傳function expression，如此一來add變數就變成 add() function了！ 12var counter = 0;return function () ***&#123;return counter += 1;***&#125; 就被包在add()函式內，直接呼叫add() 就只會跑上面*的部分。 以上做法即為closure閉包，使得變數不會被污染和衝突。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://a10000005588.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://a10000005588.github.io/tags/Javascript/"}]},{"title":"Javascript筆記:使用prototype chain(原型鍊)來達成繼承效果","slug":"javascript-prototypechain","date":"2017-09-13T04:39:37.000Z","updated":"2019-02-05T13:09:00.439Z","comments":true,"path":"2017/09/13/javascript-prototypechain/","link":"","permalink":"http://a10000005588.github.io/2017/09/13/javascript-prototypechain/","excerpt":"先知道個keyword： __proto__： javascript自己定義的變數，用來實現inheritance效果，有點類似像link list node的概念，連結其他的 prototype","text":"先知道個keyword： __proto__： javascript自己定義的變數，用來實現inheritance效果，有點類似像link list node的概念，連結其他的 prototype javascript記憶體管理的配置： class儲存在 global底下 class的prototype放置在heap （即class底下的各種variable和function) instance（ex var b = new B()) 的b儲存在 callstack(記憶體RAM裡面) slogan:在自己的scope裡面找不到要的函式或變數就跟自己的__proto__要！ 繼承範例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var Car = function()&#123; //constructor this.brand = \"default\"; var _wheels // private method var initialWheels = function () &#123; _wheels = 4 &#125; this.getNumberofWheel = function()&#123; return this.brand; &#125;&#125;var Benz = function(brandName) &#123; //constructor Car.apply(this, argument) //等於呼叫 super(args); //argument為 var Benz = function(args...); 的 args們 = [brandName, wheel] // 這一行就是把 Benz.prototype.__proto__ = Car.prototype接起來; // 即Benz class inheritance Car // 疑問：上面敘述需和Ben確認一下 那這樣為什麼下面又得自己做Benz.prototype = Object.create(Car.prototype) ?? // 解答：若沒有做Car.apply (即super()) 動作，這樣子類別會無法將接受的arguments傳遞給從parent複製過來的函式 this.brand = brandName; //初始化車品牌的名稱 &#125;// javascript ES5得自己綁定繼承關係，用__proto__這個keyword// 建立父類別實體 設定繼承關係:Benz.prototype = Object.create(Car.prototype) //上面即是做了Benz.prototype.__proto__ = Car.prototype//使Benz class繼承Car class(Benz extends Car)Benz.prototype.constructor = Benz//Benz的constructor指向Benz class//將Benz的constructor綁定到自己身上，//才能在Benz new出一個物件時作初始化動作（即呼叫Benz =function函式&#123;&#125;) //var benz = new Benz(\"Benz\") 初始化該車子名稱：\"Benz\"; var benz = new Benz() // benz.__proto__ = Benz.prototype// 宣告一個物件叫 benzconsole.log(benz.numberOfWheels()) // 會先搜尋benz.prototype有沒有numberOfWheels()方法// 沒有==&gt;那就找benz.__proto__ = Benz.prototype;// Benz.prototype就會找到 numberOfWheels()的方法！ benz.numberOfWheels() 有此方法 每次呼叫Car.apply(this, arguments)時”複製”到子類別的物件上初始化物件時較慢，在run time想要動態改變numberOfWheels()的實作時 無法影響已經創建的子類別或父類別instances. 以下為初始化較有效率的寫法：1234567891011121314151617181920212223242526var Car = function () &#123; // constructor // public property this.wheels = 4 // pulic property this.brand = 'default'&#125;// 這種寫法不支援存取private property// 因為每個物件都可以直接存取掛在parent.prototype上的property// 但可以在run time修改此Car.prototype.numberOfWheels()的實作// 就可以透過prototype chain更改所有相關的instance功能 因為instance共用prototype chain上的方法Car.prototype.numberOfWheels = function () &#123; return this.wheels&#125;var Benz = function (brandName) &#123; Car.apply(this, arguments) // 複製繼承父類別public property this.brand = 'brandName'; this.getBrand = function () &#123; return this.brand &#125;&#125;... numberOfWheels該方法已經被掛在 Car.prototype上，所以並不像Car.apply上直接複製一份給子class們，而是子class去共用Car.prototype.numberOfWheels 這個方法。 優點：節省初始化的時間和提升效率 缺點：這種寫法不支援存取private property javascript 類別、prototype以及reference中的proto所指向的關係示意圖：圖片作者： Ben大大 假設 B class extend A;let b = new B(); // b.__proto__ = B.prototypelet a = new A(); // a.__proto__ = A.prototypelet o = new Object(); o.__proto__ = Object.prototype//對應到圖片左邊的b、a、o. (先從圖片最左上角開始看那 var b = new B();b想要使用繼承A的 getValue() 函式，那麼就得先找自己的 b.prototype 沒有的話 找 b.__proto__ = B.prototype 若b.__proto__也沒有的話(即B.prototype)也沒有，那麼找 B.prototype.__proto__ == A.prototype在A.prototype就會找到getValue()的函式！ 如果又沒找到，那就最後找A.prototype.__proto__ == Object.prototype若沒有那就找 Object.prototype.__proto__ == null 即找無該函式，compile告知發生錯誤); Prototype inheritance 的好處 Suitable in loosely typed environments, no need to define explicit types. Makes it incredibly easy to implement singleton pattern (compare JavaScript and Java in this regard, and you’ll know what I am talking about). (why? 因為prototype inheritance提供???? 請看補充二） Provides ways of applying a method of an object in the context of a different object, adding and replacing methods dynamically from an object etc. (things which are not possible in a strongly typed languages). Prototype inheritance的壞處 No easy way of implementing private variables. Its possible to implement private vars using Crockford’s wizardry using closures, but its definitely not as trivial as using private variables in say Java or C#.(因為__prpto__會指向prototype的所有成員！故無法像class inheritance那樣避免繼承到有private關鍵字的變數，故得用closure手法來避免繼承到_private變數) Reference:prototype based vs. class based inheritance 補充ㄧ：Function.prototype.applyfun.apply(thisArg, [argsArray])// 將一連串參數用array包起來：[argsArray]，丟給fun函式處理 範例：1234567891011121314function theFunction(name, profession) &#123; console.log(&quot;My name is &quot; + name + &quot; and I am a &quot; + profession + &quot;.&quot;);&#125;// call functionfunction callFn(name, profession) &#123; theFunction.apply(this, [name, profession]);&#125;theFunction(&apos;小will&apos;, &apos;工程師&apos;);callFn(&apos;大Will&apos;, &apos;小廢廢&apos;);// 輸出:// My name is 小will and I am a 工程師.// My name is 大Will and I am a 小廢廢. 補充二：用Closure實作Singleton模式閉包觀念連結：==&gt; 閉包是什麼？？ 先看範例程式碼1234567891011121314151617181920var UniverseN;(function()&#123; var instance; UniverseN = function UniverseN()&#123; if(instance)&#123; return instance; &#125; instance = this; this.start_time = 0; this.bang = 'Big'; &#125;;&#125;());var uni9 = new UniverseN();var uni10 = new UniverseN();console.log(uni9 === uni10); //trueUniverseN.prototype.inEverything = true; 可以看出若利用了Prototype inheritance的特性，，將IIFE函式掛在UniverseN.prototype.IIFE上，使得之後宣告的物件不會在複製一份IIFE出來出來，讓IIFE只跑一次！這樣就可以達成一個class (UniverseN) 只能宣告一次的物件 (uni9)。 如果在宣告出 uni10，他們都還是指向同一樣的instance(uni9.__proto__ == uni10__proto__) Reference:JavaScript Design Pattern - Singleton 單體模式","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://a10000005588.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://a10000005588.github.io/tags/Javascript/"}]},{"title":"使用OpenZeppelin搭配Truffle來打造智能合約","slug":"openzepplin","date":"2017-09-13T02:43:31.000Z","updated":"2019-02-05T13:07:05.276Z","comments":true,"path":"2017/09/13/openzepplin/","link":"","permalink":"http://a10000005588.github.io/2017/09/13/openzepplin/","excerpt":"本篇是參考truffle官網所做的筆記：ROBUST SMART CONTRACTS WITH OPENZEPPELIN","text":"本篇是參考truffle官網所做的筆記：ROBUST SMART CONTRACTS WITH OPENZEPPELIN OpenZeppelin介紹可以把OpenZeppelin當成強化Solidity資訊安全的Framework，為智能合約附上Ethereum所認可的ERC-20標準，畢竟合約要處理的可是真正的錢！ ERC-20標準介紹：What is ERC-20 and What Does it Mean for Ethereum? 簡單來說ERC-20標準允許錢包、交易所和其他智能合約以一種常見的方式對接各種代幣。 使用OpenZeppelin預備知識建議先瞭解ethereum以及Smart Contract語言Solidity以及開發Smart Contract的框架 Truffle 可以參考官網或是我之前所做的筆記 Ethereum官方網站： 菜鳥William的Solidity學習紀錄 使用Truffle來練習撰寫認養寵物的智能合約 環境設定創立一個資料夾 open_z使用truffle unbox把練習專案給下載到本機上12cd open_ztruffle ubbox tutorialtoken 安裝 zeppelin-solidity 1npm install zeppelin-solidity 為tutorialtoken專案撰寫 TutorialToken合約在 /contracts 目錄底下創建 TutorialToken.sol TutorialToken.sol12345678910111213141516171819pragma solidity ^0.4.4;// 引入zepplin-solidity的StandardToken.sol 合約import 'zeppelin-solidity/contracts/token/StandardToken.sol';// 使用is 來繼承StandardToken合約contract TutorialToken is StandardToken &#123; string public name = 'TutorialToken'; // token name string public symbol = 'TT'; uint public decimals = 2; // 合約被創建時所產生的金額總數 uint public INITIAL_SUPPLY = 12000; function TutorialToken() &#123; totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; &#125;&#125; 透過以上簡短的程式碼就已經創造出符合Ethereum的 ERC-20標準的Token囉！ 編譯(Compile)以及部署(Deploy)在/migrations內，創建2_deploy_contracts.js檔案 2_deploy_contracts.js12345var TutorialToken = artifacts.require(\"./TutorialToken.sol\");module.exports = function(deployer) &#123; deployer.deploy(TutorialToken);&#125;; 在terminal，先用testrpc啟好自己的測試鍊 1testrpc then 執行12truffle comiletruffle migrate 和TutorialToken Dapp互動我們使用metamask和我們的Dapp互動 並且該專案已經內建 lite-server可運行Dapp 執行1npm run dev 看到以下畫面則表示成功運行！(別忘了要先登入metamask，以便前端能夠擷取到testrpc所開啟的錢包資訊) 以及可以看到在metamask上錢包的資訊 總結: Truffle+OpenZeppelin = A Superb Development Experience透過： Truffle：開發智能合約的框架 OpenZeppelin：可為智能合約提供ERC-20標準的工具 就可以打造出可上市的智能合約的開發環境！ 對OpenZeppelin內的合約架構有興趣的朋友可以觀看我這篇筆記： OpenZeppelin合約架構透析","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/tags/Solidity/"},{"name":"Truffle","slug":"Truffle","permalink":"http://a10000005588.github.io/tags/Truffle/"}]},{"title":"菜鳥William的Solidity學習紀錄","slug":"solidity","date":"2017-09-12T13:34:23.000Z","updated":"2019-02-05T13:07:29.142Z","comments":true,"path":"2017/09/12/solidity/","link":"","permalink":"http://a10000005588.github.io/2017/09/12/solidity/","excerpt":"這篇主要記錄著我對Solidity官網文檔的學習紀錄","text":"這篇主要記錄著我對Solidity官網文檔的學習紀錄 簡單的合約開始介紹起1234567891011121314pragma solidity ^0.4.0; // 告訴compiler要如何對待這份codecontract SimpleStorage &#123; uint storedData; // 宣告uint型態的變數 uint為 256 bits. // 以下控制stored variable. function set(uint x) &#123; storedData = x; &#125; function get() constant returns (uint) &#123; return storedData; &#125;&#125; 另外一個比較複雜的合約 123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.0;contract Coin &#123; // The keyword \"public\" makes those variables // readable from outside. address public minter; mapping (address =&gt; uint) public balances; // 可把mapping 當成是hash tables // 將address當參數 映射到balances中會得到uint型態的回傳值 // Events allow light clients to react on // changes efficiently. event Sent(address from, address to, uint amount); // 和contract同名的函式名稱即為constructor，在合約被創造出來時呼叫 function Coin() &#123; minter = msg.sender; &#125; function mint(address receiver, uint amount) &#123; if (msg.sender != minter) return; balances[receiver] += amount; &#125; function send(address receiver, uint amount) &#123; if (balances[msg.sender] &lt; amount) return; balances[msg.sender] -= amount; balances[receiver] += amount; Sent(msg.sender, receiver, amount); // msg.sender 合約的持有者 &#125;&#125; address：160-bit value that does not allow any arithmetic operations. public：使其他合約可以存取自己的scope function,variable. address public minter 可看成如下： 1function minter() returns (address) &#123; return minter; &#125; mapping (address =&gt; uint) public balances;可看成如下 123function balances(address _account) returns (uint) &#123; return balances[_account];&#125; event Sent(address from, address to, uint amount); 透過該Sent function方便追蹤錢的流出和流入地址是哪 Coin()：為建構子，合約創造出來就會呼叫且建構子會儲存： msg：儲存創造合約的人的address以及其他properties (tx,block…)，擁有直接和blockchain溝通的權利 msg.sender：呼叫合約的人，若contract A呼叫contract B，那msg.sender在contract A B都是相同的。 Ethereum Virtual MachineThe Ethereum Virtual Machine or EVM is the runtime environment for smart contracts in Ethereum. Features: OverviewThe Ethereum Virtual Machine or EVM is the runtime environment for smart contracts in Ethereum AccountsExternal accounts that are controlled by public-private key pairs (i.e. humans)Contract accounts which are controlled by the code stored together with the account.—-Every account has a persistent key-value store mapping 256-bit words to 256-bit words called storage. Transactions GasThe gas price is a value set by the creator of the transaction合約的手續費，用來執行合約的燃料，避免Contract有bug會把錢一直轉走 Storage, Memory and the Stack Storage:每個Contract都會持有自己的storage,storage為一個key-value store that maps 256-bit words to 256-bit words. Memory：of which a contract obtains a freshly cleared instance for each message call Delegatecall / Callcode and Libraries Solidity ExamplesSolidity Example 1：Voting Contract.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138pragma solidity ^0.4.11;/// @title Voting with delegation.contract Ballot &#123; // This declares a new complex type which will // be used for variables later. // It will represent a single voter. struct Voter &#123; uint weight; // weight is accumulated by delegation bool voted; // if true, that person already voted address delegate; // person delegated to uint vote; // index of the voted proposal &#125; // This is a type for a single proposal. struct Proposal &#123; bytes32 name; // short name (up to 32 bytes) uint voteCount; // number of accumulated votes &#125; address public chairperson; // This declares a state variable that // stores a `Voter` struct for each possible address. // 將每一個地址映射到對應的 Voter struct. mapping(address =&gt; Voter) public voters; // A dynamically-sized array of `Proposal` structs. Proposal[] public proposals; /// Create a new ballot to choose one of `proposalNames`. function Ballot(bytes32[] proposalNames) &#123; chairperson = msg.sender; voters[chairperson].weight = 1; // For each of the provided proposal names, // create a new proposal object and add it // to the end of the array. for (uint i = 0; i &lt; proposalNames.length; i++) &#123; // `Proposal(&#123;...&#125;)` creates a temporary // Proposal object and `proposals.push(...)` // appends it to the end of `proposals`. proposals.push(Proposal(&#123; name: proposalNames[i], voteCount: 0 &#125;)); &#125; &#125; // Give `voter` the right to vote on this ballot. // May only be called by `chairperson`. function giveRightToVote(address voter) &#123; // If the argument of `require` evaluates to `false`, // it terminates and reverts all changes to // the state and to Ether balances. It is often // a good idea to use this if functions are // called incorrectly. But watch out, this // will currently also consume all provided gas // (this is planned to change in the future). require((msg.sender == chairperson) &amp;&amp; !voters[voter].voted &amp;&amp; (voters[voter].weight == 0)); voters[voter].weight = 1; &#125; /// Delegate your vote to the voter `to`. function delegate(address to) &#123; // assigns reference Voter storage sender = voters[msg.sender]; require(!sender.voted); // Self-delegation is not allowed. require(to != msg.sender); // Forward the delegation as long as // `to` also delegated. // In general, such loops are very dangerous, // because if they run too long, they might // need more gas than is available in a block. // In this case, the delegation will not be executed, // but in other situations, such loops might // cause a contract to get \"stuck\" completely. while (voters[to].delegate != address(0)) &#123; to = voters[to].delegate; // We found a loop in the delegation, not allowed. require(to != msg.sender); &#125; // Since `sender` is a reference, this // modifies `voters[msg.sender].voted` sender.voted = true; sender.delegate = to; Voter delegate = voters[to]; if (delegate.voted) &#123; // If the delegate already voted, // directly add to the number of votes proposals[delegate.vote].voteCount += sender.weight; &#125; else &#123; // If the delegate did not vote yet, // add to her weight. delegate.weight += sender.weight; &#125; &#125; /// Give your vote (including votes delegated to you) /// to proposal `proposals[proposal].name`. function vote(uint proposal) &#123; Voter storage sender = voters[msg.sender]; require(!sender.voted); sender.voted = true; sender.vote = proposal; // If `proposal` is out of the range of the array, // this will throw automatically and revert all // changes. proposals[proposal].voteCount += sender.weight; &#125; /// @dev Computes the winning proposal taking all /// previous votes into account. function winningProposal() constant returns (uint winningProposal) &#123; uint winningVoteCount = 0; for (uint p = 0; p &lt; proposals.length; p++) &#123; if (proposals[p].voteCount &gt; winningVoteCount) &#123; winningVoteCount = proposals[p].voteCount; winningProposal = p; &#125; &#125; &#125; // Calls winningProposal() function to get the index // of the winner contained in the proposals array and then // returns the name of the winner function winnerName() constant returns (bytes32 winnerName) &#123; winnerName = proposals[winningProposal()].name; &#125;&#125; Solidity Example 2：Simple Open Auction123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119pragma solidity ^0.4.11;contract SimpleAuction &#123; // Parameters of the auction. Times are either // absolute unix timestamps (seconds since 1970-01-01) // or time periods in seconds. address public beneficiary; uint public auctionStart; uint public biddingTime; // Current state of the auction. address public highestBidder; uint public highestBid; // Allowed withdrawals of previous bids mapping(address =&gt; uint) pendingReturns; // Set to true at the end, disallows any change bool ended; // Events that will be fired on changes. event HighestBidIncreased(address bidder, uint amount); event AuctionEnded(address winner, uint amount); // The following is a so-called natspec comment, // recognizable by the three slashes. // It will be shown when the user is asked to // confirm a transaction. /// Create a simple auction with `_biddingTime` /// seconds bidding time on behalf of the /// beneficiary address `_beneficiary`. function SimpleAuction( uint _biddingTime, address _beneficiary ) &#123; beneficiary = _beneficiary; auctionStart = now; biddingTime = _biddingTime; &#125; /// Bid on the auction with the value sent /// together with this transaction. /// The value will only be refunded if the /// auction is not won. function bid() payable &#123; // No arguments are necessary, all // information is already part of // the transaction. The keyword payable // is required for the function to // be able to receive Ether. // Revert the call if the bidding // period is over. require(now &lt;= (auctionStart + biddingTime)); // If the bid is not higher, send the // money back. require(msg.value &gt; highestBid); if (highestBidder != 0) &#123; // Sending back the money by simply using // highestBidder.send(highestBid) is a security risk // because it could execute an untrusted contract. // It is always safer to let the recipients // withdraw their money themselves. pendingReturns[highestBidder] += highestBid; &#125; highestBidder = msg.sender; highestBid = msg.value; HighestBidIncreased(msg.sender, msg.value); &#125; /// Withdraw a bid that was overbid. function withdraw() returns (bool) &#123; uint amount = pendingReturns[msg.sender]; if (amount &gt; 0) &#123; // It is important to set this to zero because the recipient // can call this function again as part of the receiving call // before `send` returns. pendingReturns[msg.sender] = 0; if (!msg.sender.send(amount)) &#123; // No need to call throw here, just reset the amount owing pendingReturns[msg.sender] = amount; return false; &#125; &#125; return true; &#125; /// End the auction and send the highest bid /// to the beneficiary. function auctionEnd() &#123; // It is a good guideline to structure functions that interact // with other contracts (i.e. they call functions or send Ether) // into three phases: // 1. checking conditions // 2. performing actions (potentially changing conditions) // 3. interacting with other contracts // If these phases are mixed up, the other contract could call // back into the current contract and modify the state or cause // effects (ether payout) to be performed multiple times. // If functions called internally include interaction with external // contracts, they also have to be considered interaction with // external contracts. // 1. Conditions require(now &gt;= (auctionStart + biddingTime)); // auction did not yet end require(!ended); // this function has already been called // 2. Effects ended = true; AuctionEnded(highestBidder, highestBid); // 3. Interaction beneficiary.transfer(highestBid); &#125;&#125; Solidity Example 3：Blink Auction123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144pragma solidity ^0.4.11;contract BlindAuction &#123; struct Bid &#123; bytes32 blindedBid; uint deposit; &#125; address public beneficiary; uint public auctionStart; uint public biddingEnd; uint public revealEnd; bool public ended; mapping(address =&gt; Bid[]) public bids; address public highestBidder; uint public highestBid; // Allowed withdrawals of previous bids mapping(address =&gt; uint) pendingReturns; event AuctionEnded(address winner, uint highestBid); /// Modifiers are a convenient way to validate inputs to /// functions. `onlyBefore` is applied to `bid` below: /// The new function body is the modifier's body where /// `_` is replaced by the old function body. modifier onlyBefore(uint _time) &#123; require(now &lt; _time); _; &#125; modifier onlyAfter(uint _time) &#123; require(now &gt; _time); _; &#125; function BlindAuction( uint _biddingTime, uint _revealTime, address _beneficiary ) &#123; beneficiary = _beneficiary; auctionStart = now; biddingEnd = now + _biddingTime; revealEnd = biddingEnd + _revealTime; &#125; /// Place a blinded bid with `_blindedBid` = keccak256(value, /// fake, secret). /// The sent ether is only refunded if the bid is correctly /// revealed in the revealing phase. The bid is valid if the /// ether sent together with the bid is at least \"value\" and /// \"fake\" is not true. Setting \"fake\" to true and sending /// not the exact amount are ways to hide the real bid but /// still make the required deposit. The same address can /// place multiple bids. function bid(bytes32 _blindedBid) payable onlyBefore(biddingEnd) &#123; bids[msg.sender].push(Bid(&#123; blindedBid: _blindedBid, deposit: msg.value &#125;)); &#125; /// Reveal your blinded bids. You will get a refund for all /// correctly blinded invalid bids and for all bids except for /// the totally highest. function reveal( uint[] _values, bool[] _fake, bytes32[] _secret ) onlyAfter(biddingEnd) onlyBefore(revealEnd) &#123; uint length = bids[msg.sender].length; require(_values.length == length); require(_fake.length == length); require(_secret.length == length); uint refund; for (uint i = 0; i &lt; length; i++) &#123; var bid = bids[msg.sender][i]; var (value, fake, secret) = (_values[i], _fake[i], _secret[i]); if (bid.blindedBid != keccak256(value, fake, secret)) &#123; // Bid was not actually revealed. // Do not refund deposit. continue; &#125; refund += bid.deposit; if (!fake &amp;&amp; bid.deposit &gt;= value) &#123; if (placeBid(msg.sender, value)) refund -= value; &#125; // Make it impossible for the sender to re-claim // the same deposit. bid.blindedBid = 0; &#125; msg.sender.transfer(refund); &#125; // This is an \"internal\" function which means that it // can only be called from the contract itself (or from // derived contracts). function placeBid(address bidder, uint value) internal returns (bool success) &#123; if (value &lt;= highestBid) &#123; return false; &#125; if (highestBidder != 0) &#123; // Refund the previously highest bidder. pendingReturns[highestBidder] += highestBid; &#125; highestBid = value; highestBidder = bidder; return true; &#125; /// Withdraw a bid that was overbid. function withdraw() &#123; uint amount = pendingReturns[msg.sender]; if (amount &gt; 0) &#123; // It is important to set this to zero because the recipient // can call this function again as part of the receiving call // before `send` returns (see the remark above about // conditions -&gt; effects -&gt; interaction). pendingReturns[msg.sender] = 0; msg.sender.transfer(amount); &#125; &#125; /// End the auction and send the highest bid /// to the beneficiary. function auctionEnd() onlyAfter(revealEnd) &#123; require(!ended); AuctionEnded(highestBidder, highestBid); ended = true; // We send all the money we have, because some // of the refunds might have failed. beneficiary.transfer(this.balance); &#125;&#125; Solidity Example 4： Remote Purchase123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384pragma solidity ^0.4.11;contract Purchase &#123; uint public value; address public seller; address public buyer; enum State &#123; Created, Locked, Inactive &#125; State public state; function Purchase() payable &#123; seller = msg.sender; value = msg.value / 2; require((2 * value) == msg.value); &#125; modifier condition(bool _condition) &#123; require(_condition); _; &#125; modifier onlyBuyer() &#123; require(msg.sender == buyer); _; &#125; modifier onlySeller() &#123; require(msg.sender == seller); _; &#125; modifier inState(State _state) &#123; require(state == _state); _; &#125; event Aborted(); event PurchaseConfirmed(); event ItemReceived(); /// Abort the purchase and reclaim the ether. /// Can only be called by the seller before /// the contract is locked. function abort() onlySeller inState(State.Created) &#123; Aborted(); state = State.Inactive; seller.transfer(this.balance); &#125; /// Confirm the purchase as buyer. /// Transaction has to include `2 * value` ether. /// The ether will be locked until confirmReceived /// is called. function confirmPurchase() inState(State.Created) condition(msg.value == (2 * value)) payable &#123; PurchaseConfirmed(); buyer = msg.sender; state = State.Locked; &#125; /// Confirm that you (the buyer) received the item. /// This will release the locked ether. function confirmReceived() onlyBuyer inState(State.Locked) &#123; ItemReceived(); // It is important to change the state first because // otherwise, the contracts called using `send` below // can call in again here. state = State.Inactive; // NOTE: This actually allows both the buyer and the seller to // block the refund - the withdraw pattern should be used. buyer.transfer(value); seller.transfer(this.balance); &#125;&#125; Solidity 語法AddressHolds a 20 byte value (size of an Ethereum address) Members of Addressesaddress包含著有以下的properties： balance：地址的餘額 transfer：轉錢到該地址 若有錯誤會發送exception 1234address x = 0x123;address myAddress = this;if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10); // 送給x這個地址 10塊ether send ：也是轉錢到該地址 若有錯誤只會return false，使用要比較小心 call ：傳送參數（.value()）或函式回傳值給合約， delegatecall 1234address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;nameReg.call(&quot;register&quot;, &quot;MyName&quot;);nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a);nameReg.call.value(10); Enums：類似實作interfaceEnums needs at least one member. 123456789101112131415161718192021222324pragma solidity ^0.4.0;contract test &#123; enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125; ActionChoices choice; ActionChoices constant defaultChoice = ActionChoices.GoStraight; function setGoStraight() &#123; choice = ActionChoices.GoStraight; &#125; // Since enum types are not part of the ABI, the signature of \"getChoice\" // will automatically be changed to \"getChoice() returns (uint8)\" // for all matters external to Solidity. The integer type used is just // large enough to hold all enum values, i.e. if you have more values, // `uint16` will be used and so on. function getChoice() returns (ActionChoices) &#123; return choice; &#125; function getDefaultChoice() returns (uint) &#123; return uint(defaultChoice); &#125;&#125; Functional的種類以及參數(constnat,payble) Internal function： can only be called inside the current contract. External function： consist of an address and a function signature and they can be passed via and returned from external function calls. function宣告的格式：123456789function (&lt;parameter types&gt;) &#123;internal|external&#125; [constant] [payable] [returns (&lt;return types&gt;)]parameter types：參數的形式constant：標註該function為read-only，不會改變contract的state.payable： 設定會需要收ether的函式都要加一個payable屬性，如果沒加而有人呼叫該函式順便帶ether的話就會造成errorex:function (address chairman) &#123;&#125; constant payble returns (uint) &#123;&#125;; 兩種方法存取該function: f： will result in an internal function, this.f： an external function. Internal Example: 類似OOD的Protected、不能被其他合約呼叫12345678910111213141516171819202122232425262728293031323334353637383940414243444546pragma solidity ^0.4.5;library ArrayUtils &#123; // internal functions can be used in internal library functions because // they will be part of the same code context function map(uint[] memory self, function (uint) returns (uint) f) internal returns (uint[] memory r) &#123; r = new uint[](self.length); for (uint i = 0; i &lt; self.length; i++) &#123; r[i] = f(self[i]); &#125; &#125; function reduce( uint[] memory self, function (uint, uint) returns (uint) f ) internal returns (uint r) &#123; r = self[0]; for (uint i = 1; i &lt; self.length; i++) &#123; r = f(r, self[i]); &#125; &#125; function range(uint length) internal returns (uint[] memory r) &#123; r = new uint[](length); for (uint i = 0; i &lt; r.length; i++) &#123; r[i] = i; &#125; &#125;&#125;contract Pyramid &#123; using ArrayUtils for *; function pyramid(uint l) returns (uint) &#123; return ArrayUtils.range(l).map(square).reduce(sum); &#125; function square(uint x) internal returns (uint) &#123; return x * x; &#125; function sum(uint x, uint y) internal returns (uint) &#123; return x + y; &#125;&#125; External： 其他合約可以呼叫該合約的function1234567891011121314151617181920212223242526272829pragma solidity ^0.4.11;contract Oracle &#123; struct Request &#123; bytes data; function(bytes memory) external callback; &#125; Request[] requests; event NewRequest(uint); function query(bytes data, function(bytes memory) external callback) &#123; requests.push(Request(data, callback)); NewRequest(requests.length - 1); &#125; function reply(uint requestID, bytes response) &#123; // Here goes the check that the reply comes from a trusted source requests[requestID].callback(response); &#125;&#125;contract OracleUser &#123; Oracle constant oracle = Oracle(0x1234567); // known contract function buySomething() &#123; oracle.query(\"USD\", this.oracleResponse); &#125; function oracleResponse(bytes response) &#123; require(msg.sender == address(oracle)); // Use the data &#125;&#125; 宣告Arrayex:1uint[] memory a = new uint[](7); 宣告 Struct： 類似宣告一個物件模板 1234struct Funder &#123; address addr; uint amount;&#125; Mappings宣告成： mapping(_KeyType =&gt; _ValueType) 的形式，可以看成是hash table的形式， 123456789101112131415161718pragma solidity ^0.4.0;contract MappingExample &#123; mapping(address =&gt; uint) public balances; //設定balances的index為addreess形態的，映射出後會得到uint型態的回傳值。 function update(uint newBalance) &#123; balances[msg.sender] = newBalance; &#125;&#125;contract MappingUser &#123; function f() returns (uint) &#123; MappingExample m = new MappingExample(); m.update(100); return m.balances(this); &#125;&#125; 其他 Operators Involving LValues（可被assign的value)delete a： 把a初始化成 0（也可以用在array 都設成0, struct 都設成初始值) Ether單位Ether Uint：1 ether =1000000000000000000 wei, (10^18)1000 finney, (10^3)1000000 szabo (10^6) 全域可用變數及函式Special Variables and Functions suicide.(A合約): 將目前合約的所有ether都轉入到指定的Ａ合約(contract) delete：回收宣告的成員，並且返回一些gas當作回收的獎勵。 回收各型態的參考資料：http://me.tryblockchain.org/solidity-delete.html Block and Transaction Properties block.blockhash(uint blockNumber) returns (bytes32): hash of the given block - only works for 256 most recent blocks excluding current block.coinbase (address): current block miner’s address block.difficulty (uint): current block difficulty block.gaslimit (uint): current block gaslimit block.number (uint): current block number block.timestamp (uint): current block timestamp as seconds since unix epoch msg.data (bytes): complete calldata msg.gas (uint): remaining gas msg.sender (address): sender of the message (current call) msg.sig (bytes4): first four bytes of the calldata (i.e. function identifier) msg.value (uint): number of wei sent with the message now (uint): current block timestamp (alias for block.timestamp) tx.gasprice (uint): gas price of the transaction tx.origin (address): sender of the transaction (full call chain)(不建議用) Error Handling assert(bool condition):throws if the condition is not met - to be used for internal errors. require(bool condition):throws if the condition is not met - to be used for errors in inputs or external components. revert():abort execution and revert state changes Mathematical and Cryptographic Functions addmod(uint x, uint y, uint k) returns (uint):compute (x + y) % k where the addition is performed with arbitrary precision and does not wrap around at 2**256. mulmod(uint x, uint y, uint k) returns (uint):compute (x * y) % k where the multiplication is performed with arbitrary precision and does not wrap around at 2**256. keccak256(…) returns (bytes32):compute the Ethereum-SHA-3 (Keccak-256) hash of the (tightly packed) arguments sha256(…) returns (bytes32):compute the SHA-256 hash of the (tightly packed) argumentssha3(…) returns (bytes32):alias to keccak256 ripemd160(…) returns (bytes20):compute RIPEMD-160 hash of the (tightly packed) arguments ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):recover the address associated with the public key from elliptic curve signature or return zero on error (example usage) Solidity的表達和控制的結構（Expressions and Control Structures）Input Parameters and Output Parameters 接收參數和回傳的形式12345678910pragma solidity ^0.4.0;contract Simple &#123; // 接收 uint _a , uint _b變數 // 回傳uint -_sum uint o_product function arithmetics(uint _a, uint _b) returns (uint o_sum, uint o_product) &#123; o_sum = _a + _b; o_product = _a * _b; &#125;&#125; External Function Calls如果要得知呼叫某合約的function會有多少Wei和花費多少gas，可用.value() .gas() 範例中的function info() 如果沒有加上 payable這個keyword，就無法使用 .value() 123456789101112pragma solidity ^0.4.0;contract InfoFeed &#123; // function info() payable returns (uint ret) &#123; return 42; &#125;&#125;contract Consumer &#123; InfoFeed feed; function setFeed(address addr) &#123; feed = InfoFeed(addr); &#125; function callFeed() &#123; feed.info.value(10).gas(800)(); &#125;&#125; Creating Contracts via new123456789101112131415161718192021pragma solidity ^0.4.0;contract D &#123; uint x; function D(uint a) payable &#123; x = a; &#125;&#125;contract C &#123; D d = new D(4); // will be executed as part of C's constructor function createD(uint arg) &#123; D newD = new D(arg); &#125; function createAndEndowD(uint arg, uint amount) &#123; // Send ether along with the creation D newD = (new D).value(amount)(arg); &#125;&#125; Error handling: Assert, Require, Revertand Exceptions require can be used to easily check conditions on inputs. assert can be used for internal error checking. 1234567891011121314pragma solidity ^0.4.0;contract Sharer &#123; function sendHalf(address addr) payable returns (uint balance) &#123; require(msg.value % 2 == 0); // Only allow even numbers uint balanceBeforeTransfer = this.balance; addr.transfer(msg.value / 2); // Since transfer throws an exception on failure and // cannot call back here, there should be no way for us to // still have half of the money. assert(this.balance == balanceBeforeTransfer - msg.value / 2); return this.balance; &#125;&#125; assert 發生的狀況： If you access an array at a too large or negative index (i.e. x[i] where i &gt;= x.length or i &lt; 0). If you access a fixed-length bytesN at a too large or negative index. If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0). If you shift by a negative amount. If you convert a value too big or negative into an enum type. If you call a zero-initialized variable of internal function type. If you call assert with an argument that evaluates to false. require 發生的狀況： Calling throw. Calling require with an argument that evaluates to false. If you call a function via a message call but it does not finish properly (i.e. it runs out of gas, has no matching function, or throws an exception itself), except when a low level operation call, send, delegatecall or callcode is used. The low level operations never throw exceptions but indicate failures by returning false. If you create a contract using the new keyword but the contract creation does not finish properly (see above for the definition of “not finish properly”). If you perform an external function call targeting a contract that contains no code. If your contract receives Ether via a public function without payable modifier (including the constructor and the fallback function). If your contract receives Ether via a public getter function. If a .transfer() fails. Solidity Contract(即Class)創建contract的時候，constructor只會被呼叫一次 合約的Visibility and GettersVisibility： external:External functions are part of the contract interface, which means they can be called from other contracts and via transactions. An external function f cannot be called internally (i.e. f() does not work, but this.f() works). External functions are sometimes more efficient when they receive large arrays of data. public:Public functions are part of the contract interface and can be either called internally or via messages. For public state variables, an automatic getter function (see below) is generated. internal:Those functions and state variables can only be accessed internally (i.e. from within the current contract or contracts deriving from it), without using this. private:Private functions and state variables are only visible for the contract they are defined in and not in derived contracts. Getter Functions123456789pragma solidity ^0.4.0;contract C &#123; uint public data; function x() &#123; data = 3; // internal access 當成state變數 uint val = this.data(); // external access 當成是function &#125;&#125; Function Modifier (類似：函式插槽)Modifier可用用來擴充其他function的內容，需要被inherit才能使用。通常modifier用來設定一些條件，幫助函式被執行時能夠先滿足該條件再被執行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172pragma solidity ^0.4.11;contract owned &#123; function owned() &#123; owner = msg.sender; &#125; address owner; // 該owned合約只有宣告一個modifier onlyOwner，並且沒有使用它 // 該modifier只會被其他有繼承owned contract的合約所使用 // // \"_;\" 要繼承onlyOwner 函式的內容 modifier onlyOwner &#123; require(msg.sender == owner); _; &#125;&#125;contract mortal is owned &#123; // 繼承 owned合約 // close函式 使用modifier \"onlyOwner\" // 且close的內容會插入在 modifier中的 \"_;\"中 // 可以把modifier想像成 slot（插槽) function close() onlyOwner &#123; selfdestruct(owner); &#125;&#125;contract priced &#123; // Modifier 也可以接收參數 modifier costs(uint price) &#123; // 若滿足msg.value &gt;= price 那就執行 使用該modifier函式的內容 if (msg.value &gt;= price) &#123; _; &#125; &#125;&#125;contract Register is priced, owned &#123; mapping (address =&gt; bool) registeredAddresses; uint price; function Register(uint initialPrice) &#123; price = initialPrice; &#125; // 需要提供 payable，register才會接受ether // 使用 costs 的modifier . function register() payable costs(price) &#123; registeredAddresses[msg.sender] = true; &#125; function changePrice(uint _price) onlyOwner &#123; price = _price; &#125;&#125;contract Mutex &#123; bool locked; modifier noReentrancy() &#123; require(!locked); locked = true; _; locked = false; &#125; // noReentrancy 被一個mutex所保護，必須要判斷locked是否是false才能執行 noReentrancy才能執行 // reentrant calls from within // msg.sender.call cannot call f again.因爲lock住了 // 使用 noReentrancy(modifier), function f() noReentrancy returns (uint) &#123; require(msg.sender.call()); return 7; &#125;&#125; Constant State Variables目前僅支援 uint, string使用 宣告一次後就不能再被改變 Constant Functions不會改變contract state的值 1234567pragma solidity ^0.4.0;contract C &#123; function f(uint a, uint b) constant returns (uint) &#123; return a * (b + 42); &#125;&#125; Fallback Function沒有名稱的function,並且沒有接收參數以及不會傳任何值。當呼叫某合約的方法時，沒有辦法成功 如果有合約直接收到ether的話（亦即不是透過send() or transfer() 那就得定義一個fallback function，不然會throw an exception. 1234567891011121314151617181920212223242526pragma solidity ^0.4.0;contract Test &#123; function() &#123; x = 1; &#125; uint x;&#125;// This contract keeps all Ether sent to it with no way// to get it back.contract Sink &#123; function() payable &#123; &#125;&#125;contract Caller &#123; function callTest(Test test) &#123; test.call(0xabcdef01); // hash: 0xabcdef01 不存在 // 故 test.x的結果會變成 test.x = 1 // The following will not compile, but even // if someone sends ether to that contract, // the transaction will fail and reject the // Ether. //test.send(2 ether); &#125;&#125; EventsEvent所寫入的資料會被記錄在一個Receipt（transaction logs)資料裡，並等待被打包進區塊鏈。 白話一點就是：通知全網有一件事情發生。 12345678910111213141516pragma solidity ^0.4.0;contract ClientReceipt &#123; event Deposit( address indexed _from, bytes32 indexed _id, uint _value ); function deposit(bytes32 _id) payable &#123; // Any call to this function (even deeply nested) can // be detected from the JavaScript API by filtering // for `Deposit` to be called. Deposit(msg.sender, _id, msg.value); &#125;&#125; 在javascript API的使用方式如下：1234567891011121314151617181920var abi = /* abi as generated by the compiler */;var ClientReceipt = web3.eth.contract(abi);var clientReceipt = ClientReceipt.at(0x123 /* address */);var event = clientReceipt.Deposit();// watch for changesevent.watch(function(error, result)&#123; // result will contain various information // including the argumets given to the Deposit // call. if (!error) console.log(result);&#125;);// Or pass a callback to start watching immediatelyvar event = clientReceipt.Deposit(function(error, result) &#123; if (!error) console.log(result);&#125;); Inheritance使用 is 來繼承其他contract. 提供多重繼承同時也包含多型當一個合約R繼承其他A,B,C的合約時，只有R的合約被打包進去blockchain，其他ABC不會。（因為是將A,B,C的內容複製到R的合約內) 像是Python的繼承特性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556pragma solidity ^0.4.0;contract owned &#123; function owned() &#123; owner = msg.sender; &#125; address owner;&#125;// 使用 \"is\" 來繼承，可以存取繼承合約的 non-private members (包含 internal function and state variables)，無法透過 this 來做externally access.contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125;&#125;// 當成是 interface，等待被繼承實作contract Config &#123; function lookup(uint id) returns (address adr);&#125;contract NameReg &#123; function register(bytes32 name); function unregister();&#125;// 可以實現多重繼承// 注意的是\"owned\" 一樣也被mortal繼承，故只有一個\"owned\"的instance (和C++的vritual inheritance一樣)contract named is owned, mortal &#123; function named(bytes32 name) &#123; Config config = Config(0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970); NameReg(config.lookup(1)).register(name); &#125;// 可以override 繼承的function.注意要與原本的型態要一致 function kill() &#123; if (msg.sender == owner) &#123; Config config = Config(0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970); NameReg(config.lookup(1)).unregister(); // 依然可以呼叫繼承合約內的函式 mortal.kill(); &#125; &#125;&#125;// 如果繼承的contract中有的人的contractor需要parameter,// 那就得在 is 後面的地方輸入參數，// 如下 \"named(\"GoldFeed\");contract PriceFeed is owned, mortal, named(\"GoldFeed\") &#123; function updateInfo(uint newInfo) &#123; if (msg.sender == owner) info = newInfo; &#125; function get() constant returns(uint r) &#123; return info; &#125; uint info;&#125; 多重繼承要注意的點：12345678910111213141516171819202122232425pragma solidity ^0.4.0;contract owned &#123; function owned() &#123; owner = msg.sender; &#125; address owner;&#125;contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125;&#125;contract Base1 is mortal &#123; function kill() &#123; /* do cleanup 1 */ mortal.kill(); &#125;&#125;contract Base2 is mortal &#123; function kill() &#123; /* do cleanup 2 */ mortal.kill(); &#125;&#125;contract Final is Base1, Base2 &#123;&#125; 呼叫 Final.kill 僅會呼叫到 Base2的 kill function.而忽略掉 Base1 的. Abstract Contracts不實作合約內的function內容，被繼承時在實作。但可以定義變數，建構子等等。 例子：12345pragma solidity ^0.4.0;contract Feline &#123; function utterance() returns (bytes32);&#125; Interfaces和Abstract很像，不過不能有任何的function被實作以下為限制條件 Cannot inherit other contracts or interfaces. Cannot define constructor. Cannot define variables. Cannot define structs. Cannot define enums. 12345pragma solidity ^0.4.11;interface Token &#123; function transfer(address recipient, uint amount);&#125; Libraries和contract(class)很像，不過僅會在特地的address部署一次而已。 因為佈一個contract需要gas，不過如果要重複使用Set的話，又不想重複宣告contract，那就可以用Libraries來實作出一個Set，並且佈出去就會產生一個地址 (linker)，其他合約就可以透過linker來使用Set. 直接看例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950pragma solidity ^0.4.11;library Set &#123; // We define a new struct datatype that will be used to // hold its data in the calling contract. struct Data &#123; mapping(uint =&gt; bool) flags; &#125; // Note that the first parameter is of type \"storage // reference\" and thus only its storage address and not // its contents is passed as part of the call. This is a // special feature of library functions. It is idiomatic // to call the first parameter 'self', if the function can // be seen as a method of that object. function insert(Data storage self, uint value) returns (bool) &#123; if (self.flags[value]) return false; // already there self.flags[value] = true; return true; &#125; function remove(Data storage self, uint value) returns (bool) &#123; if (!self.flags[value]) return false; // not there self.flags[value] = false; return true; &#125; function contains(Data storage self, uint value) returns (bool) &#123; return self.flags[value]; &#125;&#125;contract C &#123; Set.Data knownValues; function register(uint value) &#123; // The library functions can be called without a // specific instance of the library, since the // \"instance\" will be the current contract. require(Set.insert(knownValues, value)); &#125; // In this contract, we can also directly access knownValues.flags, if we want.&#125; Style Guide （套用eslint for solidity) Indentation: 4 spaces (avoid using tabs.) Order of Functions: (function的寫法的優先順序) constructor fallback function (if exists) external public internal private Web3.js 學習目標瞭解：1.如何把key pair抓出來2.如何簽驗章3.如何進行加解密4.如何發events 環簽章 同態加密Confidential transaction（https://www.elementsproject.org/elements/confidential-transactions/ ZKsnark(包含零知識證明)參考：（應用例子：不公開UTXO，也能讓礦工驗證，不過礦工不能解密，不然會失去confidential的特性，不讓receiver知道UTXO）https://z.cash/technology/zksnarks.html","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://a10000005588.github.io/tags/Blockchain/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/tags/Solidity/"}]},{"title":"使用truffle來練習撰寫認養寵物的智能合約","slug":"truffle-petshop","date":"2017-09-07T14:02:57.000Z","updated":"2019-02-05T13:06:17.315Z","comments":true,"path":"2017/09/07/truffle-petshop/","link":"","permalink":"http://a10000005588.github.io/2017/09/07/truffle-petshop/","excerpt":"本篇是翻譯自Truffle官方所釋出的Dapp教學文檔Pet-Shophttp://truffleframework.com/tutorials/pet-shop 執行環境開發前準備首先要安裝testrpc、truffle :12345npm install -g ethereumjs-testrpc// 安裝測試用ethereum私有鍊npm install -g truffle// 開發智能合約的一套框架","text":"本篇是翻譯自Truffle官方所釋出的Dapp教學文檔Pet-Shophttp://truffleframework.com/tutorials/pet-shop 執行環境開發前準備首先要安裝testrpc、truffle :12345npm install -g ethereumjs-testrpc// 安裝測試用ethereum私有鍊npm install -g truffle// 開發智能合約的一套框架 安裝truffle上已經預先包好的練習專案(Truffle box: ETHEREUM PET SHOP)：12345678mkdir pet-shop-tutorial // 創建一個目錄cd pet-shop-tutorial // 切換到該目錄truffle unbox pet-shop// 安裝truffle打包好的pet-shop練習專案檔 目錄架構 /contracts: 存放合約的地方，檔名為.sol，而Migrate.sol是負責紀錄其他合約如何deploy到區塊鏈，不能刪除！ /migrations: 負責將合約掛到區塊鏈上，並且追蹤合約的更動狀況。 /test: 包含Javascript and solidity檔案，負責測試合約內容。 truffle.js : truffle的設定檔 合約內容在/contract 建立 Adoption.sol宣告一個contract:12345678910111213141516171819202122232425262728pragma solidity ^0.4.4;// 告訴compiler 現在要用哪個版本編譯contract Adoption &#123; //宣告一個 contract的class 叫 Adoption // 存放領養飼主的地址（預設是有16隻狗等待被認養） address[16] public adopters; // 有人要認養某隻寵物(petId)，判斷是否可以認養， // 回傳該認養的寵物ID以證明該寵物成功被某用戶認養 function adopt(uint petId) public returns (uint) &#123; require(petId &gt;= 0 &amp;&amp; petId &lt;= 15); // 判斷petId，若不符合結束該函式，不再往下執行 adopters[petId] = msg.sender; // 透過msg.sender取得呼叫該函式的使用者 // 也就是認養該寵物的用戶ID return petId; &#125; // 回傳所有的認養者，回傳值的型態為address[16] function getAdopters() public returns (address[16]) &#123; return adopters; &#125; &#125; 編譯(Compiling)和部署(Migrating)合約寫好合約後，需要將.sol檔進行編譯成.bytecode，才能在EVM (ethereum virtual machine上執行). 然後在terminal上執行 testrpc 啟動 啟動後會出現： 數組帳戶的address以及私鑰 HD wallet的資訊（稍後會提到metatask，會使用到Mnemonic section的資訊) Mnemonic為數個變數的資訊，如下Mnemonic: spider level team helmet shaft clarify abuse recipe stem ankle angry fee 執行 truffle compile 會看到 .sol檔被編譯 Migrationmigrate.sol描述如何將合約的內容部署到鏈上，並且處理合約上state的更動。 在 /migration 檔案內： 1_initial_migration.js： 123456// 引入編譯合約的內容var Migrations = artifacts.require(\"./Migrations.sol\");module.exports = function(deployer) &#123; deployer.deploy(Migrations);&#125;; 透過該檔案可以追蹤後續contract的變化，已部署過的合約且沒有被修改就不用再被部署（不然又會消耗gas). 2_deploy_contracts.js注意，這邊的命名開頭要編號，因為truffle進行migrate時會依據該編號而進行。 12345var Adoption = artifacts.require(\"./Adoption.sol\");module.exports = function(deployer) &#123; deployer.deploy(Adoption);&#125;; 在terminal執行 truffle migrate 會看到如下結果123456789101112Using network &apos;development&apos;.Running migration: 1_initial_migration.js Deploying Migrations... Migrations: 0x75175eb116b36ff5fef15ebd15cbab01b50b50d1Saving successful migration to network...Saving artifacts...Running migration: 2_deploy_contracts.js Deploying Adoption... Adoption: 0xb9f485451a945e65e48d9dd7fc5d759af0a89e21Saving successful migration to network...Saving artifacts... 若看到上述表面表示我們寫的第一隻 Adoption.sol的合約已經成功被部署到鏈上！ 為Smart Contract寫測試我們可以用javascript或solidity寫測試，不過本範例用solidity來寫。 在 /test 目錄下創建 TestAdoption.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748pragma solidity ^0.4.11;// 引用truffle內建的檔案 // Assert.sol用來做Unit test (判斷function input ?= output)import \"truffle/Assert.sol\";// 當測試執行，truffle會在testrpc中測試該合約，// 該DeployedAddresses用來取得被部署合約的addressimport \"truffle/DeployedAddresses.sol\";// 要被測試的合約import \"../contracts/Adoption.sol\";contract TestAdoption &#123; Adoption adoption = Adoption(DeployedAddresses.Adoption()); // Testing The adopt() Function function testUserCanAdoptPet() &#123; // 呼叫Adoption中的adopt方法 uint returnedId = adoption.adopt(8); uint expected = 8; // 判斷returnID 是否等於 expected的值 Assert.equal(returnedId, expected, \"Adoption of pet ID 8 should be recorded.\"); &#125; // Testing Retrieval of a Single Pet's Owner function testGetAdopterAddressByPetId() &#123; // 透過this取得目前合約的地址 address expected = this; address adopter = adoption.adopters(8); Assert.equal(adopter, expected, \"Owner of pet ID 8 should be recorded.\"); &#125; // Testing Retrieval of All Pet Owners function testGetAdopterAddressByPetIdInArray() &#123; address expected = this; address[16] memory adopters = adoption.getAdopters(); Assert.equal(adopters[8], expected, \"Owner of pet ID 8 should be recorded.\"); &#125; &#125; 執行 truffle test 若看到以下畫面表示test通過123456789101112131415Using network &apos;development&apos;.Compiling ./contracts/Adoption.sol...Compiling ./test/TestAdoption.sol...Compiling truffle/Assert.sol...Compiling truffle/DeployedAddresses.sol... TestAdoption ✓ testUserCanAdoptPet (91ms) ✓ testGetAdopterAddressByPetId (70ms) ✓ testGetAdopterAddressByPetIdInArray (89ms) 3 passing (670ms) 使用UI和Smart Contract互動當解開truffle box的pet-shop，可以看到在 /src目錄底下會有已經預設好的UI檔供練習用。 使用Web3.js初始化前端環境Web3.js為用來和ethereum溝通的javascript library.（而練習專案前端是使用jQuery) 在 /src/js/app.js檔案的內容改為以下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131App = &#123; web3Provider: null, contracts: &#123;&#125;, init: function() &#123; // 載入寵物的資料 $.getJSON('../pets.json', function(data) &#123; var petsRow = $('#petsRow'); var petTemplate = $('#petTemplate'); for (i = 0; i &lt; data.length; i ++) &#123; petTemplate.find('.panel-title').text(data[i].name); petTemplate.find('img').attr('src', data[i].picture); petTemplate.find('.pet-breed').text(data[i].breed); petTemplate.find('.pet-age').text(data[i].age); petTemplate.find('.pet-location').text(data[i].location); petTemplate.find('.btn-adopt').attr('data-id', data[i].id); petsRow.append(petTemplate.html()); &#125; &#125;); return App.initWeb3(); &#125;, initWeb3: function() &#123; // 初始化web3.js並且設置provider連接testrpc // 如果偵測到有metamask注入在瀏覽器的web3 instance if (typeof web3 !== 'undefined') &#123; App.web3Provider = web3.currentProvider; // 將currentProvider = metamask // web3 = new Web3(web3.currentProvider); &#125; else &#123; // 若沒有metamask or mist等等之類的， // 那就用自己開啟testrpc當成是provider App.web3Provider = new web3.providers.HttpProvider('http://localhost:8545'); web3 = new Web3(App.web3Provider); &#125; return App.initContract(); &#125;, initContract: function() &#123; $.getJSON('Adoption.json', function(data) &#123; // 取得contract的artifact(Adoption.json) // 例如contract address, ABI (Application Binary Interface)： // 即如何使用contract的變數、函式等等 var AdoptionArtifact = data; // truffle提供`truffle-contract`來幫助我們監聽已經被migrate的contract // 並把contract的artifact傳給truffle-contract'，好讓我們可以跟合約溝通 App.contracts.Adoption = TruffleContract(AdoptionArtifact); // 為contract設置Provider(我們是用metamask) App.contracts.Adoption.setProvider(App.web3Provider); // 從Adpotion.json的合約資料中，判斷寵物的是否已被認養並做標示 return App.markAdopted(); &#125;); return App.bindEvents(); &#125;, bindEvents: function() &#123; $(document).on('click', '.btn-adopt', App.handleAdopt); &#125;, handleAdopt: function() &#123; event.preventDefault(); var petId = parseInt($(event.target).data('id')); var adoptionInstance; // 使用web3來取得user's accounts // 這時metamask會跳出交易訊息出來 web3.eth.getAccounts(function(error, accounts) &#123; if (error) &#123; console.log(error); &#125; // 選擇第一個accounts作為我們的用戶 var account = accounts[0]; App.contracts.Adoption.deployed().then(function(instance) &#123; adoptionInstance = instance; // 在這裡要執行會花費gas的transaction // 取得認養用戶的account，以及點選欲認養的petId return adoptionInstance.adopt(petId, &#123;from: account&#125;); &#125;).then(function(result) &#123; // 若回傳結果正常執行markAdopted刷新UI上寵物認養中的狀態 return App.markAdopted(); &#125;).catch(function(err) &#123; console.log(err.message); &#125;); &#125;); &#125;, markAdopted: function(adopters, account) &#123; var adoptionInstance; App.contracts.Adoption.deployed().then(function(instance) &#123; // 取得Adpotion合約的內容 adoptionInstance = instance; // 呼叫合約中的getAdopters方法 // 利用`call`可以直接讀取Blockchain上的資料，不用花費ether(gas) return adoptionInstance.getAdopters.call(); &#125;).then(function(adopters) &#123; for (i = 0; i &lt; adopters.length; i++) &#123; if (adopters[i] !== '0x0000000000000000000000000000000000000000') &#123; $('.panel-pet').eq(i).find('button').text('Pending...').attr('disabled', true); &#125; &#125; &#125;).catch(function(err) &#123; console.log(err.message); &#125;); &#125;&#125;;$(function() &#123; $(window).load(function() &#123; App.init(); &#125;);&#125;); 在Chrome上和Dapp互動安裝 metamask的擴充套件 長這樣： 由於我們要測試自己的Dapp，點選該圖左上角切換到自己開啟testrpc:8545的私有鏈 因為是初次登入，點選I forgot my password 將一開始開啟testrpc 產生的 Mnemonic（數組變數名稱）貼到wallet seed.Mnemonic:1spider level team helmet shaft clarify abuse recipe stem ankle angry fee (Warning：你的testrpc產生的Mnemonic變數組會跟上面的不一樣) 設置自己的新密碼，確認後點選OK 進入後就會看到自己的第一筆account資訊了 若有顯示帳戶表示成功與testrpc連接(原本testrpc是預設100 ether，顯示出來不是100 ether的原因是因為部署合約到自己的private blockchain也需要費用) 安裝和設置lite-server啟動Dapplite-server已經包含在pet-shop的box內 在 bs-config.json檔案中 12345&#123; &quot;server&quot;: &#123; &quot;baseDir&quot;: [&quot;./src&quot;, &quot;./build/contracts&quot;] &#125;&#125; 該設置告訴server要執行的基底目錄在哪。 ./src：前端的內容./build/contracts：放置合約的內容 在script檔中 1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;lite-server&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;&#125;, 設置 &quot;dev&quot; : lite-server&quot;方便我們可以直接在terminal下執行 npm run dev 來運行Dapp 運行成功後的樣子 若要進行認養：點選 Adopt按鈕 點選Sumit後即完成認養的動作，並且把該認養的資訊透過合約掛到testrpc的鏈上，並在該寵物上狀態改成 Pending... （已認養） 延伸 將前端改成用Vue.js可以考慮用以下package： Vue-Truffle-Webpackhttps://github.com/wilfreddenton/vue-truffle-webpack 顯示該隻狗被哪位用戶認養走 改成要付足夠的錢才能認養該隻狗","categories":[{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/categories/Solidity/"}],"tags":[{"name":"Ethereum","slug":"Ethereum","permalink":"http://a10000005588.github.io/tags/Ethereum/"},{"name":"Solidity","slug":"Solidity","permalink":"http://a10000005588.github.io/tags/Solidity/"},{"name":"Truffle","slug":"Truffle","permalink":"http://a10000005588.github.io/tags/Truffle/"}]},{"title":"利用Hexo來記錄自己的學習並使用Material-flow主題","slug":"How_To_Use_Hexo","date":"2017-09-05T14:58:47.000Z","updated":"2020-01-01T13:28:10.215Z","comments":true,"path":"2017/09/05/How_To_Use_Hexo/","link":"","permalink":"http://a10000005588.github.io/2017/09/05/How_To_Use_Hexo/","excerpt":"Hexo介紹如果要打造自己風格的Blog，那就不能錯過HexoHexo是一套開源的架個人部落格的框架，","text":"Hexo介紹如果要打造自己風格的Blog，那就不能錯過HexoHexo是一套開源的架個人部落格的框架， 其優點如下： 文章以markdown格式為主。 並且能一鍵部署在Github，公開給大家看。 有很多第三方的template theme來裝飾自己的Blog 我目前這個Blog的主題是使用NextT囉 以下會詳細介紹怎麼用Hexo快速架站 Hexo架設流程安裝Hexo1npm install hexo-cli -g 初始化一個Hexo專案，並且運行之1234567hexo init blogcd blognpm installhexo server// 也可以用 hexo s -p 8080 // 指定欲開啟的port number為多少 可以看到新建立好的Blog長這樣 (X) 新增一篇文章1hexo new [layout] &lt;title&gt; [layout]有以下幾種(default為 post)： post：就po一篇文章，文章都放置在 source/_posts中 page：建立獨立的頁面，例如建立about頁面 draft：發佈一篇草稿，如果要公開則下 hexo publish [layout] &lt;title&gt;，將草稿移動到 source/_posts 佈署到自己的github安裝 hexo-deployer-git1npm install hexo-deployer-git --save 修改 _config.yml12345deploy: type: git repo: &lt;repository url&gt; // 儲存庫（Repository）網址 branch: [branch] // 分支名稱 message: [message] // 自定提交訊息 新增好文章後需要產生部署用靜態檔案執行：hexo generate 會產生public目錄 執行 hexo deploy 即可一鍵部署public目錄內容到github.io網站上 注意：github上的repo命名要與你的帳號一樣，否則還得處理路徑問題 若要直接新增好文章後部署：hexo generate --deploy 之後若要重新執行hexo deploy，請先用 hexo clean清除靜態頁面，然後在執行deploy. 使用Material-flow 來改造自己的Blog詳情請看Material-flow 的Github上文件 https://github.com/stkevintan/hexo-theme-material-flow 修改自己的Description在大頭貼下方的描述，若要修改的話得到： ./theme/material-flow/layout/_widget/about.ejs中修改！ 延伸若要對自己Blog做擴充都可以再參考Hexo以及NextT的官方文檔 Hexo官方連結：https://hexo.io/zh-tw/ 如果對其他theme有興趣也可以參考這網站 Hexo官方主題：https://hexo.io/zh-tw/docs/writing.htmlHexo主題排名：https://www.zhihu.com/question/24422335","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://a10000005588.github.io/categories/Hexo/"}],"tags":[{"name":"Frontend","slug":"Frontend","permalink":"http://a10000005588.github.io/tags/Frontend/"}]}]}